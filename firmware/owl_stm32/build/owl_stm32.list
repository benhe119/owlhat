
build/owl_stm32.elf:     file format elf32-littlearm


Disassembly of section .text:

080001a0 <Reset_Handler>:
 80001a0:	b672      	cpsid	i
 80001a2:	4833      	ldr	r0, [pc, #204]	; (8000270 <endfiniloop+0x4>)
 80001a4:	f380 8809 	msr	PSP, r0
 80001a8:	f240 0000 	movw	r0, #0
 80001ac:	f2cc 0000 	movt	r0, #49152	; 0xc000
 80001b0:	f64e 7134 	movw	r1, #61236	; 0xef34
 80001b4:	f2ce 0100 	movt	r1, #57344	; 0xe000
 80001b8:	6008      	str	r0, [r1, #0]
 80001ba:	f3bf 8f4f 	dsb	sy
 80001be:	f3bf 8f6f 	isb	sy
 80001c2:	f240 0000 	movw	r0, #0
 80001c6:	f2c0 00f0 	movt	r0, #240	; 0xf0
 80001ca:	f64e 5188 	movw	r1, #60808	; 0xed88
 80001ce:	f2ce 0100 	movt	r1, #57344	; 0xe000
 80001d2:	6008      	str	r0, [r1, #0]
 80001d4:	f3bf 8f4f 	dsb	sy
 80001d8:	f3bf 8f6f 	isb	sy
 80001dc:	f04f 0000 	mov.w	r0, #0
 80001e0:	eee1 0a10 	vmsr	fpscr, r0
 80001e4:	f64e 713c 	movw	r1, #61244	; 0xef3c
 80001e8:	f2ce 0100 	movt	r1, #57344	; 0xe000
 80001ec:	6008      	str	r0, [r1, #0]
 80001ee:	2006      	movs	r0, #6
 80001f0:	f380 8814 	msr	CONTROL, r0
 80001f4:	f3bf 8f6f 	isb	sy
 80001f8:	f001 f932 	bl	8001460 <__core_init>
 80001fc:	f001 fe48 	bl	8001e90 <__early_init>
 8000200:	f04f 3055 	mov.w	r0, #1431655765	; 0x55555555
 8000204:	491b      	ldr	r1, [pc, #108]	; (8000274 <endfiniloop+0x8>)
 8000206:	4a1c      	ldr	r2, [pc, #112]	; (8000278 <endfiniloop+0xc>)

08000208 <msloop>:
 8000208:	4291      	cmp	r1, r2
 800020a:	bf3c      	itt	cc
 800020c:	f841 0b04 	strcc.w	r0, [r1], #4
 8000210:	e7fa      	bcc.n	8000208 <msloop>
 8000212:	491a      	ldr	r1, [pc, #104]	; (800027c <endfiniloop+0x10>)
 8000214:	4a16      	ldr	r2, [pc, #88]	; (8000270 <endfiniloop+0x4>)

08000216 <psloop>:
 8000216:	4291      	cmp	r1, r2
 8000218:	bf3c      	itt	cc
 800021a:	f841 0b04 	strcc.w	r0, [r1], #4
 800021e:	e7fa      	bcc.n	8000216 <psloop>
 8000220:	4917      	ldr	r1, [pc, #92]	; (8000280 <endfiniloop+0x14>)
 8000222:	4a18      	ldr	r2, [pc, #96]	; (8000284 <endfiniloop+0x18>)
 8000224:	4b18      	ldr	r3, [pc, #96]	; (8000288 <endfiniloop+0x1c>)

08000226 <dloop>:
 8000226:	429a      	cmp	r2, r3
 8000228:	bf3e      	ittt	cc
 800022a:	f851 0b04 	ldrcc.w	r0, [r1], #4
 800022e:	f842 0b04 	strcc.w	r0, [r2], #4
 8000232:	e7f8      	bcc.n	8000226 <dloop>
 8000234:	2000      	movs	r0, #0
 8000236:	4915      	ldr	r1, [pc, #84]	; (800028c <endfiniloop+0x20>)
 8000238:	4a15      	ldr	r2, [pc, #84]	; (8000290 <endfiniloop+0x24>)

0800023a <bloop>:
 800023a:	4291      	cmp	r1, r2
 800023c:	bf3c      	itt	cc
 800023e:	f841 0b04 	strcc.w	r0, [r1], #4
 8000242:	e7fa      	bcc.n	800023a <bloop>
 8000244:	f001 f904 	bl	8001450 <__late_init>
 8000248:	4c12      	ldr	r4, [pc, #72]	; (8000294 <endfiniloop+0x28>)
 800024a:	4d13      	ldr	r5, [pc, #76]	; (8000298 <endfiniloop+0x2c>)

0800024c <initloop>:
 800024c:	42ac      	cmp	r4, r5
 800024e:	da03      	bge.n	8000258 <endinitloop>
 8000250:	f854 1b04 	ldr.w	r1, [r4], #4
 8000254:	4788      	blx	r1
 8000256:	e7f9      	b.n	800024c <initloop>

08000258 <endinitloop>:
 8000258:	f001 ffca 	bl	80021f0 <main>
 800025c:	4c0f      	ldr	r4, [pc, #60]	; (800029c <endfiniloop+0x30>)
 800025e:	4d10      	ldr	r5, [pc, #64]	; (80002a0 <endfiniloop+0x34>)

08000260 <finiloop>:
 8000260:	42ac      	cmp	r4, r5
 8000262:	da03      	bge.n	800026c <endfiniloop>
 8000264:	f854 1b04 	ldr.w	r1, [r4], #4
 8000268:	4788      	blx	r1
 800026a:	e7f9      	b.n	8000260 <finiloop>

0800026c <endfiniloop>:
 800026c:	f001 b8e8 	b.w	8001440 <__default_exit>
 8000270:	20000800 	.word	0x20000800
 8000274:	20000000 	.word	0x20000000
 8000278:	20000400 	.word	0x20000400
 800027c:	20000400 	.word	0x20000400
 8000280:	08004768 	.word	0x08004768
 8000284:	20000800 	.word	0x20000800
 8000288:	20000c4c 	.word	0x20000c4c
 800028c:	20000c50 	.word	0x20000c50
 8000290:	20001c0c 	.word	0x20001c0c
 8000294:	080001a0 	.word	0x080001a0
 8000298:	080001a0 	.word	0x080001a0
 800029c:	080001a0 	.word	0x080001a0
 80002a0:	080001a0 	.word	0x080001a0
	...

080002b0 <_port_switch>:
 80002b0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80002b4:	ed2d 8a10 	vpush	{s16-s31}
 80002b8:	f8c1 d00c 	str.w	sp, [r1, #12]
 80002bc:	f8d0 d00c 	ldr.w	sp, [r0, #12]
 80002c0:	ecbd 8a10 	vpop	{s16-s31}
 80002c4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

080002c8 <_port_thread_start>:
 80002c8:	2300      	movs	r3, #0
 80002ca:	f383 8811 	msr	BASEPRI, r3
 80002ce:	4628      	mov	r0, r5
 80002d0:	47a0      	blx	r4
 80002d2:	2000      	movs	r0, #0
 80002d4:	f001 f85c 	bl	8001390 <chThdExit>

080002d8 <_port_switch_from_isr>:
 80002d8:	f001 f862 	bl	80013a0 <chSchDoReschedule>

080002dc <_port_exit_from_isr>:
 80002dc:	df00      	svc	0
 80002de:	e7fe      	b.n	80002de <_port_exit_from_isr+0x2>

080002e0 <__aeabi_drsub>:
 80002e0:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000
 80002e4:	e002      	b.n	80002ec <__adddf3>
 80002e6:	bf00      	nop

080002e8 <__aeabi_dsub>:
 80002e8:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000

080002ec <__adddf3>:
 80002ec:	b530      	push	{r4, r5, lr}
 80002ee:	ea4f 0441 	mov.w	r4, r1, lsl #1
 80002f2:	ea4f 0543 	mov.w	r5, r3, lsl #1
 80002f6:	ea94 0f05 	teq	r4, r5
 80002fa:	bf08      	it	eq
 80002fc:	ea90 0f02 	teqeq	r0, r2
 8000300:	bf1f      	itttt	ne
 8000302:	ea54 0c00 	orrsne.w	ip, r4, r0
 8000306:	ea55 0c02 	orrsne.w	ip, r5, r2
 800030a:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
 800030e:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 8000312:	f000 80e2 	beq.w	80004da <__adddf3+0x1ee>
 8000316:	ea4f 5454 	mov.w	r4, r4, lsr #21
 800031a:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
 800031e:	bfb8      	it	lt
 8000320:	426d      	neglt	r5, r5
 8000322:	dd0c      	ble.n	800033e <__adddf3+0x52>
 8000324:	442c      	add	r4, r5
 8000326:	ea80 0202 	eor.w	r2, r0, r2
 800032a:	ea81 0303 	eor.w	r3, r1, r3
 800032e:	ea82 0000 	eor.w	r0, r2, r0
 8000332:	ea83 0101 	eor.w	r1, r3, r1
 8000336:	ea80 0202 	eor.w	r2, r0, r2
 800033a:	ea81 0303 	eor.w	r3, r1, r3
 800033e:	2d36      	cmp	r5, #54	; 0x36
 8000340:	bf88      	it	hi
 8000342:	bd30      	pophi	{r4, r5, pc}
 8000344:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 8000348:	ea4f 3101 	mov.w	r1, r1, lsl #12
 800034c:	f44f 1c80 	mov.w	ip, #1048576	; 0x100000
 8000350:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
 8000354:	d002      	beq.n	800035c <__adddf3+0x70>
 8000356:	4240      	negs	r0, r0
 8000358:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 800035c:	f013 4f00 	tst.w	r3, #2147483648	; 0x80000000
 8000360:	ea4f 3303 	mov.w	r3, r3, lsl #12
 8000364:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
 8000368:	d002      	beq.n	8000370 <__adddf3+0x84>
 800036a:	4252      	negs	r2, r2
 800036c:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 8000370:	ea94 0f05 	teq	r4, r5
 8000374:	f000 80a7 	beq.w	80004c6 <__adddf3+0x1da>
 8000378:	f1a4 0401 	sub.w	r4, r4, #1
 800037c:	f1d5 0e20 	rsbs	lr, r5, #32
 8000380:	db0d      	blt.n	800039e <__adddf3+0xb2>
 8000382:	fa02 fc0e 	lsl.w	ip, r2, lr
 8000386:	fa22 f205 	lsr.w	r2, r2, r5
 800038a:	1880      	adds	r0, r0, r2
 800038c:	f141 0100 	adc.w	r1, r1, #0
 8000390:	fa03 f20e 	lsl.w	r2, r3, lr
 8000394:	1880      	adds	r0, r0, r2
 8000396:	fa43 f305 	asr.w	r3, r3, r5
 800039a:	4159      	adcs	r1, r3
 800039c:	e00e      	b.n	80003bc <__adddf3+0xd0>
 800039e:	f1a5 0520 	sub.w	r5, r5, #32
 80003a2:	f10e 0e20 	add.w	lr, lr, #32
 80003a6:	2a01      	cmp	r2, #1
 80003a8:	fa03 fc0e 	lsl.w	ip, r3, lr
 80003ac:	bf28      	it	cs
 80003ae:	f04c 0c02 	orrcs.w	ip, ip, #2
 80003b2:	fa43 f305 	asr.w	r3, r3, r5
 80003b6:	18c0      	adds	r0, r0, r3
 80003b8:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
 80003bc:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 80003c0:	d507      	bpl.n	80003d2 <__adddf3+0xe6>
 80003c2:	f04f 0e00 	mov.w	lr, #0
 80003c6:	f1dc 0c00 	rsbs	ip, ip, #0
 80003ca:	eb7e 0000 	sbcs.w	r0, lr, r0
 80003ce:	eb6e 0101 	sbc.w	r1, lr, r1
 80003d2:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
 80003d6:	d31b      	bcc.n	8000410 <__adddf3+0x124>
 80003d8:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
 80003dc:	d30c      	bcc.n	80003f8 <__adddf3+0x10c>
 80003de:	0849      	lsrs	r1, r1, #1
 80003e0:	ea5f 0030 	movs.w	r0, r0, rrx
 80003e4:	ea4f 0c3c 	mov.w	ip, ip, rrx
 80003e8:	f104 0401 	add.w	r4, r4, #1
 80003ec:	ea4f 5244 	mov.w	r2, r4, lsl #21
 80003f0:	f512 0f80 	cmn.w	r2, #4194304	; 0x400000
 80003f4:	f080 809a 	bcs.w	800052c <__adddf3+0x240>
 80003f8:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
 80003fc:	bf08      	it	eq
 80003fe:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 8000402:	f150 0000 	adcs.w	r0, r0, #0
 8000406:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 800040a:	ea41 0105 	orr.w	r1, r1, r5
 800040e:	bd30      	pop	{r4, r5, pc}
 8000410:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
 8000414:	4140      	adcs	r0, r0
 8000416:	eb41 0101 	adc.w	r1, r1, r1
 800041a:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 800041e:	f1a4 0401 	sub.w	r4, r4, #1
 8000422:	d1e9      	bne.n	80003f8 <__adddf3+0x10c>
 8000424:	f091 0f00 	teq	r1, #0
 8000428:	bf04      	itt	eq
 800042a:	4601      	moveq	r1, r0
 800042c:	2000      	moveq	r0, #0
 800042e:	fab1 f381 	clz	r3, r1
 8000432:	bf08      	it	eq
 8000434:	3320      	addeq	r3, #32
 8000436:	f1a3 030b 	sub.w	r3, r3, #11
 800043a:	f1b3 0220 	subs.w	r2, r3, #32
 800043e:	da0c      	bge.n	800045a <__adddf3+0x16e>
 8000440:	320c      	adds	r2, #12
 8000442:	dd08      	ble.n	8000456 <__adddf3+0x16a>
 8000444:	f102 0c14 	add.w	ip, r2, #20
 8000448:	f1c2 020c 	rsb	r2, r2, #12
 800044c:	fa01 f00c 	lsl.w	r0, r1, ip
 8000450:	fa21 f102 	lsr.w	r1, r1, r2
 8000454:	e00c      	b.n	8000470 <__adddf3+0x184>
 8000456:	f102 0214 	add.w	r2, r2, #20
 800045a:	bfd8      	it	le
 800045c:	f1c2 0c20 	rsble	ip, r2, #32
 8000460:	fa01 f102 	lsl.w	r1, r1, r2
 8000464:	fa20 fc0c 	lsr.w	ip, r0, ip
 8000468:	bfdc      	itt	le
 800046a:	ea41 010c 	orrle.w	r1, r1, ip
 800046e:	4090      	lslle	r0, r2
 8000470:	1ae4      	subs	r4, r4, r3
 8000472:	bfa2      	ittt	ge
 8000474:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
 8000478:	4329      	orrge	r1, r5
 800047a:	bd30      	popge	{r4, r5, pc}
 800047c:	ea6f 0404 	mvn.w	r4, r4
 8000480:	3c1f      	subs	r4, #31
 8000482:	da1c      	bge.n	80004be <__adddf3+0x1d2>
 8000484:	340c      	adds	r4, #12
 8000486:	dc0e      	bgt.n	80004a6 <__adddf3+0x1ba>
 8000488:	f104 0414 	add.w	r4, r4, #20
 800048c:	f1c4 0220 	rsb	r2, r4, #32
 8000490:	fa20 f004 	lsr.w	r0, r0, r4
 8000494:	fa01 f302 	lsl.w	r3, r1, r2
 8000498:	ea40 0003 	orr.w	r0, r0, r3
 800049c:	fa21 f304 	lsr.w	r3, r1, r4
 80004a0:	ea45 0103 	orr.w	r1, r5, r3
 80004a4:	bd30      	pop	{r4, r5, pc}
 80004a6:	f1c4 040c 	rsb	r4, r4, #12
 80004aa:	f1c4 0220 	rsb	r2, r4, #32
 80004ae:	fa20 f002 	lsr.w	r0, r0, r2
 80004b2:	fa01 f304 	lsl.w	r3, r1, r4
 80004b6:	ea40 0003 	orr.w	r0, r0, r3
 80004ba:	4629      	mov	r1, r5
 80004bc:	bd30      	pop	{r4, r5, pc}
 80004be:	fa21 f004 	lsr.w	r0, r1, r4
 80004c2:	4629      	mov	r1, r5
 80004c4:	bd30      	pop	{r4, r5, pc}
 80004c6:	f094 0f00 	teq	r4, #0
 80004ca:	f483 1380 	eor.w	r3, r3, #1048576	; 0x100000
 80004ce:	bf06      	itte	eq
 80004d0:	f481 1180 	eoreq.w	r1, r1, #1048576	; 0x100000
 80004d4:	3401      	addeq	r4, #1
 80004d6:	3d01      	subne	r5, #1
 80004d8:	e74e      	b.n	8000378 <__adddf3+0x8c>
 80004da:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 80004de:	bf18      	it	ne
 80004e0:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 80004e4:	d029      	beq.n	800053a <__adddf3+0x24e>
 80004e6:	ea94 0f05 	teq	r4, r5
 80004ea:	bf08      	it	eq
 80004ec:	ea90 0f02 	teqeq	r0, r2
 80004f0:	d005      	beq.n	80004fe <__adddf3+0x212>
 80004f2:	ea54 0c00 	orrs.w	ip, r4, r0
 80004f6:	bf04      	itt	eq
 80004f8:	4619      	moveq	r1, r3
 80004fa:	4610      	moveq	r0, r2
 80004fc:	bd30      	pop	{r4, r5, pc}
 80004fe:	ea91 0f03 	teq	r1, r3
 8000502:	bf1e      	ittt	ne
 8000504:	2100      	movne	r1, #0
 8000506:	2000      	movne	r0, #0
 8000508:	bd30      	popne	{r4, r5, pc}
 800050a:	ea5f 5c54 	movs.w	ip, r4, lsr #21
 800050e:	d105      	bne.n	800051c <__adddf3+0x230>
 8000510:	0040      	lsls	r0, r0, #1
 8000512:	4149      	adcs	r1, r1
 8000514:	bf28      	it	cs
 8000516:	f041 4100 	orrcs.w	r1, r1, #2147483648	; 0x80000000
 800051a:	bd30      	pop	{r4, r5, pc}
 800051c:	f514 0480 	adds.w	r4, r4, #4194304	; 0x400000
 8000520:	bf3c      	itt	cc
 8000522:	f501 1180 	addcc.w	r1, r1, #1048576	; 0x100000
 8000526:	bd30      	popcc	{r4, r5, pc}
 8000528:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 800052c:	f045 41fe 	orr.w	r1, r5, #2130706432	; 0x7f000000
 8000530:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 8000534:	f04f 0000 	mov.w	r0, #0
 8000538:	bd30      	pop	{r4, r5, pc}
 800053a:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 800053e:	bf1a      	itte	ne
 8000540:	4619      	movne	r1, r3
 8000542:	4610      	movne	r0, r2
 8000544:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
 8000548:	bf1c      	itt	ne
 800054a:	460b      	movne	r3, r1
 800054c:	4602      	movne	r2, r0
 800054e:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 8000552:	bf06      	itte	eq
 8000554:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
 8000558:	ea91 0f03 	teqeq	r1, r3
 800055c:	f441 2100 	orrne.w	r1, r1, #524288	; 0x80000
 8000560:	bd30      	pop	{r4, r5, pc}
 8000562:	bf00      	nop

08000564 <__aeabi_ui2d>:
 8000564:	f090 0f00 	teq	r0, #0
 8000568:	bf04      	itt	eq
 800056a:	2100      	moveq	r1, #0
 800056c:	4770      	bxeq	lr
 800056e:	b530      	push	{r4, r5, lr}
 8000570:	f44f 6480 	mov.w	r4, #1024	; 0x400
 8000574:	f104 0432 	add.w	r4, r4, #50	; 0x32
 8000578:	f04f 0500 	mov.w	r5, #0
 800057c:	f04f 0100 	mov.w	r1, #0
 8000580:	e750      	b.n	8000424 <__adddf3+0x138>
 8000582:	bf00      	nop

08000584 <__aeabi_i2d>:
 8000584:	f090 0f00 	teq	r0, #0
 8000588:	bf04      	itt	eq
 800058a:	2100      	moveq	r1, #0
 800058c:	4770      	bxeq	lr
 800058e:	b530      	push	{r4, r5, lr}
 8000590:	f44f 6480 	mov.w	r4, #1024	; 0x400
 8000594:	f104 0432 	add.w	r4, r4, #50	; 0x32
 8000598:	f010 4500 	ands.w	r5, r0, #2147483648	; 0x80000000
 800059c:	bf48      	it	mi
 800059e:	4240      	negmi	r0, r0
 80005a0:	f04f 0100 	mov.w	r1, #0
 80005a4:	e73e      	b.n	8000424 <__adddf3+0x138>
 80005a6:	bf00      	nop

080005a8 <__aeabi_f2d>:
 80005a8:	0042      	lsls	r2, r0, #1
 80005aa:	ea4f 01e2 	mov.w	r1, r2, asr #3
 80005ae:	ea4f 0131 	mov.w	r1, r1, rrx
 80005b2:	ea4f 7002 	mov.w	r0, r2, lsl #28
 80005b6:	bf1f      	itttt	ne
 80005b8:	f012 437f 	andsne.w	r3, r2, #4278190080	; 0xff000000
 80005bc:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
 80005c0:	f081 5160 	eorne.w	r1, r1, #939524096	; 0x38000000
 80005c4:	4770      	bxne	lr
 80005c6:	f092 0f00 	teq	r2, #0
 80005ca:	bf14      	ite	ne
 80005cc:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
 80005d0:	4770      	bxeq	lr
 80005d2:	b530      	push	{r4, r5, lr}
 80005d4:	f44f 7460 	mov.w	r4, #896	; 0x380
 80005d8:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 80005dc:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 80005e0:	e720      	b.n	8000424 <__adddf3+0x138>
 80005e2:	bf00      	nop

080005e4 <__aeabi_ul2d>:
 80005e4:	ea50 0201 	orrs.w	r2, r0, r1
 80005e8:	bf08      	it	eq
 80005ea:	4770      	bxeq	lr
 80005ec:	b530      	push	{r4, r5, lr}
 80005ee:	f04f 0500 	mov.w	r5, #0
 80005f2:	e00a      	b.n	800060a <__aeabi_l2d+0x16>

080005f4 <__aeabi_l2d>:
 80005f4:	ea50 0201 	orrs.w	r2, r0, r1
 80005f8:	bf08      	it	eq
 80005fa:	4770      	bxeq	lr
 80005fc:	b530      	push	{r4, r5, lr}
 80005fe:	f011 4500 	ands.w	r5, r1, #2147483648	; 0x80000000
 8000602:	d502      	bpl.n	800060a <__aeabi_l2d+0x16>
 8000604:	4240      	negs	r0, r0
 8000606:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 800060a:	f44f 6480 	mov.w	r4, #1024	; 0x400
 800060e:	f104 0432 	add.w	r4, r4, #50	; 0x32
 8000612:	ea5f 5c91 	movs.w	ip, r1, lsr #22
 8000616:	f43f aedc 	beq.w	80003d2 <__adddf3+0xe6>
 800061a:	f04f 0203 	mov.w	r2, #3
 800061e:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 8000622:	bf18      	it	ne
 8000624:	3203      	addne	r2, #3
 8000626:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 800062a:	bf18      	it	ne
 800062c:	3203      	addne	r2, #3
 800062e:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
 8000632:	f1c2 0320 	rsb	r3, r2, #32
 8000636:	fa00 fc03 	lsl.w	ip, r0, r3
 800063a:	fa20 f002 	lsr.w	r0, r0, r2
 800063e:	fa01 fe03 	lsl.w	lr, r1, r3
 8000642:	ea40 000e 	orr.w	r0, r0, lr
 8000646:	fa21 f102 	lsr.w	r1, r1, r2
 800064a:	4414      	add	r4, r2
 800064c:	e6c1      	b.n	80003d2 <__adddf3+0xe6>
 800064e:	bf00      	nop

08000650 <SVC_Handler>:
/*lint -restore*/
  struct port_extctx *ctxp;

#if CORTEX_USE_FPU
  /* Enforcing unstacking of the FP part of the context.*/
  FPU->FPCCR &= ~FPU_FPCCR_LSPACT_Msk;
 8000650:	4a06      	ldr	r2, [pc, #24]	; (800066c <SVC_Handler+0x1c>)
 8000652:	6853      	ldr	r3, [r2, #4]
 8000654:	f023 0301 	bic.w	r3, r3, #1
 8000658:	6053      	str	r3, [r2, #4]
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 800065a:	f3ef 8309 	mrs	r3, PSP
  /* The port_extctx structure is pointed by the PSP register.*/
  ctxp = (struct port_extctx *)__get_PSP();

  /* Discarding the current exception context and positioning the stack to
     point to the real one.*/
  ctxp++;
 800065e:	3368      	adds	r3, #104	; 0x68

    \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
 8000660:	f383 8809 	msr	PSP, r3

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 8000664:	2300      	movs	r3, #0
 8000666:	f383 8811 	msr	BASEPRI, r3
 800066a:	4770      	bx	lr
 800066c:	e000ef30 	.word	0xe000ef30

08000670 <chCoreAlloc>:
 8000670:	2320      	movs	r3, #32
 8000672:	f383 8811 	msr	BASEPRI, r3

  chDbgCheckClassI();

  size = MEM_ALIGN_NEXT(size);
  /*lint -save -e9033 [10.8] The cast is safe.*/
  if ((size_t)(endmem - nextmem) < size) {
 8000676:	4909      	ldr	r1, [pc, #36]	; (800069c <chCoreAlloc+0x2c>)
 8000678:	4a09      	ldr	r2, [pc, #36]	; (80006a0 <chCoreAlloc+0x30>)
void *chCoreAllocI(size_t size) {
  void *p;

  chDbgCheckClassI();

  size = MEM_ALIGN_NEXT(size);
 800067a:	1dc3      	adds	r3, r0, #7
  /*lint -save -e9033 [10.8] The cast is safe.*/
  if ((size_t)(endmem - nextmem) < size) {
 800067c:	6812      	ldr	r2, [r2, #0]
 800067e:	6808      	ldr	r0, [r1, #0]
void *chCoreAllocI(size_t size) {
  void *p;

  chDbgCheckClassI();

  size = MEM_ALIGN_NEXT(size);
 8000680:	f023 0307 	bic.w	r3, r3, #7
  /*lint -save -e9033 [10.8] The cast is safe.*/
  if ((size_t)(endmem - nextmem) < size) {
 8000684:	1a12      	subs	r2, r2, r0
 8000686:	429a      	cmp	r2, r3
  /*lint -restore*/
    return NULL;
  }
  p = nextmem;
  nextmem += size;
 8000688:	bf28      	it	cs
 800068a:	181b      	addcs	r3, r3, r0
 800068c:	f04f 0200 	mov.w	r2, #0
 8000690:	bf2c      	ite	cs
 8000692:	600b      	strcs	r3, [r1, #0]

  size = MEM_ALIGN_NEXT(size);
  /*lint -save -e9033 [10.8] The cast is safe.*/
  if ((size_t)(endmem - nextmem) < size) {
  /*lint -restore*/
    return NULL;
 8000694:	4610      	movcc	r0, r2
 8000696:	f382 8811 	msr	BASEPRI, r2
  chSysLock();
  p = chCoreAllocI(size);
  chSysUnlock();

  return p;
}
 800069a:	4770      	bx	lr
 800069c:	20001258 	.word	0x20001258
 80006a0:	20001264 	.word	0x20001264
	...

080006b0 <queue_prio_insert>:
  tlp->p_next = tp->p_next;

  return tp;
}

static inline void queue_prio_insert(thread_t *tp, threads_queue_t *tqp) {
 80006b0:	b510      	push	{r4, lr}
 80006b2:	460b      	mov	r3, r1

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->p_next;
 80006b4:	681b      	ldr	r3, [r3, #0]
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
 80006b6:	428b      	cmp	r3, r1
 80006b8:	d004      	beq.n	80006c4 <queue_prio_insert+0x14>
 80006ba:	689c      	ldr	r4, [r3, #8]
 80006bc:	6882      	ldr	r2, [r0, #8]
 80006be:	4294      	cmp	r4, r2
 80006c0:	d2f8      	bcs.n	80006b4 <queue_prio_insert+0x4>
 80006c2:	4619      	mov	r1, r3
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 80006c4:	684b      	ldr	r3, [r1, #4]

  thread_t *cp = (thread_t *)tqp;
  do {
    cp = cp->p_next;
  } while ((cp != (thread_t *)tqp) && (cp->p_prio >= tp->p_prio));
  tp->p_next = cp;
 80006c6:	6001      	str	r1, [r0, #0]
  tp->p_prev = cp->p_prev;
 80006c8:	6043      	str	r3, [r0, #4]
  tp->p_prev->p_next = tp;
 80006ca:	6018      	str	r0, [r3, #0]
  cp->p_prev = tp;
 80006cc:	6048      	str	r0, [r1, #4]
 80006ce:	bd10      	pop	{r4, pc}

080006d0 <_idle_thread.lto_priv.65>:
 *          that this thread is executed only if there are no other ready
 *          threads in the system.
 *
 * @param[in] p         the thread parameter, unused in this scenario
 */
static void _idle_thread(void *p) {
 80006d0:	e7fe      	b.n	80006d0 <_idle_thread.lto_priv.65>
	...

080006e0 <chSchDoRescheduleAhead>:
 * @special
 */
void chSchDoRescheduleAhead(void) {
  thread_t *otp, *cp;

  otp = currp;
 80006e0:	4b0c      	ldr	r3, [pc, #48]	; (8000714 <chSchDoRescheduleAhead+0x34>)
  tp->p_prev->p_next = tp;
  tqp->p_prev = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;
 80006e2:	6818      	ldr	r0, [r3, #0]
 80006e4:	6999      	ldr	r1, [r3, #24]

  tqp->p_next = tp->p_next;
 80006e6:	6802      	ldr	r2, [r0, #0]
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoRescheduleAhead(void) {
 80006e8:	b510      	push	{r4, lr}
  tqp->p_next->p_prev = (thread_t *)tqp;
 80006ea:	6053      	str	r3, [r2, #4]
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  tqp->p_next = tp->p_next;
 80006ec:	601a      	str	r2, [r3, #0]
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
  if (otp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
 80006ee:	2201      	movs	r2, #1
 80006f0:	7702      	strb	r2, [r0, #28]

  otp->p_state = CH_STATE_READY;
 80006f2:	2200      	movs	r2, #0
 80006f4:	770a      	strb	r2, [r1, #28]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio > otp->p_prio);
 80006f6:	688a      	ldr	r2, [r1, #8]
void chSchDoRescheduleAhead(void) {
  thread_t *otp, *cp;

  otp = currp;
  /* Picks the first thread from the ready queue and makes it current.*/
  setcurrp(queue_fifo_remove(&ch.rlist.r_queue));
 80006f8:	6198      	str	r0, [r3, #24]
  currp->p_state = CH_STATE_CURRENT;

  otp->p_state = CH_STATE_READY;
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
 80006fa:	681b      	ldr	r3, [r3, #0]
  } while (cp->p_prio > otp->p_prio);
 80006fc:	689c      	ldr	r4, [r3, #8]
 80006fe:	4294      	cmp	r4, r2
 8000700:	d8fb      	bhi.n	80006fa <chSchDoRescheduleAhead+0x1a>
  /* Insertion on p_prev.*/
  otp->p_next = cp;
  otp->p_prev = cp->p_prev;
 8000702:	685a      	ldr	r2, [r3, #4]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio > otp->p_prio);
  /* Insertion on p_prev.*/
  otp->p_next = cp;
 8000704:	600b      	str	r3, [r1, #0]
  otp->p_prev = cp->p_prev;
 8000706:	604a      	str	r2, [r1, #4]
  otp->p_prev->p_next = otp;
  cp->p_prev = otp;

  chSysSwitch(currp, otp);
}
 8000708:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    cp = cp->p_next;
  } while (cp->p_prio > otp->p_prio);
  /* Insertion on p_prev.*/
  otp->p_next = cp;
  otp->p_prev = cp->p_prev;
  otp->p_prev->p_next = otp;
 800070c:	6011      	str	r1, [r2, #0]
  cp->p_prev = otp;
 800070e:	6059      	str	r1, [r3, #4]

  chSysSwitch(currp, otp);
 8000710:	f7ff bdce 	b.w	80002b0 <_port_switch>
 8000714:	20001a00 	.word	0x20001a00
	...

08000720 <dmaStreamAllocate>:
 * @special
 */
bool dmaStreamAllocate(const stm32_dma_stream_t *dmastp,
                       uint32_t priority,
                       stm32_dmaisr_t func,
                       void *param) {
 8000720:	b5f0      	push	{r4, r5, r6, r7, lr}

  osalDbgCheck(dmastp != NULL);

  /* Checks if the stream is already taken.*/
  if ((dma_streams_mask & (1 << dmastp->selfindex)) != 0)
 8000722:	4f25      	ldr	r7, [pc, #148]	; (80007b8 <dmaStreamAllocate+0x98>)
 8000724:	7a46      	ldrb	r6, [r0, #9]
 8000726:	683c      	ldr	r4, [r7, #0]
 * @special
 */
bool dmaStreamAllocate(const stm32_dma_stream_t *dmastp,
                       uint32_t priority,
                       stm32_dmaisr_t func,
                       void *param) {
 8000728:	4605      	mov	r5, r0

  osalDbgCheck(dmastp != NULL);

  /* Checks if the stream is already taken.*/
  if ((dma_streams_mask & (1 << dmastp->selfindex)) != 0)
 800072a:	2001      	movs	r0, #1
 800072c:	fa00 fe06 	lsl.w	lr, r0, r6
 8000730:	ea1e 0f04 	tst.w	lr, r4
 8000734:	d13e      	bne.n	80007b4 <dmaStreamAllocate+0x94>
    return TRUE;

  /* Marks the stream as allocated.*/
  dma_isr_redir[dmastp->selfindex].dma_func  = func;
 8000736:	4821      	ldr	r0, [pc, #132]	; (80007bc <dmaStreamAllocate+0x9c>)
 8000738:	f840 2036 	str.w	r2, [r0, r6, lsl #3]
  dma_isr_redir[dmastp->selfindex].dma_param = param;
 800073c:	eb00 00c6 	add.w	r0, r0, r6, lsl #3
 8000740:	6043      	str	r3, [r0, #4]
  dma_streams_mask |= (1 << dmastp->selfindex);
 8000742:	ea4e 0304 	orr.w	r3, lr, r4

  /* Enabling DMA clocks required by the current streams set.*/
  if ((dma_streams_mask & STM32_DMA1_STREAMS_MASK) != 0)
 8000746:	0658      	lsls	r0, r3, #25
    rccEnableDMA1(FALSE);
 8000748:	bf18      	it	ne
 800074a:	4c1d      	ldrne	r4, [pc, #116]	; (80007c0 <dmaStreamAllocate+0xa0>)
    return TRUE;

  /* Marks the stream as allocated.*/
  dma_isr_redir[dmastp->selfindex].dma_func  = func;
  dma_isr_redir[dmastp->selfindex].dma_param = param;
  dma_streams_mask |= (1 << dmastp->selfindex);
 800074c:	603b      	str	r3, [r7, #0]

  /* Enabling DMA clocks required by the current streams set.*/
  if ((dma_streams_mask & STM32_DMA1_STREAMS_MASK) != 0)
    rccEnableDMA1(FALSE);
 800074e:	bf1e      	ittt	ne
 8000750:	6960      	ldrne	r0, [r4, #20]
 8000752:	f040 0001 	orrne.w	r0, r0, #1
 8000756:	6160      	strne	r0, [r4, #20]
#if STM32_HAS_DMA2
  if ((dma_streams_mask & STM32_DMA2_STREAMS_MASK) != 0)
 8000758:	f413 6f78 	tst.w	r3, #3968	; 0xf80
    rccEnableDMA2(FALSE);
 800075c:	bf18      	it	ne
 800075e:	4818      	ldrne	r0, [pc, #96]	; (80007c0 <dmaStreamAllocate+0xa0>)
#endif

  /* Putting the stream in a safe state.*/
  dmaStreamDisable(dmastp);
 8000760:	686c      	ldr	r4, [r5, #4]
  /* Enabling DMA clocks required by the current streams set.*/
  if ((dma_streams_mask & STM32_DMA1_STREAMS_MASK) != 0)
    rccEnableDMA1(FALSE);
#if STM32_HAS_DMA2
  if ((dma_streams_mask & STM32_DMA2_STREAMS_MASK) != 0)
    rccEnableDMA2(FALSE);
 8000762:	bf1e      	ittt	ne
 8000764:	6943      	ldrne	r3, [r0, #20]
 8000766:	f043 0302 	orrne.w	r3, r3, #2
 800076a:	6143      	strne	r3, [r0, #20]
#endif

  /* Putting the stream in a safe state.*/
  dmaStreamDisable(dmastp);
 800076c:	682b      	ldr	r3, [r5, #0]
 800076e:	6818      	ldr	r0, [r3, #0]
 8000770:	f020 000f 	bic.w	r0, r0, #15
 8000774:	6018      	str	r0, [r3, #0]
 8000776:	7a2e      	ldrb	r6, [r5, #8]
 8000778:	200f      	movs	r0, #15
 800077a:	40b0      	lsls	r0, r6
 800077c:	6020      	str	r0, [r4, #0]
  dmastp->channel->CCR = STM32_DMA_CCR_RESET_VALUE;
 800077e:	2000      	movs	r0, #0
 8000780:	6018      	str	r0, [r3, #0]

  /* Enables the associated IRQ vector if a callback is defined.*/
  if (func != NULL)
 8000782:	b1b2      	cbz	r2, 80007b2 <dmaStreamAllocate+0x92>
    nvicEnableVector(dmastp->vector, priority);
 8000784:	7aab      	ldrb	r3, [r5, #10]
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8000786:	f003 021f 	and.w	r2, r3, #31

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 800078a:	f103 4460 	add.w	r4, r3, #3758096384	; 0xe0000000
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 800078e:	095b      	lsrs	r3, r3, #5

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8000790:	f504 4461 	add.w	r4, r4, #57600	; 0xe100
 8000794:	0109      	lsls	r1, r1, #4
 8000796:	009b      	lsls	r3, r3, #2
 8000798:	b2c9      	uxtb	r1, r1
 800079a:	f103 4360 	add.w	r3, r3, #3758096384	; 0xe0000000
 800079e:	f884 1300 	strb.w	r1, [r4, #768]	; 0x300
 80007a2:	f503 4361 	add.w	r3, r3, #57600	; 0xe100
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 80007a6:	2101      	movs	r1, #1
 80007a8:	4091      	lsls	r1, r2
 80007aa:	f8c3 1180 	str.w	r1, [r3, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 80007ae:	6019      	str	r1, [r3, #0]
 80007b0:	bdf0      	pop	{r4, r5, r6, r7, pc}
  /* Putting the stream in a safe state.*/
  dmaStreamDisable(dmastp);
  dmastp->channel->CCR = STM32_DMA_CCR_RESET_VALUE;

  /* Enables the associated IRQ vector if a callback is defined.*/
  if (func != NULL)
 80007b2:	4610      	mov	r0, r2
    nvicEnableVector(dmastp->vector, priority);

  return FALSE;
}
 80007b4:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80007b6:	bf00      	nop
 80007b8:	20000e80 	.word	0x20000e80
 80007bc:	20000e20 	.word	0x20000e20
 80007c0:	40021000 	.word	0x40021000
	...

080007d0 <sdStart>:
 *                      If this parameter is set to @p NULL then a default
 *                      configuration is used.
 *
 * @api
 */
void sdStart(SerialDriver *sdp, const SerialConfig *config) {
 80007d0:	b510      	push	{r4, lr}
 80007d2:	2220      	movs	r2, #32
 80007d4:	f382 8811 	msr	BASEPRI, r2
 * @notapi
 */
void sd_lld_start(SerialDriver *sdp, const SerialConfig *config) {

  if (config == NULL)
    config = &default_config;
 80007d8:	4b20      	ldr	r3, [pc, #128]	; (800085c <sdStart+0x8c>)
 80007da:	2900      	cmp	r1, #0
 80007dc:	bf08      	it	eq
 80007de:	4619      	moveq	r1, r3

  if (sdp->state == SD_STOP) {
 80007e0:	7a03      	ldrb	r3, [r0, #8]
 80007e2:	2b01      	cmp	r3, #1
 80007e4:	d11c      	bne.n	8000820 <sdStart+0x50>
#if STM32_SERIAL_USE_USART1
    if (&SD1 == sdp) {
 80007e6:	4b1e      	ldr	r3, [pc, #120]	; (8000860 <sdStart+0x90>)
 80007e8:	4298      	cmp	r0, r3
 80007ea:	d109      	bne.n	8000800 <sdStart+0x30>
      rccEnableUSART1(FALSE);
 80007ec:	4c1d      	ldr	r4, [pc, #116]	; (8000864 <sdStart+0x94>)
 80007ee:	69a3      	ldr	r3, [r4, #24]
 80007f0:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 80007f4:	61a3      	str	r3, [r4, #24]

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 80007f6:	4b1c      	ldr	r3, [pc, #112]	; (8000868 <sdStart+0x98>)
 80007f8:	24c0      	movs	r4, #192	; 0xc0
 80007fa:	f883 4325 	strb.w	r4, [r3, #805]	; 0x325
 80007fe:	e00c      	b.n	800081a <sdStart+0x4a>
      nvicEnableVector(STM32_USART1_NUMBER, STM32_SERIAL_USART1_PRIORITY);
    }
#endif
#if STM32_SERIAL_USE_USART2
    if (&SD2 == sdp) {
 8000800:	4b1a      	ldr	r3, [pc, #104]	; (800086c <sdStart+0x9c>)
 8000802:	4298      	cmp	r0, r3
 8000804:	d10c      	bne.n	8000820 <sdStart+0x50>
      rccEnableUSART2(FALSE);
 8000806:	4a17      	ldr	r2, [pc, #92]	; (8000864 <sdStart+0x94>)
 8000808:	69d3      	ldr	r3, [r2, #28]
 800080a:	f443 3300 	orr.w	r3, r3, #131072	; 0x20000
 800080e:	61d3      	str	r3, [r2, #28]
 8000810:	4b15      	ldr	r3, [pc, #84]	; (8000868 <sdStart+0x98>)
 8000812:	22c0      	movs	r2, #192	; 0xc0
 8000814:	f883 2326 	strb.w	r2, [r3, #806]	; 0x326
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8000818:	2240      	movs	r2, #64	; 0x40
 800081a:	f8c3 2184 	str.w	r2, [r3, #388]	; 0x184
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 800081e:	605a      	str	r2, [r3, #4]
 *
 * @param[in] sdp       pointer to a @p SerialDriver object
 * @param[in] config    the architecture-dependent serial driver configuration
 */
static void usart_init(SerialDriver *sdp, const SerialConfig *config) {
  USART_TypeDef *u = sdp->usart;
 8000820:	6f43      	ldr	r3, [r0, #116]	; 0x74

  /* Baud rate setting.*/
  u->BRR = (uint16_t)(sdp->clock / config->speed);
 8000822:	680c      	ldr	r4, [r1, #0]
 8000824:	6f82      	ldr	r2, [r0, #120]	; 0x78
 8000826:	fbb2 f2f4 	udiv	r2, r2, r4
 800082a:	b292      	uxth	r2, r2
 800082c:	60da      	str	r2, [r3, #12]

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
 800082e:	688a      	ldr	r2, [r1, #8]
 8000830:	f042 0240 	orr.w	r2, r2, #64	; 0x40
 8000834:	605a      	str	r2, [r3, #4]
  u->CR3 = config->cr3 | USART_CR3_EIE;
 8000836:	68ca      	ldr	r2, [r1, #12]
 8000838:	f042 0201 	orr.w	r2, r2, #1
 800083c:	609a      	str	r2, [r3, #8]
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
                         USART_CR1_RXNEIE | USART_CR1_TE |
 800083e:	684a      	ldr	r2, [r1, #4]
 8000840:	f442 7296 	orr.w	r2, r2, #300	; 0x12c
 8000844:	f042 0201 	orr.w	r2, r2, #1
  u->BRR = (uint16_t)(sdp->clock / config->speed);

  /* Note that some bits are enforced.*/
  u->CR2 = config->cr2 | USART_CR2_LBDIE;
  u->CR3 = config->cr3 | USART_CR3_EIE;
  u->CR1 = config->cr1 | USART_CR1_UE | USART_CR1_PEIE |
 8000848:	601a      	str	r2, [r3, #0]
                         USART_CR1_RXNEIE | USART_CR1_TE |
                         USART_CR1_RE;
  u->ICR = 0xFFFFFFFF;
 800084a:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 800084e:	621a      	str	r2, [r3, #32]

  osalSysLock();
  osalDbgAssert((sdp->state == SD_STOP) || (sdp->state == SD_READY),
                "invalid state");
  sd_lld_start(sdp, config);
  sdp->state = SD_READY;
 8000850:	2302      	movs	r3, #2
 8000852:	7203      	strb	r3, [r0, #8]
 8000854:	2300      	movs	r3, #0
 8000856:	f383 8811 	msr	BASEPRI, r3
 800085a:	bd10      	pop	{r4, pc}
 800085c:	08003c40 	.word	0x08003c40
 8000860:	20000e88 	.word	0x20000e88
 8000864:	40021000 	.word	0x40021000
 8000868:	e000e100 	.word	0xe000e100
 800086c:	20000f04 	.word	0x20000f04

08000870 <_port_irq_epilogue>:
 8000870:	2320      	movs	r3, #32
 8000872:	f383 8811 	msr	BASEPRI, r3
 * @brief   Exception exit redirection to _port_switch_from_isr().
 */
void _port_irq_epilogue(void) {

  port_lock_from_isr();
  if ((SCB->ICSR & SCB_ICSR_RETTOBASE_Msk) != 0U) {
 8000876:	4b17      	ldr	r3, [pc, #92]	; (80008d4 <_port_irq_epilogue+0x64>)
 8000878:	685b      	ldr	r3, [r3, #4]
 800087a:	f413 6300 	ands.w	r3, r3, #2048	; 0x800
 800087e:	d026      	beq.n	80008ce <_port_irq_epilogue+0x5e>
#if (__FPU_PRESENT == 1) && (__FPU_USED == 1)
  uint32_t result;

  /* Empty asm statement works as a scheduling barrier */
  __ASM volatile ("");
  __ASM volatile ("VMRS %0, fpscr" : "=r" (result) );
 8000880:	eef1 3a10 	vmrs	r3, fpscr
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE uint32_t __get_PSP(void)
{
  register uint32_t result;

  __ASM volatile ("MRS %0, psp\n"  : "=r" (result) );
 8000884:	f3ef 8309 	mrs	r3, PSP
    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    ctxp--;

    /* Setting up a fake XPSR register value.*/
    ctxp->xpsr = (regarm_t)0x01000000;
 8000888:	f04f 7280 	mov.w	r2, #16777216	; 0x1000000
 800088c:	f843 2c4c 	str.w	r2, [r3, #-76]
#if CORTEX_USE_FPU == TRUE
    ctxp->fpscr = (regarm_t)FPU->FPDSCR;
 8000890:	4a11      	ldr	r2, [pc, #68]	; (80008d8 <_port_irq_epilogue+0x68>)
 8000892:	68d2      	ldr	r2, [r2, #12]
 8000894:	f843 2c08 	str.w	r2, [r3, #-8]
    /* The port_extctx structure is pointed by the PSP register.*/
    ctxp = (struct port_extctx *)__get_PSP();

    /* Adding an artificial exception return context, there is no need to
       populate it fully.*/
    ctxp--;
 8000898:	f1a3 0268 	sub.w	r2, r3, #104	; 0x68

    \param [in]    topOfProcStack  Process Stack Pointer value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_PSP(uint32_t topOfProcStack)
{
  __ASM volatile ("MSR psp, %0\n" : : "r" (topOfProcStack) : "sp");
 800089c:	f382 8809 	msr	PSP, r2
 * @retval false        if preemption is not required.
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {
  tprio_t p1 = firstprio(&ch.rlist.r_queue);
 80008a0:	490e      	ldr	r1, [pc, #56]	; (80008dc <_port_irq_epilogue+0x6c>)
  tprio_t p2 = currp->p_prio;
 80008a2:	6988      	ldr	r0, [r1, #24]
 * @retval false        if preemption is not required.
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {
  tprio_t p1 = firstprio(&ch.rlist.r_queue);
 80008a4:	680a      	ldr	r2, [r1, #0]
  tprio_t p2 = currp->p_prio;
 80008a6:	6881      	ldr	r1, [r0, #8]
#if CH_CFG_TIME_QUANTUM > 0
  /* If the running thread has not reached its time quantum, reschedule only
     if the first thread on the ready queue has a higher priority.
     Otherwise, if the running thread has used up its time quantum, reschedule
     if the first thread on the ready queue has equal or higher priority.*/
  return (currp->p_preempt > (tslices_t)0) ? (p1 > p2) : (p1 >= p2);
 80008a8:	7fc0      	ldrb	r0, [r0, #31]
 * @retval false        if preemption is not required.
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {
  tprio_t p1 = firstprio(&ch.rlist.r_queue);
 80008aa:	6892      	ldr	r2, [r2, #8]
#if CH_CFG_TIME_QUANTUM > 0
  /* If the running thread has not reached its time quantum, reschedule only
     if the first thread on the ready queue has a higher priority.
     Otherwise, if the running thread has used up its time quantum, reschedule
     if the first thread on the ready queue has equal or higher priority.*/
  return (currp->p_preempt > (tslices_t)0) ? (p1 > p2) : (p1 >= p2);
 80008ac:	b120      	cbz	r0, 80008b8 <_port_irq_epilogue+0x48>
 80008ae:	428a      	cmp	r2, r1
 80008b0:	bf94      	ite	ls
 80008b2:	2200      	movls	r2, #0
 80008b4:	2201      	movhi	r2, #1
 80008b6:	e003      	b.n	80008c0 <_port_irq_epilogue+0x50>
 80008b8:	428a      	cmp	r2, r1
 80008ba:	bf34      	ite	cc
 80008bc:	2200      	movcc	r2, #0
 80008be:	2201      	movcs	r2, #1
    /* Writing back the modified PSP value.*/
    __set_PSP((uint32_t)ctxp);

    /* The exit sequence is different depending on if a preemption is
       required or not.*/
    if (chSchIsPreemptionRequired()) {
 80008c0:	b10a      	cbz	r2, 80008c6 <_port_irq_epilogue+0x56>
      /* Preemption is required we need to enforce a context switch.*/
      ctxp->pc = (regarm_t)_port_switch_from_isr;
 80008c2:	4a07      	ldr	r2, [pc, #28]	; (80008e0 <_port_irq_epilogue+0x70>)
 80008c4:	e000      	b.n	80008c8 <_port_irq_epilogue+0x58>
    }
    else {
      /* Preemption not required, we just need to exit the exception
         atomically.*/
      ctxp->pc = (regarm_t)_port_exit_from_isr;
 80008c6:	4a07      	ldr	r2, [pc, #28]	; (80008e4 <_port_irq_epilogue+0x74>)
 80008c8:	f843 2c50 	str.w	r2, [r3, #-80]
 80008cc:	4770      	bx	lr

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 80008ce:	f383 8811 	msr	BASEPRI, r3
 80008d2:	4770      	bx	lr
 80008d4:	e000ed00 	.word	0xe000ed00
 80008d8:	e000ef30 	.word	0xe000ef30
 80008dc:	20001a00 	.word	0x20001a00
 80008e0:	080002d9 	.word	0x080002d9
 80008e4:	080002dc 	.word	0x080002dc
	...

080008f0 <SysTick_Handler>:
 * @brief   System Timer vector.
 * @details This interrupt is used for system tick in periodic mode.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(SysTick_Handler) {
 80008f0:	b570      	push	{r4, r5, r6, lr}
 80008f2:	2320      	movs	r3, #32
 80008f4:	f383 8811 	msr	BASEPRI, r3

  chDbgCheckClassI();

#if CH_CFG_TIME_QUANTUM > 0
  /* Running thread has not used up quantum yet? */
  if (currp->p_preempt > (tslices_t)0) {
 80008f8:	4c14      	ldr	r4, [pc, #80]	; (800094c <SysTick_Handler+0x5c>)
 80008fa:	69a2      	ldr	r2, [r4, #24]
 80008fc:	7fd3      	ldrb	r3, [r2, #31]
 80008fe:	b10b      	cbz	r3, 8000904 <SysTick_Handler+0x14>
    /* Decrement remaining quantum.*/
    currp->p_preempt--;
 8000900:	3b01      	subs	r3, #1
 8000902:	77d3      	strb	r3, [r2, #31]
static inline void chVTDoTickI(void) {

  chDbgCheckClassI();

#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.vt_systime++;
 8000904:	6aa3      	ldr	r3, [r4, #40]	; 0x28
  if (&ch.vtlist != (virtual_timers_list_t *)ch.vtlist.vt_next) {
 8000906:	69e2      	ldr	r2, [r4, #28]
static inline void chVTDoTickI(void) {

  chDbgCheckClassI();

#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.vt_systime++;
 8000908:	3301      	adds	r3, #1
 800090a:	62a3      	str	r3, [r4, #40]	; 0x28
  if (&ch.vtlist != (virtual_timers_list_t *)ch.vtlist.vt_next) {
 800090c:	4b10      	ldr	r3, [pc, #64]	; (8000950 <SysTick_Handler+0x60>)
 800090e:	429a      	cmp	r2, r3
 8000910:	461d      	mov	r5, r3
 8000912:	d106      	bne.n	8000922 <SysTick_Handler+0x32>
 8000914:	2300      	movs	r3, #0
 8000916:	f383 8811 	msr	BASEPRI, r3
  osalSysLockFromISR();
  osalOsTimerHandlerI();
  osalSysUnlockFromISR();

  OSAL_IRQ_EPILOGUE();
}
 800091a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}

  osalSysLockFromISR();
  osalOsTimerHandlerI();
  osalSysUnlockFromISR();

  OSAL_IRQ_EPILOGUE();
 800091e:	f7ff bfa7 	b.w	8000870 <_port_irq_epilogue>
    /* The list is not empty, processing elements on top.*/
    --ch.vtlist.vt_next->vt_delta;
 8000922:	6893      	ldr	r3, [r2, #8]
 8000924:	3b01      	subs	r3, #1
 8000926:	6093      	str	r3, [r2, #8]
    while (ch.vtlist.vt_next->vt_delta == (systime_t)0) {
 8000928:	69e3      	ldr	r3, [r4, #28]
 800092a:	689a      	ldr	r2, [r3, #8]
 800092c:	2a00      	cmp	r2, #0
 800092e:	d1f1      	bne.n	8000914 <SysTick_Handler+0x24>
      vtfunc_t fn;

      vtp = ch.vtlist.vt_next;
      fn = vtp->vt_func;
      vtp->vt_func = NULL;
      vtp->vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
 8000930:	6819      	ldr	r1, [r3, #0]
      ch.vtlist.vt_next = vtp->vt_next;
 8000932:	4806      	ldr	r0, [pc, #24]	; (800094c <SysTick_Handler+0x5c>)
    while (ch.vtlist.vt_next->vt_delta == (systime_t)0) {
      virtual_timer_t *vtp;
      vtfunc_t fn;

      vtp = ch.vtlist.vt_next;
      fn = vtp->vt_func;
 8000934:	68de      	ldr	r6, [r3, #12]
      vtp->vt_func = NULL;
 8000936:	60da      	str	r2, [r3, #12]
      vtp->vt_next->vt_prev = (virtual_timer_t *)&ch.vtlist;
 8000938:	604d      	str	r5, [r1, #4]
      ch.vtlist.vt_next = vtp->vt_next;
 800093a:	61c1      	str	r1, [r0, #28]
 800093c:	f382 8811 	msr	BASEPRI, r2
      chSysUnlockFromISR();
      fn(vtp->vt_par);
 8000940:	6918      	ldr	r0, [r3, #16]
 8000942:	47b0      	blx	r6
 8000944:	2320      	movs	r3, #32
 8000946:	f383 8811 	msr	BASEPRI, r3
 800094a:	e7ed      	b.n	8000928 <SysTick_Handler+0x38>
 800094c:	20001a00 	.word	0x20001a00
 8000950:	20001a1c 	.word	0x20001a1c
	...

08000960 <Vector130>:
/**
 * @brief   DMA2 stream 5 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector130) {
 8000960:	b508      	push	{r3, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->ISR >> 16) & STM32_DMA_ISR_MASK;
 8000962:	4b07      	ldr	r3, [pc, #28]	; (8000980 <Vector130+0x20>)
 8000964:	6819      	ldr	r1, [r3, #0]
 8000966:	f3c1 4103 	ubfx	r1, r1, #16, #4
  DMA2->IFCR = flags << 16;
 800096a:	040a      	lsls	r2, r1, #16
 800096c:	605a      	str	r2, [r3, #4]
  if (dma_isr_redir[11].dma_func)
 800096e:	4a05      	ldr	r2, [pc, #20]	; (8000984 <Vector130+0x24>)
 8000970:	6d93      	ldr	r3, [r2, #88]	; 0x58
 8000972:	b10b      	cbz	r3, 8000978 <Vector130+0x18>
    dma_isr_redir[11].dma_func(dma_isr_redir[11].dma_param, flags);
 8000974:	6dd0      	ldr	r0, [r2, #92]	; 0x5c
 8000976:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
}
 8000978:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  flags = (DMA2->ISR >> 16) & STM32_DMA_ISR_MASK;
  DMA2->IFCR = flags << 16;
  if (dma_isr_redir[11].dma_func)
    dma_isr_redir[11].dma_func(dma_isr_redir[11].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 800097c:	f7ff bf78 	b.w	8000870 <_port_irq_epilogue>
 8000980:	40020400 	.word	0x40020400
 8000984:	20000e20 	.word	0x20000e20
	...

08000990 <Vector12C>:
/**
 * @brief   DMA2 stream 4 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector12C) {
 8000990:	b508      	push	{r3, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->ISR >> 12) & STM32_DMA_ISR_MASK;
 8000992:	4b07      	ldr	r3, [pc, #28]	; (80009b0 <Vector12C+0x20>)
 8000994:	6819      	ldr	r1, [r3, #0]
 8000996:	f3c1 3103 	ubfx	r1, r1, #12, #4
  DMA2->IFCR = flags << 12;
 800099a:	030a      	lsls	r2, r1, #12
 800099c:	605a      	str	r2, [r3, #4]
  if (dma_isr_redir[10].dma_func)
 800099e:	4a05      	ldr	r2, [pc, #20]	; (80009b4 <Vector12C+0x24>)
 80009a0:	6d13      	ldr	r3, [r2, #80]	; 0x50
 80009a2:	b10b      	cbz	r3, 80009a8 <Vector12C+0x18>
    dma_isr_redir[10].dma_func(dma_isr_redir[10].dma_param, flags);
 80009a4:	6d50      	ldr	r0, [r2, #84]	; 0x54
 80009a6:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
}
 80009a8:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  flags = (DMA2->ISR >> 12) & STM32_DMA_ISR_MASK;
  DMA2->IFCR = flags << 12;
  if (dma_isr_redir[10].dma_func)
    dma_isr_redir[10].dma_func(dma_isr_redir[10].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 80009ac:	f7ff bf60 	b.w	8000870 <_port_irq_epilogue>
 80009b0:	40020400 	.word	0x40020400
 80009b4:	20000e20 	.word	0x20000e20
	...

080009c0 <Vector128>:
/**
 * @brief   DMA2 stream 3 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector128) {
 80009c0:	b508      	push	{r3, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->ISR >> 8) & STM32_DMA_ISR_MASK;
 80009c2:	4b07      	ldr	r3, [pc, #28]	; (80009e0 <Vector128+0x20>)
 80009c4:	6819      	ldr	r1, [r3, #0]
 80009c6:	f3c1 2103 	ubfx	r1, r1, #8, #4
  DMA2->IFCR = flags << 8;
 80009ca:	020a      	lsls	r2, r1, #8
 80009cc:	605a      	str	r2, [r3, #4]
  if (dma_isr_redir[9].dma_func)
 80009ce:	4a05      	ldr	r2, [pc, #20]	; (80009e4 <Vector128+0x24>)
 80009d0:	6c93      	ldr	r3, [r2, #72]	; 0x48
 80009d2:	b10b      	cbz	r3, 80009d8 <Vector128+0x18>
    dma_isr_redir[9].dma_func(dma_isr_redir[9].dma_param, flags);
 80009d4:	6cd0      	ldr	r0, [r2, #76]	; 0x4c
 80009d6:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
}
 80009d8:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  flags = (DMA2->ISR >> 8) & STM32_DMA_ISR_MASK;
  DMA2->IFCR = flags << 8;
  if (dma_isr_redir[9].dma_func)
    dma_isr_redir[9].dma_func(dma_isr_redir[9].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 80009dc:	f7ff bf48 	b.w	8000870 <_port_irq_epilogue>
 80009e0:	40020400 	.word	0x40020400
 80009e4:	20000e20 	.word	0x20000e20
	...

080009f0 <Vector124>:
/**
 * @brief   DMA2 stream 2 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector124) {
 80009f0:	b508      	push	{r3, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->ISR >> 4) & STM32_DMA_ISR_MASK;
 80009f2:	4b07      	ldr	r3, [pc, #28]	; (8000a10 <Vector124+0x20>)
 80009f4:	6819      	ldr	r1, [r3, #0]
 80009f6:	f3c1 1103 	ubfx	r1, r1, #4, #4
  DMA2->IFCR = flags << 4;
 80009fa:	010a      	lsls	r2, r1, #4
 80009fc:	605a      	str	r2, [r3, #4]
  if (dma_isr_redir[8].dma_func)
 80009fe:	4a05      	ldr	r2, [pc, #20]	; (8000a14 <Vector124+0x24>)
 8000a00:	6c13      	ldr	r3, [r2, #64]	; 0x40
 8000a02:	b10b      	cbz	r3, 8000a08 <Vector124+0x18>
    dma_isr_redir[8].dma_func(dma_isr_redir[8].dma_param, flags);
 8000a04:	6c50      	ldr	r0, [r2, #68]	; 0x44
 8000a06:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
}
 8000a08:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  flags = (DMA2->ISR >> 4) & STM32_DMA_ISR_MASK;
  DMA2->IFCR = flags << 4;
  if (dma_isr_redir[8].dma_func)
    dma_isr_redir[8].dma_func(dma_isr_redir[8].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 8000a0c:	f7ff bf30 	b.w	8000870 <_port_irq_epilogue>
 8000a10:	40020400 	.word	0x40020400
 8000a14:	20000e20 	.word	0x20000e20
	...

08000a20 <Vector120>:
/**
 * @brief   DMA2 stream 1 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector120) {
 8000a20:	b508      	push	{r3, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->ISR >> 0) & STM32_DMA_ISR_MASK;
 8000a22:	4b07      	ldr	r3, [pc, #28]	; (8000a40 <Vector120+0x20>)
  DMA2->IFCR = flags << 0;
  if (dma_isr_redir[7].dma_func)
 8000a24:	4a07      	ldr	r2, [pc, #28]	; (8000a44 <Vector120+0x24>)
OSAL_IRQ_HANDLER(Vector120) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA2->ISR >> 0) & STM32_DMA_ISR_MASK;
 8000a26:	6819      	ldr	r1, [r3, #0]
 8000a28:	f001 010f 	and.w	r1, r1, #15
  DMA2->IFCR = flags << 0;
 8000a2c:	6059      	str	r1, [r3, #4]
  if (dma_isr_redir[7].dma_func)
 8000a2e:	6b93      	ldr	r3, [r2, #56]	; 0x38
 8000a30:	b10b      	cbz	r3, 8000a36 <Vector120+0x16>
    dma_isr_redir[7].dma_func(dma_isr_redir[7].dma_param, flags);
 8000a32:	6bd0      	ldr	r0, [r2, #60]	; 0x3c
 8000a34:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
}
 8000a36:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  flags = (DMA2->ISR >> 0) & STM32_DMA_ISR_MASK;
  DMA2->IFCR = flags << 0;
  if (dma_isr_redir[7].dma_func)
    dma_isr_redir[7].dma_func(dma_isr_redir[7].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 8000a3a:	f7ff bf19 	b.w	8000870 <_port_irq_epilogue>
 8000a3e:	bf00      	nop
 8000a40:	40020400 	.word	0x40020400
 8000a44:	20000e20 	.word	0x20000e20
	...

08000a50 <Vector84>:
/**
 * @brief   DMA1 stream 7 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector84) {
 8000a50:	b508      	push	{r3, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->ISR >> 24) & STM32_DMA_ISR_MASK;
 8000a52:	4b07      	ldr	r3, [pc, #28]	; (8000a70 <Vector84+0x20>)
 8000a54:	6819      	ldr	r1, [r3, #0]
 8000a56:	f3c1 6103 	ubfx	r1, r1, #24, #4
  DMA1->IFCR = flags << 24;
 8000a5a:	060a      	lsls	r2, r1, #24
 8000a5c:	605a      	str	r2, [r3, #4]
  if (dma_isr_redir[6].dma_func)
 8000a5e:	4a05      	ldr	r2, [pc, #20]	; (8000a74 <Vector84+0x24>)
 8000a60:	6b13      	ldr	r3, [r2, #48]	; 0x30
 8000a62:	b10b      	cbz	r3, 8000a68 <Vector84+0x18>
    dma_isr_redir[6].dma_func(dma_isr_redir[6].dma_param, flags);
 8000a64:	6b50      	ldr	r0, [r2, #52]	; 0x34
 8000a66:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
}
 8000a68:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  flags = (DMA1->ISR >> 24) & STM32_DMA_ISR_MASK;
  DMA1->IFCR = flags << 24;
  if (dma_isr_redir[6].dma_func)
    dma_isr_redir[6].dma_func(dma_isr_redir[6].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 8000a6c:	f7ff bf00 	b.w	8000870 <_port_irq_epilogue>
 8000a70:	40020000 	.word	0x40020000
 8000a74:	20000e20 	.word	0x20000e20
	...

08000a80 <Vector80>:
/**
 * @brief   DMA1 stream 6 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector80) {
 8000a80:	b508      	push	{r3, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->ISR >> 20) & STM32_DMA_ISR_MASK;
 8000a82:	4b07      	ldr	r3, [pc, #28]	; (8000aa0 <Vector80+0x20>)
 8000a84:	6819      	ldr	r1, [r3, #0]
 8000a86:	f3c1 5103 	ubfx	r1, r1, #20, #4
  DMA1->IFCR = flags << 20;
 8000a8a:	050a      	lsls	r2, r1, #20
 8000a8c:	605a      	str	r2, [r3, #4]
  if (dma_isr_redir[5].dma_func)
 8000a8e:	4a05      	ldr	r2, [pc, #20]	; (8000aa4 <Vector80+0x24>)
 8000a90:	6a93      	ldr	r3, [r2, #40]	; 0x28
 8000a92:	b10b      	cbz	r3, 8000a98 <Vector80+0x18>
    dma_isr_redir[5].dma_func(dma_isr_redir[5].dma_param, flags);
 8000a94:	6ad0      	ldr	r0, [r2, #44]	; 0x2c
 8000a96:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
}
 8000a98:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  flags = (DMA1->ISR >> 20) & STM32_DMA_ISR_MASK;
  DMA1->IFCR = flags << 20;
  if (dma_isr_redir[5].dma_func)
    dma_isr_redir[5].dma_func(dma_isr_redir[5].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 8000a9c:	f7ff bee8 	b.w	8000870 <_port_irq_epilogue>
 8000aa0:	40020000 	.word	0x40020000
 8000aa4:	20000e20 	.word	0x20000e20
	...

08000ab0 <Vector7C>:
/**
 * @brief   DMA1 stream 5 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector7C) {
 8000ab0:	b508      	push	{r3, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->ISR >> 16) & STM32_DMA_ISR_MASK;
 8000ab2:	4b07      	ldr	r3, [pc, #28]	; (8000ad0 <Vector7C+0x20>)
 8000ab4:	6819      	ldr	r1, [r3, #0]
 8000ab6:	f3c1 4103 	ubfx	r1, r1, #16, #4
  DMA1->IFCR = flags << 16;
 8000aba:	040a      	lsls	r2, r1, #16
 8000abc:	605a      	str	r2, [r3, #4]
  if (dma_isr_redir[4].dma_func)
 8000abe:	4a05      	ldr	r2, [pc, #20]	; (8000ad4 <Vector7C+0x24>)
 8000ac0:	6a13      	ldr	r3, [r2, #32]
 8000ac2:	b10b      	cbz	r3, 8000ac8 <Vector7C+0x18>
    dma_isr_redir[4].dma_func(dma_isr_redir[4].dma_param, flags);
 8000ac4:	6a50      	ldr	r0, [r2, #36]	; 0x24
 8000ac6:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
}
 8000ac8:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  flags = (DMA1->ISR >> 16) & STM32_DMA_ISR_MASK;
  DMA1->IFCR = flags << 16;
  if (dma_isr_redir[4].dma_func)
    dma_isr_redir[4].dma_func(dma_isr_redir[4].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 8000acc:	f7ff bed0 	b.w	8000870 <_port_irq_epilogue>
 8000ad0:	40020000 	.word	0x40020000
 8000ad4:	20000e20 	.word	0x20000e20
	...

08000ae0 <Vector78>:
/**
 * @brief   DMA1 stream 4 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector78) {
 8000ae0:	b508      	push	{r3, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->ISR >> 12) & STM32_DMA_ISR_MASK;
 8000ae2:	4b07      	ldr	r3, [pc, #28]	; (8000b00 <Vector78+0x20>)
 8000ae4:	6819      	ldr	r1, [r3, #0]
 8000ae6:	f3c1 3103 	ubfx	r1, r1, #12, #4
  DMA1->IFCR = flags << 12;
 8000aea:	030a      	lsls	r2, r1, #12
 8000aec:	605a      	str	r2, [r3, #4]
  if (dma_isr_redir[3].dma_func)
 8000aee:	4a05      	ldr	r2, [pc, #20]	; (8000b04 <Vector78+0x24>)
 8000af0:	6993      	ldr	r3, [r2, #24]
 8000af2:	b10b      	cbz	r3, 8000af8 <Vector78+0x18>
    dma_isr_redir[3].dma_func(dma_isr_redir[3].dma_param, flags);
 8000af4:	69d0      	ldr	r0, [r2, #28]
 8000af6:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
}
 8000af8:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  flags = (DMA1->ISR >> 12) & STM32_DMA_ISR_MASK;
  DMA1->IFCR = flags << 12;
  if (dma_isr_redir[3].dma_func)
    dma_isr_redir[3].dma_func(dma_isr_redir[3].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 8000afc:	f7ff beb8 	b.w	8000870 <_port_irq_epilogue>
 8000b00:	40020000 	.word	0x40020000
 8000b04:	20000e20 	.word	0x20000e20
	...

08000b10 <Vector74>:
/**
 * @brief   DMA1 stream 3 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector74) {
 8000b10:	b508      	push	{r3, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->ISR >> 8) & STM32_DMA_ISR_MASK;
 8000b12:	4b07      	ldr	r3, [pc, #28]	; (8000b30 <Vector74+0x20>)
 8000b14:	6819      	ldr	r1, [r3, #0]
 8000b16:	f3c1 2103 	ubfx	r1, r1, #8, #4
  DMA1->IFCR = flags << 8;
 8000b1a:	020a      	lsls	r2, r1, #8
 8000b1c:	605a      	str	r2, [r3, #4]
  if (dma_isr_redir[2].dma_func)
 8000b1e:	4a05      	ldr	r2, [pc, #20]	; (8000b34 <Vector74+0x24>)
 8000b20:	6913      	ldr	r3, [r2, #16]
 8000b22:	b10b      	cbz	r3, 8000b28 <Vector74+0x18>
    dma_isr_redir[2].dma_func(dma_isr_redir[2].dma_param, flags);
 8000b24:	6950      	ldr	r0, [r2, #20]
 8000b26:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
}
 8000b28:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  flags = (DMA1->ISR >> 8) & STM32_DMA_ISR_MASK;
  DMA1->IFCR = flags << 8;
  if (dma_isr_redir[2].dma_func)
    dma_isr_redir[2].dma_func(dma_isr_redir[2].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 8000b2c:	f7ff bea0 	b.w	8000870 <_port_irq_epilogue>
 8000b30:	40020000 	.word	0x40020000
 8000b34:	20000e20 	.word	0x20000e20
	...

08000b40 <Vector70>:
/**
 * @brief   DMA1 stream 2 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector70) {
 8000b40:	b508      	push	{r3, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->ISR >> 4) & STM32_DMA_ISR_MASK;
 8000b42:	4b07      	ldr	r3, [pc, #28]	; (8000b60 <Vector70+0x20>)
 8000b44:	6819      	ldr	r1, [r3, #0]
 8000b46:	f3c1 1103 	ubfx	r1, r1, #4, #4
  DMA1->IFCR = flags << 4;
 8000b4a:	010a      	lsls	r2, r1, #4
 8000b4c:	605a      	str	r2, [r3, #4]
  if (dma_isr_redir[1].dma_func)
 8000b4e:	4a05      	ldr	r2, [pc, #20]	; (8000b64 <Vector70+0x24>)
 8000b50:	6893      	ldr	r3, [r2, #8]
 8000b52:	b10b      	cbz	r3, 8000b58 <Vector70+0x18>
    dma_isr_redir[1].dma_func(dma_isr_redir[1].dma_param, flags);
 8000b54:	68d0      	ldr	r0, [r2, #12]
 8000b56:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
}
 8000b58:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  flags = (DMA1->ISR >> 4) & STM32_DMA_ISR_MASK;
  DMA1->IFCR = flags << 4;
  if (dma_isr_redir[1].dma_func)
    dma_isr_redir[1].dma_func(dma_isr_redir[1].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 8000b5c:	f7ff be88 	b.w	8000870 <_port_irq_epilogue>
 8000b60:	40020000 	.word	0x40020000
 8000b64:	20000e20 	.word	0x20000e20
	...

08000b70 <Vector6C>:
/**
 * @brief   DMA1 stream 1 shared interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector6C) {
 8000b70:	b508      	push	{r3, lr}
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->ISR >> 0) & STM32_DMA_ISR_MASK;
 8000b72:	4b07      	ldr	r3, [pc, #28]	; (8000b90 <Vector6C+0x20>)
  DMA1->IFCR = flags << 0;
  if (dma_isr_redir[0].dma_func)
 8000b74:	4a07      	ldr	r2, [pc, #28]	; (8000b94 <Vector6C+0x24>)
OSAL_IRQ_HANDLER(Vector6C) {
  uint32_t flags;

  OSAL_IRQ_PROLOGUE();

  flags = (DMA1->ISR >> 0) & STM32_DMA_ISR_MASK;
 8000b76:	6819      	ldr	r1, [r3, #0]
 8000b78:	f001 010f 	and.w	r1, r1, #15
  DMA1->IFCR = flags << 0;
 8000b7c:	6059      	str	r1, [r3, #4]
  if (dma_isr_redir[0].dma_func)
 8000b7e:	6813      	ldr	r3, [r2, #0]
 8000b80:	b10b      	cbz	r3, 8000b86 <Vector6C+0x16>
    dma_isr_redir[0].dma_func(dma_isr_redir[0].dma_param, flags);
 8000b82:	6850      	ldr	r0, [r2, #4]
 8000b84:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
}
 8000b86:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  flags = (DMA1->ISR >> 0) & STM32_DMA_ISR_MASK;
  DMA1->IFCR = flags << 0;
  if (dma_isr_redir[0].dma_func)
    dma_isr_redir[0].dma_func(dma_isr_redir[0].dma_param, flags);

  OSAL_IRQ_EPILOGUE();
 8000b8a:	f7ff be71 	b.w	8000870 <_port_irq_epilogue>
 8000b8e:	bf00      	nop
 8000b90:	40020000 	.word	0x40020000
 8000b94:	20000e20 	.word	0x20000e20
	...

08000ba0 <chTMStopMeasurementX>:
 *
 * @return              The realtime counter value.
 */
static inline rtcnt_t port_rt_get_counter_value(void) {

  return DWT->CYCCNT;
 8000ba0:	4b0e      	ldr	r3, [pc, #56]	; (8000bdc <chTMStopMeasurementX+0x3c>)

static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
 8000ba2:	68c1      	ldr	r1, [r0, #12]
 8000ba4:	685a      	ldr	r2, [r3, #4]
 *
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch.tm.offset);
 8000ba6:	4b0e      	ldr	r3, [pc, #56]	; (8000be0 <chTMStopMeasurementX+0x40>)
 *
 * @param[in,out] tmp   pointer to a @p time_measurement_t structure
 *
 * @xclass
 */
NOINLINE void chTMStopMeasurementX(time_measurement_t *tmp) {
 8000ba8:	b530      	push	{r4, r5, lr}

  tm_stop(tmp, chSysGetRealtimeCounterX(), ch.tm.offset);
 8000baa:	6f5c      	ldr	r4, [r3, #116]	; 0x74
static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
  tmp->last = (now - tmp->last) - offset;
 8000bac:	6883      	ldr	r3, [r0, #8]
 8000bae:	1ad3      	subs	r3, r2, r3
 8000bb0:	1b1b      	subs	r3, r3, r4
  tmp->cumulative += (rttime_t)tmp->last;
 8000bb2:	e9d0 4504 	ldrd	r4, r5, [r0, #16]
  /*lint -save -e9013 [15.7] There is no else because it is not needed.*/
  if (tmp->last > tmp->worst) {
 8000bb6:	6842      	ldr	r2, [r0, #4]
static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
  tmp->last = (now - tmp->last) - offset;
 8000bb8:	6083      	str	r3, [r0, #8]
  tmp->cumulative += (rttime_t)tmp->last;
 8000bba:	18e4      	adds	r4, r4, r3
 8000bbc:	f145 0500 	adc.w	r5, r5, #0

static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
 8000bc0:	3101      	adds	r1, #1
  tmp->last = (now - tmp->last) - offset;
  tmp->cumulative += (rttime_t)tmp->last;
  /*lint -save -e9013 [15.7] There is no else because it is not needed.*/
  if (tmp->last > tmp->worst) {
 8000bc2:	4293      	cmp	r3, r2

static inline void tm_stop(time_measurement_t *tmp,
                           rtcnt_t now,
                           rtcnt_t offset) {

  tmp->n++;
 8000bc4:	60c1      	str	r1, [r0, #12]
  tmp->last = (now - tmp->last) - offset;
  tmp->cumulative += (rttime_t)tmp->last;
 8000bc6:	e9c0 4504 	strd	r4, r5, [r0, #16]
  /*lint -save -e9013 [15.7] There is no else because it is not needed.*/
  if (tmp->last > tmp->worst) {
 8000bca:	d901      	bls.n	8000bd0 <chTMStopMeasurementX+0x30>
    tmp->worst = tmp->last;
 8000bcc:	6043      	str	r3, [r0, #4]
 8000bce:	bd30      	pop	{r4, r5, pc}
  }
  else if (tmp->last < tmp->best) {
 8000bd0:	6802      	ldr	r2, [r0, #0]
 8000bd2:	4293      	cmp	r3, r2
    tmp->best = tmp->last;
 8000bd4:	bf38      	it	cc
 8000bd6:	6003      	strcc	r3, [r0, #0]
 8000bd8:	bd30      	pop	{r4, r5, pc}
 8000bda:	bf00      	nop
 8000bdc:	e0001000 	.word	0xe0001000
 8000be0:	20001a00 	.word	0x20001a00
	...

08000bf0 <chTMStartMeasurementX>:
 8000bf0:	4b01      	ldr	r3, [pc, #4]	; (8000bf8 <chTMStartMeasurementX+0x8>)
 8000bf2:	685b      	ldr	r3, [r3, #4]
 *
 * @xclass
 */
NOINLINE void chTMStartMeasurementX(time_measurement_t *tmp) {

  tmp->last = chSysGetRealtimeCounterX();
 8000bf4:	6083      	str	r3, [r0, #8]
 8000bf6:	4770      	bx	lr
 8000bf8:	e0001000 	.word	0xe0001000
 8000bfc:	00000000 	.word	0x00000000

08000c00 <chSchGoSleepS>:
void chSchGoSleepS(tstate_t newstate) {
  thread_t *otp;

  chDbgCheckClassS();

  otp = currp;
 8000c00:	4b07      	ldr	r3, [pc, #28]	; (8000c20 <chSchGoSleepS+0x20>)
 8000c02:	6999      	ldr	r1, [r3, #24]
 *
 * @param[in] newstate  the new thread state
 *
 * @sclass
 */
void chSchGoSleepS(tstate_t newstate) {
 8000c04:	b510      	push	{r4, lr}
  thread_t *otp;

  chDbgCheckClassS();

  otp = currp;
  otp->p_state = newstate;
 8000c06:	7708      	strb	r0, [r1, #28]
  tp->p_prev->p_next = tp;
  tqp->p_prev = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;
 8000c08:	6818      	ldr	r0, [r3, #0]

  tqp->p_next = tp->p_next;
 8000c0a:	6804      	ldr	r4, [r0, #0]
 8000c0c:	601c      	str	r4, [r3, #0]
#if CH_CFG_TIME_QUANTUM > 0
  /* The thread is renouncing its remaining time slices so it will have a new
     time quantum when it will wakeup.*/
  otp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
 8000c0e:	2201      	movs	r2, #1
 8000c10:	77ca      	strb	r2, [r1, #31]
  tqp->p_next->p_prev = (thread_t *)tqp;
 8000c12:	6063      	str	r3, [r4, #4]
#if defined(CH_CFG_IDLE_ENTER_HOOK)
  if (currp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
 8000c14:	7702      	strb	r2, [r0, #28]
  chSysSwitch(currp, otp);
}
 8000c16:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
#if CH_CFG_TIME_QUANTUM > 0
  /* The thread is renouncing its remaining time slices so it will have a new
     time quantum when it will wakeup.*/
  otp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
  setcurrp(queue_fifo_remove(&ch.rlist.r_queue));
 8000c1a:	6198      	str	r0, [r3, #24]
  if (currp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_ENTER_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
  chSysSwitch(currp, otp);
 8000c1c:	f7ff bb48 	b.w	80002b0 <_port_switch>
 8000c20:	20001a00 	.word	0x20001a00
	...

08000c30 <chSchGoSleepTimeoutS>:
 * @return              The wakeup message.
 * @retval MSG_TIMEOUT  if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t time) {
 8000c30:	b570      	push	{r4, r5, r6, lr}

  chDbgCheckClassS();

  if (TIME_INFINITE != time) {
 8000c32:	1c4b      	adds	r3, r1, #1
 * @return              The wakeup message.
 * @retval MSG_TIMEOUT  if a timeout occurs.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t time) {
 8000c34:	b086      	sub	sp, #24
 8000c36:	4606      	mov	r6, r0
 8000c38:	4c18      	ldr	r4, [pc, #96]	; (8000c9c <chSchGoSleepTimeoutS+0x6c>)

  chDbgCheckClassS();

  if (TIME_INFINITE != time) {
 8000c3a:	d028      	beq.n	8000c8e <chSchGoSleepTimeoutS+0x5e>
  systime_t delta;

  chDbgCheckClassI();
  chDbgCheck((vtp != NULL) && (vtfunc != NULL) && (delay != TIME_IMMEDIATE));

  vtp->vt_par = par;
 8000c3c:	69a3      	ldr	r3, [r4, #24]
 8000c3e:	9305      	str	r3, [sp, #20]
  vtp->vt_func = vtfunc;
 8000c40:	4b17      	ldr	r3, [pc, #92]	; (8000ca0 <chSchGoSleepTimeoutS+0x70>)
 8000c42:	9304      	str	r3, [sp, #16]
  delta = delay;
#endif /* CH_CFG_ST_TIMEDELTA == 0 */

  /* The delta list is scanned in order to find the correct position for
     this timer. */
  p = ch.vtlist.vt_next;
 8000c44:	69e3      	ldr	r3, [r4, #28]
  while (p->vt_delta < delta) {
 8000c46:	689a      	ldr	r2, [r3, #8]
 8000c48:	428a      	cmp	r2, r1
 8000c4a:	d202      	bcs.n	8000c52 <chSchGoSleepTimeoutS+0x22>
    delta -= p->vt_delta;
 8000c4c:	1a89      	subs	r1, r1, r2
    p = p->vt_next;
 8000c4e:	681b      	ldr	r3, [r3, #0]
 8000c50:	e7f9      	b.n	8000c46 <chSchGoSleepTimeoutS+0x16>
  }

  /* The timer is inserted in the delta list.*/
  vtp->vt_next = p;
  vtp->vt_prev = vtp->vt_next->vt_prev;
 8000c52:	6858      	ldr	r0, [r3, #4]
 8000c54:	9002      	str	r0, [sp, #8]
  vtp->vt_prev->vt_next = vtp;
 8000c56:	aa01      	add	r2, sp, #4
    delta -= p->vt_delta;
    p = p->vt_next;
  }

  /* The timer is inserted in the delta list.*/
  vtp->vt_next = p;
 8000c58:	9301      	str	r3, [sp, #4]
  vtp->vt_prev = vtp->vt_next->vt_prev;
  vtp->vt_prev->vt_next = vtp;
 8000c5a:	6002      	str	r2, [r0, #0]
  p->vt_prev = vtp;
 8000c5c:	605a      	str	r2, [r3, #4]
  vtp->vt_delta = delta
 8000c5e:	9103      	str	r1, [sp, #12]

  /* Special case when the timer is in last position in the list, the
     value in the header must be restored.*/;
  p->vt_delta -= delta;
 8000c60:	689a      	ldr	r2, [r3, #8]
 8000c62:	1a51      	subs	r1, r2, r1
 8000c64:	6099      	str	r1, [r3, #8]
  ch.vtlist.vt_delta = (systime_t)-1;
 8000c66:	f04f 35ff 	mov.w	r5, #4294967295	; 0xffffffff
    virtual_timer_t vt;

    chVTDoSetI(&vt, time, wakeup, currp);
    chSchGoSleepS(newstate);
 8000c6a:	4630      	mov	r0, r6
 8000c6c:	6265      	str	r5, [r4, #36]	; 0x24
 8000c6e:	f7ff ffc7 	bl	8000c00 <chSchGoSleepS>
    if (chVTIsArmedI(&vt)) {
 8000c72:	9b04      	ldr	r3, [sp, #16]
 8000c74:	b16b      	cbz	r3, 8000c92 <chSchGoSleepTimeoutS+0x62>
  chDbgAssert(vtp->vt_func != NULL, "timer not set or already triggered");

#if CH_CFG_ST_TIMEDELTA == 0

  /* The delta of the timer is added to the next timer.*/
  vtp->vt_next->vt_delta += vtp->vt_delta;
 8000c76:	9b01      	ldr	r3, [sp, #4]
 8000c78:	9a03      	ldr	r2, [sp, #12]
 8000c7a:	6899      	ldr	r1, [r3, #8]
 8000c7c:	440a      	add	r2, r1
 8000c7e:	609a      	str	r2, [r3, #8]

 /* Removing the element from the delta list.*/
  vtp->vt_prev->vt_next = vtp->vt_next;
 8000c80:	9a02      	ldr	r2, [sp, #8]
 8000c82:	6013      	str	r3, [r2, #0]
  vtp->vt_next->vt_prev = vtp->vt_prev;
 8000c84:	9b01      	ldr	r3, [sp, #4]
 8000c86:	605a      	str	r2, [r3, #4]
  vtp->vt_func = NULL;

  /* The above code changes the value in the header when the removed element
     is the last of the list, restoring it.*/
  ch.vtlist.vt_delta = (systime_t)-1;
 8000c88:	4b04      	ldr	r3, [pc, #16]	; (8000c9c <chSchGoSleepTimeoutS+0x6c>)
 8000c8a:	625d      	str	r5, [r3, #36]	; 0x24
 8000c8c:	e001      	b.n	8000c92 <chSchGoSleepTimeoutS+0x62>
      chVTDoResetI(&vt);
    }
  }
  else {
    chSchGoSleepS(newstate);
 8000c8e:	f7ff ffb7 	bl	8000c00 <chSchGoSleepS>
  }

  return currp->p_u.rdymsg;
 8000c92:	69a3      	ldr	r3, [r4, #24]
}
 8000c94:	6a18      	ldr	r0, [r3, #32]
 8000c96:	b006      	add	sp, #24
 8000c98:	bd70      	pop	{r4, r5, r6, pc}
 8000c9a:	bf00      	nop
 8000c9c:	20001a00 	.word	0x20001a00
 8000ca0:	080013e1 	.word	0x080013e1
	...

08000cb0 <chThdEnqueueTimeoutS>:
 *
 * @sclass
 */
msg_t chThdEnqueueTimeoutS(threads_queue_t *tqp, systime_t timeout) {

  if (TIME_IMMEDIATE == timeout) {
 8000cb0:	b149      	cbz	r1, 8000cc6 <chThdEnqueueTimeoutS+0x16>
    return MSG_TIMEOUT;
  }

  queue_insert(currp, tqp);
 8000cb2:	4b06      	ldr	r3, [pc, #24]	; (8000ccc <chThdEnqueueTimeoutS+0x1c>)
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {

  tp->p_next = (thread_t *)tqp;
  tp->p_prev = tqp->p_prev;
 8000cb4:	6842      	ldr	r2, [r0, #4]
 8000cb6:	699b      	ldr	r3, [r3, #24]
  cp->p_prev = tp;
}

static inline void queue_insert(thread_t *tp, threads_queue_t *tqp) {

  tp->p_next = (thread_t *)tqp;
 8000cb8:	6018      	str	r0, [r3, #0]
  tp->p_prev = tqp->p_prev;
 8000cba:	605a      	str	r2, [r3, #4]
  tp->p_prev->p_next = tp;
 8000cbc:	6013      	str	r3, [r2, #0]
  tqp->p_prev = tp;
 8000cbe:	6043      	str	r3, [r0, #4]

  return chSchGoSleepTimeoutS(CH_STATE_QUEUED, timeout);
 8000cc0:	2004      	movs	r0, #4
 8000cc2:	f7ff bfb5 	b.w	8000c30 <chSchGoSleepTimeoutS>
}
 8000cc6:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 8000cca:	4770      	bx	lr
 8000ccc:	20001a00 	.word	0x20001a00

08000cd0 <chOQWriteTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t chOQWriteTimeout(output_queue_t *oqp, const uint8_t *bp,
                        size_t n, systime_t timeout) {
 8000cd0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8000cd4:	4699      	mov	r9, r3
 8000cd6:	4604      	mov	r4, r0
 8000cd8:	460e      	mov	r6, r1
 8000cda:	4617      	mov	r7, r2
  qnotify_t nfy = oqp->q_notify;
 8000cdc:	f8d0 801c 	ldr.w	r8, [r0, #28]
 8000ce0:	2320      	movs	r3, #32
 8000ce2:	f383 8811 	msr	BASEPRI, r3
  size_t w = 0;
 8000ce6:	2500      	movs	r5, #0
 */
static inline bool chOQIsFullI(output_queue_t *oqp) {

  chDbgCheckClassI();

  return (bool)(chQSpaceI(oqp) == 0U);
 8000ce8:	f8d4 a008 	ldr.w	sl, [r4, #8]

  chDbgCheck(n > 0U);

  chSysLock();
  while (true) {
    while (chOQIsFullI(oqp)) {
 8000cec:	f1ba 0f00 	cmp.w	sl, #0
 8000cf0:	d108      	bne.n	8000d04 <chOQWriteTimeout+0x34>
      if (chThdEnqueueTimeoutS(&oqp->q_waiting, timeout) != Q_OK) {
 8000cf2:	4620      	mov	r0, r4
 8000cf4:	4649      	mov	r1, r9
 8000cf6:	f7ff ffdb 	bl	8000cb0 <chThdEnqueueTimeoutS>
 8000cfa:	2800      	cmp	r0, #0
 8000cfc:	d0f4      	beq.n	8000ce8 <chOQWriteTimeout+0x18>
 8000cfe:	f38a 8811 	msr	BASEPRI, sl
 8000d02:	e020      	b.n	8000d46 <chOQWriteTimeout+0x76>
        chSysUnlock();
        return w;
      }
    }
    
    oqp->q_counter--;
 8000d04:	68a3      	ldr	r3, [r4, #8]
 8000d06:	3b01      	subs	r3, #1
 8000d08:	60a3      	str	r3, [r4, #8]
    *oqp->q_wrptr++ = *bp++;
 8000d0a:	6963      	ldr	r3, [r4, #20]
 8000d0c:	1c5a      	adds	r2, r3, #1
 8000d0e:	6162      	str	r2, [r4, #20]
 8000d10:	7832      	ldrb	r2, [r6, #0]
 8000d12:	701a      	strb	r2, [r3, #0]
    if (oqp->q_wrptr >= oqp->q_top) {
 8000d14:	6923      	ldr	r3, [r4, #16]
 8000d16:	6962      	ldr	r2, [r4, #20]
 8000d18:	429a      	cmp	r2, r3
      oqp->q_wrptr = oqp->q_buffer;
 8000d1a:	bf24      	itt	cs
 8000d1c:	68e3      	ldrcs	r3, [r4, #12]
 8000d1e:	6163      	strcs	r3, [r4, #20]
        return w;
      }
    }
    
    oqp->q_counter--;
    *oqp->q_wrptr++ = *bp++;
 8000d20:	f106 0a01 	add.w	sl, r6, #1
    if (oqp->q_wrptr >= oqp->q_top) {
      oqp->q_wrptr = oqp->q_buffer;
    }

    if (nfy != NULL) {
 8000d24:	f1b8 0f00 	cmp.w	r8, #0
 8000d28:	d001      	beq.n	8000d2e <chOQWriteTimeout+0x5e>
      nfy(oqp);
 8000d2a:	4620      	mov	r0, r4
 8000d2c:	47c0      	blx	r8
 8000d2e:	2300      	movs	r3, #0
 8000d30:	f383 8811 	msr	BASEPRI, r3
    }
    chSysUnlock(); /* Gives a preemption chance in a controlled point.*/

    w++;
    if (--n == 0U) {
 8000d34:	3f01      	subs	r7, #1
    if (nfy != NULL) {
      nfy(oqp);
    }
    chSysUnlock(); /* Gives a preemption chance in a controlled point.*/

    w++;
 8000d36:	f105 0501 	add.w	r5, r5, #1
    if (--n == 0U) {
 8000d3a:	d004      	beq.n	8000d46 <chOQWriteTimeout+0x76>
 8000d3c:	2320      	movs	r3, #32
 8000d3e:	f383 8811 	msr	BASEPRI, r3
        return w;
      }
    }
    
    oqp->q_counter--;
    *oqp->q_wrptr++ = *bp++;
 8000d42:	4656      	mov	r6, sl
 8000d44:	e7d0      	b.n	8000ce8 <chOQWriteTimeout+0x18>
    if (--n == 0U) {
      return w;
    }
    chSysLock();
  }
}
 8000d46:	4628      	mov	r0, r5
 8000d48:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 8000d4c:	0000      	movs	r0, r0
	...

08000d50 <writet.lto_priv.58>:
  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, timeout);
}

static size_t writet(void *ip, const uint8_t *bp, size_t n, systime_t timeout) {

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, timeout);
 8000d50:	3030      	adds	r0, #48	; 0x30
 8000d52:	f7ff bfbd 	b.w	8000cd0 <chOQWriteTimeout>
	...

08000d60 <write.lto_priv.52>:
 * queue-level function or macro.
 */

static size_t write(void *ip, const uint8_t *bp, size_t n) {

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp,
 8000d60:	3030      	adds	r0, #48	; 0x30
 8000d62:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8000d66:	f7ff bfb3 	b.w	8000cd0 <chOQWriteTimeout>
 8000d6a:	0000      	movs	r0, r0
 8000d6c:	0000      	movs	r0, r0
	...

08000d70 <chOQPutTimeout>:
 * @retval Q_TIMEOUT    if the specified time expired.
 * @retval Q_RESET      if the queue has been reset.
 *
 * @api
 */
msg_t chOQPutTimeout(output_queue_t *oqp, uint8_t b, systime_t timeout) {
 8000d70:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8000d72:	4604      	mov	r4, r0
 8000d74:	460e      	mov	r6, r1
 8000d76:	4617      	mov	r7, r2
 8000d78:	2320      	movs	r3, #32
 8000d7a:	f383 8811 	msr	BASEPRI, r3
 8000d7e:	68a5      	ldr	r5, [r4, #8]

  chSysLock();
  while (chOQIsFullI(oqp)) {
 8000d80:	b945      	cbnz	r5, 8000d94 <chOQPutTimeout+0x24>
    msg_t msg = chThdEnqueueTimeoutS(&oqp->q_waiting, timeout);
 8000d82:	4620      	mov	r0, r4
 8000d84:	4639      	mov	r1, r7
 8000d86:	f7ff ff93 	bl	8000cb0 <chThdEnqueueTimeoutS>
    if (msg < Q_OK) {
 8000d8a:	2800      	cmp	r0, #0
 8000d8c:	daf7      	bge.n	8000d7e <chOQPutTimeout+0xe>
 8000d8e:	f385 8811 	msr	BASEPRI, r5
 8000d92:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
      chSysUnlock();
      return msg;
    }
  }

  oqp->q_counter--;
 8000d94:	68a3      	ldr	r3, [r4, #8]
 8000d96:	3b01      	subs	r3, #1
 8000d98:	60a3      	str	r3, [r4, #8]
  *oqp->q_wrptr++ = b;
 8000d9a:	6963      	ldr	r3, [r4, #20]
 8000d9c:	1c5a      	adds	r2, r3, #1
 8000d9e:	6162      	str	r2, [r4, #20]
 8000da0:	701e      	strb	r6, [r3, #0]
  if (oqp->q_wrptr >= oqp->q_top) {
 8000da2:	6923      	ldr	r3, [r4, #16]
 8000da4:	6962      	ldr	r2, [r4, #20]
 8000da6:	429a      	cmp	r2, r3
    oqp->q_wrptr = oqp->q_buffer;
 8000da8:	bf24      	itt	cs
 8000daa:	68e3      	ldrcs	r3, [r4, #12]
 8000dac:	6163      	strcs	r3, [r4, #20]
  }

  if (oqp->q_notify != NULL) {
 8000dae:	69e3      	ldr	r3, [r4, #28]
 8000db0:	b10b      	cbz	r3, 8000db6 <chOQPutTimeout+0x46>
    oqp->q_notify(oqp);
 8000db2:	4620      	mov	r0, r4
 8000db4:	4798      	blx	r3
 8000db6:	2000      	movs	r0, #0
 8000db8:	f380 8811 	msr	BASEPRI, r0
  }
  chSysUnlock();

  return Q_OK;
}
 8000dbc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	...

08000dc0 <putt.lto_priv.56>:
  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, TIME_INFINITE);
}

static msg_t putt(void *ip, uint8_t b, systime_t timeout) {

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
 8000dc0:	3030      	adds	r0, #48	; 0x30
 8000dc2:	f7ff bfd5 	b.w	8000d70 <chOQPutTimeout>
	...

08000dd0 <put.lto_priv.54>:
                       n, TIME_INFINITE);
}

static msg_t put(void *ip, uint8_t b) {

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
 8000dd0:	3030      	adds	r0, #48	; 0x30
 8000dd2:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 8000dd6:	f7ff bfcb 	b.w	8000d70 <chOQPutTimeout>
 8000dda:	0000      	movs	r0, r0
 8000ddc:	0000      	movs	r0, r0
	...

08000de0 <chIQReadTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t chIQReadTimeout(input_queue_t *iqp, uint8_t *bp,
                       size_t n, systime_t timeout) {
 8000de0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 8000de4:	4699      	mov	r9, r3
 8000de6:	4604      	mov	r4, r0
 8000de8:	460f      	mov	r7, r1
 8000dea:	4690      	mov	r8, r2
  qnotify_t nfy = iqp->q_notify;
 8000dec:	69c6      	ldr	r6, [r0, #28]
 8000dee:	2320      	movs	r3, #32
 8000df0:	f383 8811 	msr	BASEPRI, r3
  size_t r = 0;
 8000df4:	2500      	movs	r5, #0

  chDbgCheck(n > 0U);

  chSysLock();
  while (true) {
    if (nfy != NULL) {
 8000df6:	b10e      	cbz	r6, 8000dfc <chIQReadTimeout+0x1c>
      nfy(iqp);
 8000df8:	4620      	mov	r0, r4
 8000dfa:	47b0      	blx	r6
 */
static inline bool chIQIsEmptyI(input_queue_t *iqp) {

  chDbgCheckClassI();

  return (bool)(chQSpaceI(iqp) == 0U);
 8000dfc:	f8d4 a008 	ldr.w	sl, [r4, #8]
    }

    while (chIQIsEmptyI(iqp)) {
 8000e00:	f1ba 0f00 	cmp.w	sl, #0
 8000e04:	d108      	bne.n	8000e18 <chIQReadTimeout+0x38>
      if (chThdEnqueueTimeoutS(&iqp->q_waiting, timeout) != Q_OK) {
 8000e06:	4620      	mov	r0, r4
 8000e08:	4649      	mov	r1, r9
 8000e0a:	f7ff ff51 	bl	8000cb0 <chThdEnqueueTimeoutS>
 8000e0e:	2800      	cmp	r0, #0
 8000e10:	d0f4      	beq.n	8000dfc <chIQReadTimeout+0x1c>
 8000e12:	f38a 8811 	msr	BASEPRI, sl
 8000e16:	e017      	b.n	8000e48 <chIQReadTimeout+0x68>
        chSysUnlock();
        return r;
      }
    }

    iqp->q_counter--;
 8000e18:	68a3      	ldr	r3, [r4, #8]
 8000e1a:	3b01      	subs	r3, #1
 8000e1c:	60a3      	str	r3, [r4, #8]
    *bp++ = *iqp->q_rdptr++;
 8000e1e:	69a3      	ldr	r3, [r4, #24]
 8000e20:	1c5a      	adds	r2, r3, #1
 8000e22:	61a2      	str	r2, [r4, #24]
 8000e24:	781b      	ldrb	r3, [r3, #0]
 8000e26:	557b      	strb	r3, [r7, r5]
    if (iqp->q_rdptr >= iqp->q_top) {
 8000e28:	6923      	ldr	r3, [r4, #16]
 8000e2a:	69a2      	ldr	r2, [r4, #24]
 8000e2c:	429a      	cmp	r2, r3
      iqp->q_rdptr = iqp->q_buffer;
 8000e2e:	bf24      	itt	cs
 8000e30:	68e3      	ldrcs	r3, [r4, #12]
 8000e32:	61a3      	strcs	r3, [r4, #24]
 8000e34:	2300      	movs	r3, #0
 8000e36:	f383 8811 	msr	BASEPRI, r3
    }
    chSysUnlock(); /* Gives a preemption chance in a controlled point.*/

    r++;
 8000e3a:	3501      	adds	r5, #1
    if (--n == 0U) {
 8000e3c:	45a8      	cmp	r8, r5
 8000e3e:	d003      	beq.n	8000e48 <chIQReadTimeout+0x68>
 8000e40:	2320      	movs	r3, #32
 8000e42:	f383 8811 	msr	BASEPRI, r3
 8000e46:	e7d6      	b.n	8000df6 <chIQReadTimeout+0x16>
      return r;
    }

    chSysLock();
  }
}
 8000e48:	4628      	mov	r0, r5
 8000e4a:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
	...

08000e50 <readt.lto_priv.59>:
  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, timeout);
}

static size_t readt(void *ip, uint8_t *bp, size_t n, systime_t timeout) {

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp, n, timeout);
 8000e50:	300c      	adds	r0, #12
 8000e52:	f7ff bfc5 	b.w	8000de0 <chIQReadTimeout>
	...

08000e60 <read.lto_priv.53>:
                        n, TIME_INFINITE);
}

static size_t read(void *ip, uint8_t *bp, size_t n) {

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp,
 8000e60:	300c      	adds	r0, #12
 8000e62:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8000e66:	f7ff bfbb 	b.w	8000de0 <chIQReadTimeout>
 8000e6a:	0000      	movs	r0, r0
 8000e6c:	0000      	movs	r0, r0
	...

08000e70 <chIQGetTimeout>:
 * @retval Q_TIMEOUT    if the specified time expired.
 * @retval Q_RESET      if the queue has been reset.
 *
 * @api
 */
msg_t chIQGetTimeout(input_queue_t *iqp, systime_t timeout) {
 8000e70:	b570      	push	{r4, r5, r6, lr}
 8000e72:	2320      	movs	r3, #32
 8000e74:	4604      	mov	r4, r0
 8000e76:	460e      	mov	r6, r1
 8000e78:	f383 8811 	msr	BASEPRI, r3
  uint8_t b;

  chSysLock();
  if (iqp->q_notify != NULL) {
 8000e7c:	69c3      	ldr	r3, [r0, #28]
 8000e7e:	b103      	cbz	r3, 8000e82 <chIQGetTimeout+0x12>
    iqp->q_notify(iqp);
 8000e80:	4798      	blx	r3
 8000e82:	68a5      	ldr	r5, [r4, #8]
  }

  while (chIQIsEmptyI(iqp)) {
 8000e84:	b945      	cbnz	r5, 8000e98 <chIQGetTimeout+0x28>
    msg_t msg = chThdEnqueueTimeoutS(&iqp->q_waiting, timeout);
 8000e86:	4620      	mov	r0, r4
 8000e88:	4631      	mov	r1, r6
 8000e8a:	f7ff ff11 	bl	8000cb0 <chThdEnqueueTimeoutS>
    if (msg < Q_OK) {
 8000e8e:	2800      	cmp	r0, #0
 8000e90:	daf7      	bge.n	8000e82 <chIQGetTimeout+0x12>
 8000e92:	f385 8811 	msr	BASEPRI, r5
 8000e96:	bd70      	pop	{r4, r5, r6, pc}
      chSysUnlock();
      return msg;
    }
  }

  iqp->q_counter--;
 8000e98:	68a3      	ldr	r3, [r4, #8]
  b = *iqp->q_rdptr++;
 8000e9a:	69a2      	ldr	r2, [r4, #24]
      chSysUnlock();
      return msg;
    }
  }

  iqp->q_counter--;
 8000e9c:	3b01      	subs	r3, #1
 8000e9e:	60a3      	str	r3, [r4, #8]
  b = *iqp->q_rdptr++;
 8000ea0:	1c53      	adds	r3, r2, #1
 8000ea2:	61a3      	str	r3, [r4, #24]
 8000ea4:	7810      	ldrb	r0, [r2, #0]
  if (iqp->q_rdptr >= iqp->q_top) {
 8000ea6:	6922      	ldr	r2, [r4, #16]
 8000ea8:	4293      	cmp	r3, r2
    iqp->q_rdptr = iqp->q_buffer;
 8000eaa:	bf24      	itt	cs
 8000eac:	68e3      	ldrcs	r3, [r4, #12]
 8000eae:	61a3      	strcs	r3, [r4, #24]
 8000eb0:	2300      	movs	r3, #0
 8000eb2:	f383 8811 	msr	BASEPRI, r3
  }
  chSysUnlock();

  return (msg_t)b;
}
 8000eb6:	bd70      	pop	{r4, r5, r6, pc}
	...

08000ec0 <gett.lto_priv.57>:
  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
}

static msg_t gett(void *ip, systime_t timeout) {

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, timeout);
 8000ec0:	300c      	adds	r0, #12
 8000ec2:	f7ff bfd5 	b.w	8000e70 <chIQGetTimeout>
	...

08000ed0 <get.lto_priv.55>:
  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
}

static msg_t get(void *ip) {

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, TIME_INFINITE);
 8000ed0:	300c      	adds	r0, #12
 8000ed2:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 8000ed6:	f7ff bfcb 	b.w	8000e70 <chIQGetTimeout>
 8000eda:	0000      	movs	r0, r0
 8000edc:	0000      	movs	r0, r0
	...

08000ee0 <chThdSleep>:
 *                      - @a TIME_IMMEDIATE this value is not allowed.
 *                      .
 *
 * @api
 */
void chThdSleep(systime_t time) {
 8000ee0:	b508      	push	{r3, lr}
 8000ee2:	4601      	mov	r1, r0
 8000ee4:	2320      	movs	r3, #32
 8000ee6:	f383 8811 	msr	BASEPRI, r3
 */
static inline void chThdSleepS(systime_t time) {

  chDbgCheck(time != TIME_IMMEDIATE);

  (void) chSchGoSleepTimeoutS(CH_STATE_SLEEPING, time);
 8000eea:	2008      	movs	r0, #8
 8000eec:	f7ff fea0 	bl	8000c30 <chSchGoSleepTimeoutS>
 8000ef0:	2300      	movs	r3, #0
 8000ef2:	f383 8811 	msr	BASEPRI, r3
 8000ef6:	bd08      	pop	{r3, pc}
	...

08000f00 <chSchReadyI>:
  chDbgCheck(tp != NULL);
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
 8000f00:	2300      	movs	r3, #0
 8000f02:	7703      	strb	r3, [r0, #28]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio >= tp->p_prio);
 8000f04:	6882      	ldr	r2, [r0, #8]
  chDbgAssert((tp->p_state != CH_STATE_READY) &&
              (tp->p_state != CH_STATE_FINAL),
              "invalid state");

  tp->p_state = CH_STATE_READY;
  cp = (thread_t *)&ch.rlist.r_queue;
 8000f06:	4b05      	ldr	r3, [pc, #20]	; (8000f1c <chSchReadyI+0x1c>)
  do {
    cp = cp->p_next;
 8000f08:	681b      	ldr	r3, [r3, #0]
  } while (cp->p_prio >= tp->p_prio);
 8000f0a:	6899      	ldr	r1, [r3, #8]
 8000f0c:	4291      	cmp	r1, r2
 8000f0e:	d2fb      	bcs.n	8000f08 <chSchReadyI+0x8>
  /* Insertion on p_prev.*/
  tp->p_next = cp;
  tp->p_prev = cp->p_prev;
 8000f10:	685a      	ldr	r2, [r3, #4]
  cp = (thread_t *)&ch.rlist.r_queue;
  do {
    cp = cp->p_next;
  } while (cp->p_prio >= tp->p_prio);
  /* Insertion on p_prev.*/
  tp->p_next = cp;
 8000f12:	6003      	str	r3, [r0, #0]
  tp->p_prev = cp->p_prev;
 8000f14:	6042      	str	r2, [r0, #4]
  tp->p_prev->p_next = tp;
 8000f16:	6010      	str	r0, [r2, #0]
  cp->p_prev = tp;
 8000f18:	6058      	str	r0, [r3, #4]

  return tp;
}
 8000f1a:	4770      	bx	lr
 8000f1c:	20001a00 	.word	0x20001a00

08000f20 <chEvtBroadcastFlagsI>:
 * @param[in] esp       pointer to the @p event_source_t structure
 * @param[in] flags     the flags set to be added to the listener flags mask
 *
 * @iclass
 */
void chEvtBroadcastFlagsI(event_source_t *esp, eventflags_t flags) {
 8000f20:	b570      	push	{r4, r5, r6, lr}
  event_listener_t *elp;

  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->es_next;
 8000f22:	6804      	ldr	r4, [r0, #0]
 * @param[in] esp       pointer to the @p event_source_t structure
 * @param[in] flags     the flags set to be added to the listener flags mask
 *
 * @iclass
 */
void chEvtBroadcastFlagsI(event_source_t *esp, eventflags_t flags) {
 8000f24:	4605      	mov	r5, r0
 8000f26:	460e      	mov	r6, r1
  chDbgCheckClassI();
  chDbgCheck(esp != NULL);

  elp = esp->es_next;
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  while (elp != (event_listener_t *)esp) {
 8000f28:	42ac      	cmp	r4, r5
 8000f2a:	d01e      	beq.n	8000f6a <chEvtBroadcastFlagsI+0x4a>
  /*lint -restore*/
    elp->el_flags |= flags;
 8000f2c:	68e3      	ldr	r3, [r4, #12]
 8000f2e:	4333      	orrs	r3, r6
 8000f30:	60e3      	str	r3, [r4, #12]
    /* When flags == 0 the thread will always be signaled because the
       source does not emit any flag.*/
    if ((flags == (eventflags_t)0) ||
 8000f32:	b116      	cbz	r6, 8000f3a <chEvtBroadcastFlagsI+0x1a>
        ((elp->el_flags & elp->el_wflags) != (eventflags_t)0)) {
 8000f34:	6922      	ldr	r2, [r4, #16]
  while (elp != (event_listener_t *)esp) {
  /*lint -restore*/
    elp->el_flags |= flags;
    /* When flags == 0 the thread will always be signaled because the
       source does not emit any flag.*/
    if ((flags == (eventflags_t)0) ||
 8000f36:	4213      	tst	r3, r2
 8000f38:	d015      	beq.n	8000f66 <chEvtBroadcastFlagsI+0x46>
        ((elp->el_flags & elp->el_wflags) != (eventflags_t)0)) {
      chEvtSignalI(elp->el_listener, elp->el_events);
 8000f3a:	6860      	ldr	r0, [r4, #4]
void chEvtSignalI(thread_t *tp, eventmask_t events) {

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->p_epending |= events;
 8000f3c:	68a3      	ldr	r3, [r4, #8]
 8000f3e:	6b42      	ldr	r2, [r0, #52]	; 0x34
 8000f40:	4313      	orrs	r3, r2
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
 8000f42:	7f02      	ldrb	r2, [r0, #28]
void chEvtSignalI(thread_t *tp, eventmask_t events) {

  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->p_epending |= events;
 8000f44:	6343      	str	r3, [r0, #52]	; 0x34
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
 8000f46:	2a0a      	cmp	r2, #10
 8000f48:	d103      	bne.n	8000f52 <chEvtBroadcastFlagsI+0x32>
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
 8000f4a:	6a02      	ldr	r2, [r0, #32]
  chDbgCheckClassI();
  chDbgCheck(tp != NULL);

  tp->p_epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
 8000f4c:	4213      	tst	r3, r2
 8000f4e:	d106      	bne.n	8000f5e <chEvtBroadcastFlagsI+0x3e>
 8000f50:	e009      	b.n	8000f66 <chEvtBroadcastFlagsI+0x46>
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
 8000f52:	2a0b      	cmp	r2, #11
 8000f54:	d107      	bne.n	8000f66 <chEvtBroadcastFlagsI+0x46>
      ((tp->p_state == CH_STATE_WTANDEVT) &&
       ((tp->p_epending & tp->p_u.ewmask) == tp->p_u.ewmask))) {
 8000f56:	6a02      	ldr	r2, [r0, #32]
 8000f58:	4013      	ands	r3, r2

  tp->p_epending |= events;
  /* Test on the AND/OR conditions wait states.*/
  if (((tp->p_state == CH_STATE_WTOREVT) &&
       ((tp->p_epending & tp->p_u.ewmask) != (eventmask_t)0)) ||
      ((tp->p_state == CH_STATE_WTANDEVT) &&
 8000f5a:	4293      	cmp	r3, r2
 8000f5c:	d103      	bne.n	8000f66 <chEvtBroadcastFlagsI+0x46>
       ((tp->p_epending & tp->p_u.ewmask) == tp->p_u.ewmask))) {
    tp->p_u.rdymsg = MSG_OK;
 8000f5e:	2300      	movs	r3, #0
 8000f60:	6203      	str	r3, [r0, #32]
    (void) chSchReadyI(tp);
 8000f62:	f7ff ffcd 	bl	8000f00 <chSchReadyI>
       source does not emit any flag.*/
    if ((flags == (eventflags_t)0) ||
        ((elp->el_flags & elp->el_wflags) != (eventflags_t)0)) {
      chEvtSignalI(elp->el_listener, elp->el_events);
    }
    elp = elp->el_next;
 8000f66:	6824      	ldr	r4, [r4, #0]
 8000f68:	e7de      	b.n	8000f28 <chEvtBroadcastFlagsI+0x8>
  }
}
 8000f6a:	bd70      	pop	{r4, r5, r6, pc}
 8000f6c:	0000      	movs	r0, r0
	...

08000f70 <chMtxUnlock>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @api
 */
void chMtxUnlock(mutex_t *mp) {
 8000f70:	b570      	push	{r4, r5, r6, lr}
  thread_t *ctp = currp;
 8000f72:	4c17      	ldr	r4, [pc, #92]	; (8000fd0 <chMtxUnlock+0x60>)
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @api
 */
void chMtxUnlock(mutex_t *mp) {
 8000f74:	4603      	mov	r3, r0
  thread_t *ctp = currp;
 8000f76:	69a1      	ldr	r1, [r4, #24]
 8000f78:	2220      	movs	r2, #32
 8000f7a:	f382 8811 	msr	BASEPRI, r2
    chDbgAssert(ctp->p_mtxlist == mp, "not next in list");

    /* Removes the top mutex from the thread's owned mutexes list and marks
       it as not owned. Note, it is assumed to be the same mutex passed as
       parameter of this function.*/
    ctp->p_mtxlist = mp->m_next;
 8000f7e:	68c2      	ldr	r2, [r0, #12]
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->p_next != (const thread_t *)tqp);
 8000f80:	6800      	ldr	r0, [r0, #0]
 8000f82:	638a      	str	r2, [r1, #56]	; 0x38

    /* If a thread is waiting on the mutex then the fun part begins.*/
    if (chMtxQueueNotEmptyS(mp)) {
 8000f84:	4298      	cmp	r0, r3
 8000f86:	d01d      	beq.n	8000fc4 <chMtxUnlock+0x54>
      thread_t *tp;

      /* Recalculates the optimal thread priority by scanning the owned
         mutexes list.*/
      tprio_t newprio = ctp->p_realprio;
 8000f88:	6bcd      	ldr	r5, [r1, #60]	; 0x3c
      lmp = ctp->p_mtxlist;
      while (lmp != NULL) {
 8000f8a:	b142      	cbz	r2, 8000f9e <chMtxUnlock+0x2e>
 8000f8c:	6816      	ldr	r6, [r2, #0]
        /* If the highest priority thread waiting in the mutexes list has a
           greater priority than the current thread base priority then the
           final priority will have at least that priority.*/
        if (chMtxQueueNotEmptyS(lmp) &&
 8000f8e:	4296      	cmp	r6, r2
 8000f90:	d003      	beq.n	8000f9a <chMtxUnlock+0x2a>
            (lmp->m_queue.p_next->p_prio > newprio)) {
 8000f92:	68b6      	ldr	r6, [r6, #8]
 8000f94:	42b5      	cmp	r5, r6
 8000f96:	bf38      	it	cc
 8000f98:	4635      	movcc	r5, r6
          newprio = lmp->m_queue.p_next->p_prio;
        }
        lmp = lmp->m_next;
 8000f9a:	68d2      	ldr	r2, [r2, #12]
 8000f9c:	e7f5      	b.n	8000f8a <chMtxUnlock+0x1a>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  tqp->p_next = tp->p_next;
 8000f9e:	6802      	ldr	r2, [r0, #0]
      }

      /* Assigns to the current thread the highest priority among all the
         waiting threads.*/
      ctp->p_prio = newprio;
 8000fa0:	608d      	str	r5, [r1, #8]
 8000fa2:	601a      	str	r2, [r3, #0]
  tqp->p_next->p_prev = (thread_t *)tqp;
 8000fa4:	6053      	str	r3, [r2, #4]
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->m_cnt = (cnt_t)1;
#endif
      tp = queue_fifo_remove(&mp->m_queue);
      mp->m_owner = tp;
      mp->m_next = tp->p_mtxlist;
 8000fa6:	6b82      	ldr	r2, [r0, #56]	; 0x38
 8000fa8:	60da      	str	r2, [r3, #12]
         assigns the mutex to it.*/
#if CH_CFG_USE_MUTEXES_RECURSIVE == TRUE
      mp->m_cnt = (cnt_t)1;
#endif
      tp = queue_fifo_remove(&mp->m_queue);
      mp->m_owner = tp;
 8000faa:	6098      	str	r0, [r3, #8]
      mp->m_next = tp->p_mtxlist;
      tp->p_mtxlist = mp;
 8000fac:	6383      	str	r3, [r0, #56]	; 0x38

      /* Note, not using chSchWakeupS() becuase that function expects the
         current thread to have the higher or equal priority than the ones
         in the ready list. This is not necessarily true here because we
         just changed priority.*/
      (void) chSchReadyI(tp);
 8000fae:	f7ff ffa7 	bl	8000f00 <chSchReadyI>
 */
static inline bool chSchIsRescRequiredI(void) {

  chDbgCheckClassI();

  return firstprio(&ch.rlist.r_queue) > currp->p_prio;
 8000fb2:	6822      	ldr	r2, [r4, #0]
 8000fb4:	69a3      	ldr	r3, [r4, #24]
 */
void chSchRescheduleS(void) {

  chDbgCheckClassS();

  if (chSchIsRescRequiredI()) {
 8000fb6:	6892      	ldr	r2, [r2, #8]
 8000fb8:	689b      	ldr	r3, [r3, #8]
 8000fba:	429a      	cmp	r2, r3
 8000fbc:	d904      	bls.n	8000fc8 <chMtxUnlock+0x58>
    chSchDoRescheduleAhead();
 8000fbe:	f7ff fb8f 	bl	80006e0 <chSchDoRescheduleAhead>
 8000fc2:	e001      	b.n	8000fc8 <chMtxUnlock+0x58>
      chSchRescheduleS();
    }
    else {
      mp->m_owner = NULL;
 8000fc4:	2300      	movs	r3, #0
 8000fc6:	6083      	str	r3, [r0, #8]
 8000fc8:	2300      	movs	r3, #0
 8000fca:	f383 8811 	msr	BASEPRI, r3
 8000fce:	bd70      	pop	{r4, r5, r6, pc}
 8000fd0:	20001a00 	.word	0x20001a00
	...

08000fe0 <chMtxLock>:
 *
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @api
 */
void chMtxLock(mutex_t *mp) {
 8000fe0:	b570      	push	{r4, r5, r6, lr}
 8000fe2:	2320      	movs	r3, #32
 8000fe4:	4606      	mov	r6, r0
 8000fe6:	f383 8811 	msr	BASEPRI, r3
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @sclass
 */
void chMtxLockS(mutex_t *mp) {
  thread_t *ctp = currp;
 8000fea:	4b1f      	ldr	r3, [pc, #124]	; (8001068 <chMtxLock+0x88>)

  chDbgCheckClassS();
  chDbgCheck(mp != NULL);

  /* Is the mutex already locked? */
  if (mp->m_owner != NULL) {
 8000fec:	6884      	ldr	r4, [r0, #8]
 * @param[in] mp        pointer to the @p mutex_t structure
 *
 * @sclass
 */
void chMtxLockS(mutex_t *mp) {
  thread_t *ctp = currp;
 8000fee:	699d      	ldr	r5, [r3, #24]

  chDbgCheckClassS();
  chDbgCheck(mp != NULL);

  /* Is the mutex already locked? */
  if (mp->m_owner != NULL) {
 8000ff0:	2c00      	cmp	r4, #0
 8000ff2:	d031      	beq.n	8001058 <chMtxLock+0x78>
         priority of the running thread requesting the mutex.*/
      thread_t *tp = mp->m_owner;

      /* Does the running thread have higher priority than the mutex
         owning thread? */
      while (tp->p_prio < ctp->p_prio) {
 8000ff4:	68ab      	ldr	r3, [r5, #8]
 8000ff6:	68a2      	ldr	r2, [r4, #8]
 8000ff8:	429a      	cmp	r2, r3
 8000ffa:	d224      	bcs.n	8001046 <chMtxLock+0x66>
        /* Make priority of thread tp match the running thread's priority.*/
        tp->p_prio = ctp->p_prio;
 8000ffc:	60a3      	str	r3, [r4, #8]

        /* The following states need priority queues reordering.*/
        switch (tp->p_state) {
 8000ffe:	7f23      	ldrb	r3, [r4, #28]
 8001000:	2b06      	cmp	r3, #6
 8001002:	d00b      	beq.n	800101c <chMtxLock+0x3c>
 8001004:	2b07      	cmp	r3, #7
 8001006:	d015      	beq.n	8001034 <chMtxLock+0x54>
 8001008:	b9eb      	cbnz	r3, 8001046 <chMtxLock+0x66>
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->p_prev->p_next = tp->p_next;
 800100a:	e894 000c 	ldmia.w	r4, {r2, r3}
 800100e:	601a      	str	r2, [r3, #0]
  tp->p_next->p_prev = tp->p_prev;
 8001010:	6822      	ldr	r2, [r4, #0]
#if CH_DBG_ENABLE_ASSERTS == TRUE
          /* Prevents an assertion in chSchReadyI().*/
          tp->p_state = CH_STATE_CURRENT;
#endif
          /* Re-enqueues tp with its new priority on the ready list.*/
          (void) chSchReadyI(queue_dequeue(tp));
 8001012:	4620      	mov	r0, r4
 8001014:	6053      	str	r3, [r2, #4]
 8001016:	f7ff ff73 	bl	8000f00 <chSchReadyI>
 800101a:	e014      	b.n	8001046 <chMtxLock+0x66>
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->p_prev->p_next = tp->p_next;
 800101c:	e894 000c 	ldmia.w	r4, {r2, r3}
 8001020:	601a      	str	r2, [r3, #0]
  tp->p_next->p_prev = tp->p_prev;
 8001022:	6822      	ldr	r2, [r4, #0]

        /* The following states need priority queues reordering.*/
        switch (tp->p_state) {
        case CH_STATE_WTMTX:
          /* Re-enqueues the mutex owner with its new priority.*/
          queue_prio_insert(queue_dequeue(tp), &tp->p_u.wtmtxp->m_queue);
 8001024:	6a21      	ldr	r1, [r4, #32]
 8001026:	6053      	str	r3, [r2, #4]
 8001028:	4620      	mov	r0, r4
 800102a:	f7ff fb41 	bl	80006b0 <queue_prio_insert>
          tp = tp->p_u.wtmtxp->m_owner;
 800102e:	6a23      	ldr	r3, [r4, #32]
 8001030:	689c      	ldr	r4, [r3, #8]
 8001032:	e7df      	b.n	8000ff4 <chMtxLock+0x14>
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->p_prev->p_next = tp->p_next;
 8001034:	e894 000c 	ldmia.w	r4, {r2, r3}
 8001038:	601a      	str	r2, [r3, #0]
  tp->p_next->p_prev = tp->p_prev;
 800103a:	6822      	ldr	r2, [r4, #0]
#endif
#if (CH_CFG_USE_MESSAGES == TRUE) && (CH_CFG_USE_MESSAGES_PRIORITY == TRUE)
        case CH_STATE_SNDMSGQ:
#endif
          /* Re-enqueues tp with its new priority on the queue.*/
          queue_prio_insert(queue_dequeue(tp), &tp->p_u.wtmtxp->m_queue);
 800103c:	6a21      	ldr	r1, [r4, #32]
 800103e:	6053      	str	r3, [r2, #4]
 8001040:	4620      	mov	r0, r4
 8001042:	f7ff fb35 	bl	80006b0 <queue_prio_insert>
        }
        break;
      }

      /* Sleep on the mutex.*/
      queue_prio_insert(ctp, &mp->m_queue);
 8001046:	4628      	mov	r0, r5
 8001048:	4631      	mov	r1, r6
 800104a:	f7ff fb31 	bl	80006b0 <queue_prio_insert>
      ctp->p_u.wtmtxp = mp;
 800104e:	622e      	str	r6, [r5, #32]
      chSchGoSleepS(CH_STATE_WTMTX);
 8001050:	2006      	movs	r0, #6
 8001052:	f7ff fdd5 	bl	8000c00 <chSchGoSleepS>
 8001056:	e003      	b.n	8001060 <chMtxLock+0x80>

    mp->m_cnt++;
#endif
    /* It was not owned, inserted in the owned mutexes list.*/
    mp->m_owner = ctp;
    mp->m_next = ctp->p_mtxlist;
 8001058:	6bab      	ldr	r3, [r5, #56]	; 0x38
    chDbgAssert(mp->m_cnt == (cnt_t)0, "counter is not zero");

    mp->m_cnt++;
#endif
    /* It was not owned, inserted in the owned mutexes list.*/
    mp->m_owner = ctp;
 800105a:	6085      	str	r5, [r0, #8]
    mp->m_next = ctp->p_mtxlist;
 800105c:	60c3      	str	r3, [r0, #12]
    ctp->p_mtxlist = mp;
 800105e:	63a8      	str	r0, [r5, #56]	; 0x38
 8001060:	2300      	movs	r3, #0
 8001062:	f383 8811 	msr	BASEPRI, r3
 8001066:	bd70      	pop	{r4, r5, r6, pc}
 8001068:	20001a00 	.word	0x20001a00
 800106c:	00000000 	.word	0x00000000

08001070 <chThdRelease>:
 *
 * @param[in] tp        pointer to the thread
 *
 * @api
 */
void chThdRelease(thread_t *tp) {
 8001070:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8001072:	2120      	movs	r1, #32
 8001074:	4604      	mov	r4, r0
 8001076:	f381 8811 	msr	BASEPRI, r1
  trefs_t refs;

  chSysLock();
  chDbgAssert(tp->p_refs > (trefs_t)0, "not referenced");
  tp->p_refs--;
 800107a:	7f83      	ldrb	r3, [r0, #30]
 800107c:	3b01      	subs	r3, #1
 800107e:	b2db      	uxtb	r3, r3
 8001080:	7783      	strb	r3, [r0, #30]
 8001082:	2200      	movs	r2, #0
 8001084:	f382 8811 	msr	BASEPRI, r2
  chSysUnlock();

  /* If the references counter reaches zero and the thread is in its
     terminated state then the memory can be returned to the proper
     allocator. Of course static threads are not affected.*/
  if ((refs == (trefs_t)0) && (tp->p_state == CH_STATE_FINAL)) {
 8001088:	2b00      	cmp	r3, #0
 800108a:	d15a      	bne.n	8001142 <chThdRelease+0xd2>
 800108c:	7f02      	ldrb	r2, [r0, #28]
 800108e:	2a0f      	cmp	r2, #15
 8001090:	d157      	bne.n	8001142 <chThdRelease+0xd2>
    switch (tp->p_flags & CH_FLAG_MODE_MASK) {
 8001092:	7f42      	ldrb	r2, [r0, #29]
 8001094:	f002 0203 	and.w	r2, r2, #3
 8001098:	2a01      	cmp	r2, #1
 800109a:	d002      	beq.n	80010a2 <chThdRelease+0x32>
 800109c:	2a02      	cmp	r2, #2
 800109e:	d043      	beq.n	8001128 <chThdRelease+0xb8>
 80010a0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
#if CH_CFG_USE_HEAP == TRUE
    case CH_FLAG_MODE_HEAP:
#if CH_CFG_USE_REGISTRY == TRUE
      REG_REMOVE(tp);
 80010a2:	6943      	ldr	r3, [r0, #20]
 80010a4:	6902      	ldr	r2, [r0, #16]
 80010a6:	611a      	str	r2, [r3, #16]
 80010a8:	6902      	ldr	r2, [r0, #16]
 80010aa:	6153      	str	r3, [r2, #20]
  chDbgCheck(p != NULL);

  /*lint -save -e9087 [11.3] Safe cast.*/
  hp = (union heap_header *)p - 1;
  /*lint -restore*/
  heapp = hp->h.u.heap;
 80010ac:	f850 6c08 	ldr.w	r6, [r0, #-8]
  qp = &heapp->h_free;
 80010b0:	f106 0708 	add.w	r7, r6, #8

  H_LOCK(heapp);
 80010b4:	3610      	adds	r6, #16
  memory_heap_t *heapp;

  chDbgCheck(p != NULL);

  /*lint -save -e9087 [11.3] Safe cast.*/
  hp = (union heap_header *)p - 1;
 80010b6:	f1a0 0508 	sub.w	r5, r0, #8
  /*lint -restore*/
  heapp = hp->h.u.heap;
  qp = &heapp->h_free;

  H_LOCK(heapp);
 80010ba:	4630      	mov	r0, r6
 80010bc:	f7ff ff90 	bl	8000fe0 <chMtxLock>

  /*lint -save -e9087 [11.3] Safe cast.*/
  hp = (union heap_header *)p - 1;
  /*lint -restore*/
  heapp = hp->h.u.heap;
  qp = &heapp->h_free;
 80010c0:	463b      	mov	r3, r7

  H_LOCK(heapp);
  while (true) {
    chDbgAssert((hp < qp) || (hp >= LIMIT(qp)), "within free block");

    if (((qp == &heapp->h_free) || (hp > qp)) &&
 80010c2:	42bb      	cmp	r3, r7
 80010c4:	681a      	ldr	r2, [r3, #0]
 80010c6:	d001      	beq.n	80010cc <chThdRelease+0x5c>
 80010c8:	429d      	cmp	r5, r3
 80010ca:	d926      	bls.n	800111a <chThdRelease+0xaa>
 80010cc:	b10a      	cbz	r2, 80010d2 <chThdRelease+0x62>
        ((qp->h.u.next == NULL) || (hp < qp->h.u.next))) {
 80010ce:	4295      	cmp	r5, r2
 80010d0:	d223      	bcs.n	800111a <chThdRelease+0xaa>
      /* Insertion after qp.*/
      hp->h.u.next = qp->h.u.next;
      qp->h.u.next = hp;
      /* Verifies if the newly inserted block should be merged.*/
      if (LIMIT(hp) == hp->h.u.next) {
 80010d2:	f854 0c04 	ldr.w	r0, [r4, #-4]
    chDbgAssert((hp < qp) || (hp >= LIMIT(qp)), "within free block");

    if (((qp == &heapp->h_free) || (hp > qp)) &&
        ((qp->h.u.next == NULL) || (hp < qp->h.u.next))) {
      /* Insertion after qp.*/
      hp->h.u.next = qp->h.u.next;
 80010d6:	f844 2c08 	str.w	r2, [r4, #-8]
      qp->h.u.next = hp;
 80010da:	601d      	str	r5, [r3, #0]
      /* Verifies if the newly inserted block should be merged.*/
      if (LIMIT(hp) == hp->h.u.next) {
 80010dc:	f100 0108 	add.w	r1, r0, #8
 80010e0:	f854 7c08 	ldr.w	r7, [r4, #-8]
 80010e4:	186a      	adds	r2, r5, r1
 80010e6:	42ba      	cmp	r2, r7
        /* Merge with the next block.*/
        hp->h.size += hp->h.u.next->h.size + sizeof(union heap_header);
 80010e8:	bf01      	itttt	eq
 80010ea:	6852      	ldreq	r2, [r2, #4]
 80010ec:	1812      	addeq	r2, r2, r0
 80010ee:	3208      	addeq	r2, #8
 80010f0:	f844 2c04 	streq.w	r2, [r4, #-4]
        hp->h.u.next = hp->h.u.next->h.u.next;
      }
      if ((LIMIT(qp) == hp)) {
 80010f4:	6858      	ldr	r0, [r3, #4]
      qp->h.u.next = hp;
      /* Verifies if the newly inserted block should be merged.*/
      if (LIMIT(hp) == hp->h.u.next) {
        /* Merge with the next block.*/
        hp->h.size += hp->h.u.next->h.size + sizeof(union heap_header);
        hp->h.u.next = hp->h.u.next->h.u.next;
 80010f6:	bf04      	itt	eq
 80010f8:	586a      	ldreq	r2, [r5, r1]
 80010fa:	f844 2c08 	streq.w	r2, [r4, #-8]
      }
      if ((LIMIT(qp) == hp)) {
 80010fe:	f100 0108 	add.w	r1, r0, #8
 8001102:	4419      	add	r1, r3
 8001104:	428d      	cmp	r5, r1
 8001106:	d10a      	bne.n	800111e <chThdRelease+0xae>
        /* Merge with the previous block.*/
        qp->h.size += hp->h.size + sizeof(union heap_header);
 8001108:	f854 2c04 	ldr.w	r2, [r4, #-4]
 800110c:	4402      	add	r2, r0
 800110e:	3208      	adds	r2, #8
 8001110:	605a      	str	r2, [r3, #4]
        qp->h.u.next = hp->h.u.next;
 8001112:	f854 2c08 	ldr.w	r2, [r4, #-8]
 8001116:	601a      	str	r2, [r3, #0]
 8001118:	e001      	b.n	800111e <chThdRelease+0xae>
      }
      break;
    }
    qp = qp->h.u.next;
 800111a:	4613      	mov	r3, r2
 800111c:	e7d1      	b.n	80010c2 <chThdRelease+0x52>
  }
  H_UNLOCK(heapp);
 800111e:	4630      	mov	r0, r6
      /* Nothing to do for static threads, those are removed from the
         registry on exit.*/
      break;
    }
  }
}
 8001120:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
 8001124:	f7ff bf24 	b.w	8000f70 <chMtxUnlock>
      break;
#endif
#if CH_CFG_USE_MEMPOOLS == TRUE
    case CH_FLAG_MODE_MPOOL:
#if CH_CFG_USE_REGISTRY == TRUE
      REG_REMOVE(tp);
 8001128:	6942      	ldr	r2, [r0, #20]
 800112a:	6900      	ldr	r0, [r0, #16]
 800112c:	6110      	str	r0, [r2, #16]
 800112e:	6920      	ldr	r0, [r4, #16]
 8001130:	6142      	str	r2, [r0, #20]
#endif
      chPoolFree(tp->p_mpool, tp);
 8001132:	6c22      	ldr	r2, [r4, #64]	; 0x40
 8001134:	f381 8811 	msr	BASEPRI, r1
  struct pool_header *php = objp;

  chDbgCheckClassI();
  chDbgCheck((mp != NULL) && (objp != NULL));

  php->ph_next = mp->mp_next;
 8001138:	6811      	ldr	r1, [r2, #0]
 800113a:	6021      	str	r1, [r4, #0]
  mp->mp_next = php;
 800113c:	6014      	str	r4, [r2, #0]
 800113e:	f383 8811 	msr	BASEPRI, r3
 8001142:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
	...

08001150 <chThdResumeI>:
 *
 * @iclass
 */
void chThdResumeI(thread_reference_t *trp, msg_t msg) {

  if (*trp != NULL) {
 8001150:	6803      	ldr	r3, [r0, #0]
 8001152:	b12b      	cbz	r3, 8001160 <chThdResumeI+0x10>
    thread_t *tp = *trp;

    chDbgAssert(tp->p_state == CH_STATE_SUSPENDED,
                "not THD_STATE_SUSPENDED");

    *trp = NULL;
 8001154:	2200      	movs	r2, #0
 8001156:	6002      	str	r2, [r0, #0]
    tp->p_u.rdymsg = msg;
 8001158:	6219      	str	r1, [r3, #32]
    (void) chSchReadyI(tp);
 800115a:	4618      	mov	r0, r3
 800115c:	f7ff bed0 	b.w	8000f00 <chSchReadyI>
 8001160:	4770      	bx	lr
	...

08001170 <adc_lld_serve_interrupt.lto_priv.89>:
 */
static void adc_lld_serve_interrupt(ADCDriver *adcp, uint32_t isr) {

  /* It could be a spurious interrupt caused by overflows after DMA disabling,
     just ignore it in this case.*/
  if (adcp->grpp != NULL) {
 8001170:	6903      	ldr	r3, [r0, #16]
 * @brief   ADC ISR service routine.
 *
 * @param[in] adcp      pointer to the @p ADCDriver object
 * @param[in] isr       content of the ISR register
 */
static void adc_lld_serve_interrupt(ADCDriver *adcp, uint32_t isr) {
 8001172:	b570      	push	{r4, r5, r6, lr}
 8001174:	4604      	mov	r4, r0
 8001176:	460d      	mov	r5, r1

  /* It could be a spurious interrupt caused by overflows after DMA disabling,
     just ignore it in this case.*/
  if (adcp->grpp != NULL) {
 8001178:	2b00      	cmp	r3, #0
 800117a:	d07e      	beq.n	800127a <adc_lld_serve_interrupt.lto_priv.89+0x10a>
    /* Note, an overflow may occur after the conversion ended before the driver
       is able to stop the ADC, this is why the DMA channel is checked too.*/
    if ((isr & ADC_ISR_OVR) &&
 800117c:	06ce      	lsls	r6, r1, #27
 800117e:	d51f      	bpl.n	80011c0 <adc_lld_serve_interrupt.lto_priv.89+0x50>
        (dmaStreamGetTransactionSize(adcp->dmastp) > 0)) {
 8001180:	6b43      	ldr	r3, [r0, #52]	; 0x34
 8001182:	681b      	ldr	r3, [r3, #0]
 8001184:	685b      	ldr	r3, [r3, #4]
  /* It could be a spurious interrupt caused by overflows after DMA disabling,
     just ignore it in this case.*/
  if (adcp->grpp != NULL) {
    /* Note, an overflow may occur after the conversion ended before the driver
       is able to stop the ADC, this is why the DMA channel is checked too.*/
    if ((isr & ADC_ISR_OVR) &&
 8001186:	b1db      	cbz	r3, 80011c0 <adc_lld_serve_interrupt.lto_priv.89+0x50>
        (dmaStreamGetTransactionSize(adcp->dmastp) > 0)) {
      /* ADC overflow condition, this could happen only if the DMA is unable
         to read data fast enough.*/
      _adc_isr_error_code(adcp, ADC_ERR_OVERFLOW);
 8001188:	f000 fefa 	bl	8001f80 <adc_lld_stop_conversion>
 800118c:	6923      	ldr	r3, [r4, #16]
 800118e:	689b      	ldr	r3, [r3, #8]
 8001190:	b14b      	cbz	r3, 80011a6 <adc_lld_serve_interrupt.lto_priv.89+0x36>
 8001192:	2205      	movs	r2, #5
 8001194:	7022      	strb	r2, [r4, #0]
 8001196:	4620      	mov	r0, r4
 8001198:	2101      	movs	r1, #1
 800119a:	4798      	blx	r3
 800119c:	7823      	ldrb	r3, [r4, #0]
 800119e:	2b05      	cmp	r3, #5
 80011a0:	bf04      	itt	eq
 80011a2:	2302      	moveq	r3, #2
 80011a4:	7023      	strbeq	r3, [r4, #0]
 80011a6:	2600      	movs	r6, #0
 80011a8:	6126      	str	r6, [r4, #16]
 80011aa:	2320      	movs	r3, #32
 80011ac:	f383 8811 	msr	BASEPRI, r3
 *
 * @iclass
 */
static inline void osalThreadResumeI(thread_reference_t *trp, msg_t msg) {

  chThdResumeI(trp, msg);
 80011b0:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 80011b4:	f104 0014 	add.w	r0, r4, #20
 80011b8:	f7ff ffca 	bl	8001150 <chThdResumeI>
 80011bc:	f386 8811 	msr	BASEPRI, r6
    }
    if (isr & ADC_ISR_AWD1) {
 80011c0:	0629      	lsls	r1, r5, #24
 80011c2:	d51c      	bpl.n	80011fe <adc_lld_serve_interrupt.lto_priv.89+0x8e>
      /* Analog watchdog error.*/
      _adc_isr_error_code(adcp, ADC_ERR_AWD1);
 80011c4:	4620      	mov	r0, r4
 80011c6:	f000 fedb 	bl	8001f80 <adc_lld_stop_conversion>
 80011ca:	6923      	ldr	r3, [r4, #16]
 80011cc:	689b      	ldr	r3, [r3, #8]
 80011ce:	b14b      	cbz	r3, 80011e4 <adc_lld_serve_interrupt.lto_priv.89+0x74>
 80011d0:	2205      	movs	r2, #5
 80011d2:	7022      	strb	r2, [r4, #0]
 80011d4:	4620      	mov	r0, r4
 80011d6:	2102      	movs	r1, #2
 80011d8:	4798      	blx	r3
 80011da:	7823      	ldrb	r3, [r4, #0]
 80011dc:	2b05      	cmp	r3, #5
 80011de:	bf04      	itt	eq
 80011e0:	2302      	moveq	r3, #2
 80011e2:	7023      	strbeq	r3, [r4, #0]
 80011e4:	2600      	movs	r6, #0
 80011e6:	6126      	str	r6, [r4, #16]
 80011e8:	2320      	movs	r3, #32
 80011ea:	f383 8811 	msr	BASEPRI, r3
 80011ee:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 80011f2:	f104 0014 	add.w	r0, r4, #20
 80011f6:	f7ff ffab 	bl	8001150 <chThdResumeI>
 80011fa:	f386 8811 	msr	BASEPRI, r6
    }
    if (isr & ADC_ISR_AWD2) {
 80011fe:	05ea      	lsls	r2, r5, #23
 8001200:	d51c      	bpl.n	800123c <adc_lld_serve_interrupt.lto_priv.89+0xcc>
      /* Analog watchdog error.*/
      _adc_isr_error_code(adcp, ADC_ERR_AWD2);
 8001202:	4620      	mov	r0, r4
 8001204:	f000 febc 	bl	8001f80 <adc_lld_stop_conversion>
 8001208:	6923      	ldr	r3, [r4, #16]
 800120a:	689b      	ldr	r3, [r3, #8]
 800120c:	b14b      	cbz	r3, 8001222 <adc_lld_serve_interrupt.lto_priv.89+0xb2>
 800120e:	2205      	movs	r2, #5
 8001210:	7022      	strb	r2, [r4, #0]
 8001212:	4620      	mov	r0, r4
 8001214:	2103      	movs	r1, #3
 8001216:	4798      	blx	r3
 8001218:	7823      	ldrb	r3, [r4, #0]
 800121a:	2b05      	cmp	r3, #5
 800121c:	bf04      	itt	eq
 800121e:	2302      	moveq	r3, #2
 8001220:	7023      	strbeq	r3, [r4, #0]
 8001222:	2600      	movs	r6, #0
 8001224:	6126      	str	r6, [r4, #16]
 8001226:	2320      	movs	r3, #32
 8001228:	f383 8811 	msr	BASEPRI, r3
 800122c:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 8001230:	f104 0014 	add.w	r0, r4, #20
 8001234:	f7ff ff8c 	bl	8001150 <chThdResumeI>
 8001238:	f386 8811 	msr	BASEPRI, r6
    }
    if (isr & ADC_ISR_AWD3) {
 800123c:	05ab      	lsls	r3, r5, #22
 800123e:	d51c      	bpl.n	800127a <adc_lld_serve_interrupt.lto_priv.89+0x10a>
      /* Analog watchdog error.*/
      _adc_isr_error_code(adcp, ADC_ERR_AWD3);
 8001240:	4620      	mov	r0, r4
 8001242:	f000 fe9d 	bl	8001f80 <adc_lld_stop_conversion>
 8001246:	6923      	ldr	r3, [r4, #16]
 8001248:	689b      	ldr	r3, [r3, #8]
 800124a:	b14b      	cbz	r3, 8001260 <adc_lld_serve_interrupt.lto_priv.89+0xf0>
 800124c:	2205      	movs	r2, #5
 800124e:	7022      	strb	r2, [r4, #0]
 8001250:	4620      	mov	r0, r4
 8001252:	2104      	movs	r1, #4
 8001254:	4798      	blx	r3
 8001256:	7823      	ldrb	r3, [r4, #0]
 8001258:	2b05      	cmp	r3, #5
 800125a:	bf04      	itt	eq
 800125c:	2302      	moveq	r3, #2
 800125e:	7023      	strbeq	r3, [r4, #0]
 8001260:	2500      	movs	r5, #0
 8001262:	6125      	str	r5, [r4, #16]
 8001264:	2320      	movs	r3, #32
 8001266:	f383 8811 	msr	BASEPRI, r3
 800126a:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 800126e:	f104 0014 	add.w	r0, r4, #20
 8001272:	f7ff ff6d 	bl	8001150 <chThdResumeI>
 8001276:	f385 8811 	msr	BASEPRI, r5
 800127a:	bd70      	pop	{r4, r5, r6, pc}
 800127c:	0000      	movs	r0, r0
	...

08001280 <adc_lld_serve_dma_interrupt.lto_priv.64>:
 * @brief   ADC DMA ISR service routine.
 *
 * @param[in] adcp      pointer to the @p ADCDriver object
 * @param[in] flags     pre-shifted content of the ISR register
 */
static void adc_lld_serve_dma_interrupt(ADCDriver *adcp, uint32_t flags) {
 8001280:	b570      	push	{r4, r5, r6, lr}

  /* DMA errors handling.*/
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
 8001282:	070e      	lsls	r6, r1, #28
 * @brief   ADC DMA ISR service routine.
 *
 * @param[in] adcp      pointer to the @p ADCDriver object
 * @param[in] flags     pre-shifted content of the ISR register
 */
static void adc_lld_serve_dma_interrupt(ADCDriver *adcp, uint32_t flags) {
 8001284:	4604      	mov	r4, r0

  /* DMA errors handling.*/
  if ((flags & (STM32_DMA_ISR_TEIF | STM32_DMA_ISR_DMEIF)) != 0) {
 8001286:	d51c      	bpl.n	80012c2 <adc_lld_serve_dma_interrupt.lto_priv.64+0x42>
    /* DMA, this could help only if the DMA tries to access an unmapped
       address space or violates alignment rules.*/
    _adc_isr_error_code(adcp, ADC_ERR_DMAFAILURE);
 8001288:	f000 fe7a 	bl	8001f80 <adc_lld_stop_conversion>
 800128c:	6923      	ldr	r3, [r4, #16]
 800128e:	689b      	ldr	r3, [r3, #8]
 8001290:	b14b      	cbz	r3, 80012a6 <adc_lld_serve_dma_interrupt.lto_priv.64+0x26>
 8001292:	2205      	movs	r2, #5
 8001294:	7022      	strb	r2, [r4, #0]
 8001296:	4620      	mov	r0, r4
 8001298:	2100      	movs	r1, #0
 800129a:	4798      	blx	r3
 800129c:	7823      	ldrb	r3, [r4, #0]
 800129e:	2b05      	cmp	r3, #5
 80012a0:	bf04      	itt	eq
 80012a2:	2302      	moveq	r3, #2
 80012a4:	7023      	strbeq	r3, [r4, #0]
 80012a6:	2500      	movs	r5, #0
 80012a8:	6125      	str	r5, [r4, #16]
 80012aa:	2320      	movs	r3, #32
 80012ac:	f383 8811 	msr	BASEPRI, r3
 80012b0:	f04f 31ff 	mov.w	r1, #4294967295	; 0xffffffff
 80012b4:	f104 0014 	add.w	r0, r4, #20
 80012b8:	f7ff ff4a 	bl	8001150 <chThdResumeI>
 80012bc:	f385 8811 	msr	BASEPRI, r5
 80012c0:	bd70      	pop	{r4, r5, r6, pc}
  }
  else {
    /* It is possible that the conversion group has already be reset by the
       ADC error handler, in this case this interrupt is spurious.*/
    if (adcp->grpp != NULL) {
 80012c2:	6903      	ldr	r3, [r0, #16]
 80012c4:	2b00      	cmp	r3, #0
 80012c6:	d03b      	beq.n	8001340 <adc_lld_serve_dma_interrupt.lto_priv.64+0xc0>
      if ((flags & STM32_DMA_ISR_TCIF) != 0) {
 80012c8:	078d      	lsls	r5, r1, #30
 80012ca:	d52f      	bpl.n	800132c <adc_lld_serve_dma_interrupt.lto_priv.64+0xac>
        /* Transfer complete processing.*/
        _adc_isr_full_code(adcp);
 80012cc:	781a      	ldrb	r2, [r3, #0]
 80012ce:	b17a      	cbz	r2, 80012f0 <adc_lld_serve_dma_interrupt.lto_priv.64+0x70>
 80012d0:	685d      	ldr	r5, [r3, #4]
 80012d2:	2d00      	cmp	r5, #0
 80012d4:	d034      	beq.n	8001340 <adc_lld_serve_dma_interrupt.lto_priv.64+0xc0>
 80012d6:	68c2      	ldr	r2, [r0, #12]
 80012d8:	2a01      	cmp	r2, #1
 80012da:	bf85      	ittet	hi
 80012dc:	885b      	ldrhhi	r3, [r3, #2]
 80012de:	6881      	ldrhi	r1, [r0, #8]
 80012e0:	6881      	ldrls	r1, [r0, #8]
 80012e2:	0852      	lsrhi	r2, r2, #1
 80012e4:	bf84      	itt	hi
 80012e6:	4353      	mulhi	r3, r2
 80012e8:	eb01 0143 	addhi.w	r1, r1, r3, lsl #1
 80012ec:	462b      	mov	r3, r5
 80012ee:	e024      	b.n	800133a <adc_lld_serve_dma_interrupt.lto_priv.64+0xba>
 80012f0:	f000 fe46 	bl	8001f80 <adc_lld_stop_conversion>
 80012f4:	6923      	ldr	r3, [r4, #16]
 80012f6:	685b      	ldr	r3, [r3, #4]
 80012f8:	b143      	cbz	r3, 800130c <adc_lld_serve_dma_interrupt.lto_priv.64+0x8c>
 80012fa:	2204      	movs	r2, #4
 80012fc:	7022      	strb	r2, [r4, #0]
 80012fe:	4620      	mov	r0, r4
 8001300:	68a1      	ldr	r1, [r4, #8]
 8001302:	68e2      	ldr	r2, [r4, #12]
 8001304:	4798      	blx	r3
 8001306:	7823      	ldrb	r3, [r4, #0]
 8001308:	2b04      	cmp	r3, #4
 800130a:	d103      	bne.n	8001314 <adc_lld_serve_dma_interrupt.lto_priv.64+0x94>
 800130c:	2302      	movs	r3, #2
 800130e:	7023      	strb	r3, [r4, #0]
 8001310:	2300      	movs	r3, #0
 8001312:	6123      	str	r3, [r4, #16]
 8001314:	2320      	movs	r3, #32
 8001316:	f383 8811 	msr	BASEPRI, r3
 800131a:	2100      	movs	r1, #0
 800131c:	f104 0014 	add.w	r0, r4, #20
 8001320:	f7ff ff16 	bl	8001150 <chThdResumeI>
 8001324:	2300      	movs	r3, #0
 8001326:	f383 8811 	msr	BASEPRI, r3
 800132a:	bd70      	pop	{r4, r5, r6, pc}
      }
      else if ((flags & STM32_DMA_ISR_HTIF) != 0) {
 800132c:	074a      	lsls	r2, r1, #29
 800132e:	d507      	bpl.n	8001340 <adc_lld_serve_dma_interrupt.lto_priv.64+0xc0>
        /* Half transfer processing.*/
        _adc_isr_half_code(adcp);
 8001330:	685b      	ldr	r3, [r3, #4]
 8001332:	b12b      	cbz	r3, 8001340 <adc_lld_serve_dma_interrupt.lto_priv.64+0xc0>
 8001334:	68c2      	ldr	r2, [r0, #12]
 8001336:	6881      	ldr	r1, [r0, #8]
 8001338:	0852      	lsrs	r2, r2, #1
      }
    }
  }
}
 800133a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
        /* Transfer complete processing.*/
        _adc_isr_full_code(adcp);
      }
      else if ((flags & STM32_DMA_ISR_HTIF) != 0) {
        /* Half transfer processing.*/
        _adc_isr_half_code(adcp);
 800133e:	4718      	bx	r3
 8001340:	bd70      	pop	{r4, r5, r6, pc}
	...

08001350 <chThdExitS>:
 * @param[in] msg       thread exit code
 *
 * @sclass
 */
void chThdExitS(msg_t msg) {
  thread_t *tp = currp;
 8001350:	4b0e      	ldr	r3, [pc, #56]	; (800138c <chThdExitS+0x3c>)
 *
 * @param[in] msg       thread exit code
 *
 * @sclass
 */
void chThdExitS(msg_t msg) {
 8001352:	b510      	push	{r4, lr}
  thread_t *tp = currp;
 8001354:	699c      	ldr	r4, [r3, #24]

  tp->p_u.exitcode = msg;
 8001356:	6220      	str	r0, [r4, #32]
 *
 * @notapi
 */
static inline bool list_notempty(threads_list_t *tlp) {

  return (bool)(tlp->p_next != (thread_t *)tlp);
 8001358:	4623      	mov	r3, r4
 800135a:	f853 0f24 	ldr.w	r0, [r3, #36]!
#if defined(CH_CFG_THREAD_EXIT_HOOK)
  CH_CFG_THREAD_EXIT_HOOK(tp);
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  while (list_notempty(&tp->p_waiting)) {
 800135e:	4298      	cmp	r0, r3
 8001360:	d004      	beq.n	800136c <chThdExitS+0x1c>
}

static inline thread_t *list_remove(threads_list_t *tlp) {

  thread_t *tp = tlp->p_next;
  tlp->p_next = tp->p_next;
 8001362:	6803      	ldr	r3, [r0, #0]
 8001364:	6263      	str	r3, [r4, #36]	; 0x24
    (void) chSchReadyI(list_remove(&tp->p_waiting));
 8001366:	f7ff fdcb 	bl	8000f00 <chSchReadyI>
 800136a:	e7f5      	b.n	8001358 <chThdExitS+0x8>
  }
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  /* Static threads are immediately removed from the registry because
     there is no memory to recover.*/
  if ((tp->p_flags & CH_FLAG_MODE_MASK) == CH_FLAG_MODE_STATIC) {
 800136c:	7f63      	ldrb	r3, [r4, #29]
 800136e:	079b      	lsls	r3, r3, #30
    REG_REMOVE(tp);
 8001370:	bf01      	itttt	eq
 8001372:	6963      	ldreq	r3, [r4, #20]
 8001374:	6922      	ldreq	r2, [r4, #16]
 8001376:	611a      	streq	r2, [r3, #16]
 8001378:	6922      	ldreq	r2, [r4, #16]
  }
#endif
  chSchGoSleepS(CH_STATE_FINAL);
 800137a:	f04f 000f 	mov.w	r0, #15
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  /* Static threads are immediately removed from the registry because
     there is no memory to recover.*/
  if ((tp->p_flags & CH_FLAG_MODE_MASK) == CH_FLAG_MODE_STATIC) {
    REG_REMOVE(tp);
 800137e:	bf08      	it	eq
 8001380:	6153      	streq	r3, [r2, #20]
#endif
  chSchGoSleepS(CH_STATE_FINAL);

  /* The thread never returns here.*/
  chDbgAssert(false, "zombies apocalypse");
}
 8001382:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
     there is no memory to recover.*/
  if ((tp->p_flags & CH_FLAG_MODE_MASK) == CH_FLAG_MODE_STATIC) {
    REG_REMOVE(tp);
  }
#endif
  chSchGoSleepS(CH_STATE_FINAL);
 8001386:	f7ff bc3b 	b.w	8000c00 <chSchGoSleepS>
 800138a:	bf00      	nop
 800138c:	20001a00 	.word	0x20001a00

08001390 <chThdExit>:
 8001390:	2320      	movs	r3, #32
 8001392:	f383 8811 	msr	BASEPRI, r3
 * @api
 */
void chThdExit(msg_t msg) {

  chSysLock();
  chThdExitS(msg);
 8001396:	f7ff bfdb 	b.w	8001350 <chThdExitS>
 800139a:	0000      	movs	r0, r0
 800139c:	0000      	movs	r0, r0
	...

080013a0 <chSchDoReschedule>:
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoReschedule(void) {
 80013a0:	b538      	push	{r3, r4, r5, lr}

#if CH_CFG_TIME_QUANTUM > 0
  /* If CH_CFG_TIME_QUANTUM is enabled then there are two different scenarios
     to handle on preemption: time quantum elapsed or not.*/
  if (currp->p_preempt == (tslices_t)0) {
 80013a2:	4c0c      	ldr	r4, [pc, #48]	; (80013d4 <chSchDoReschedule+0x34>)
 80013a4:	69a5      	ldr	r5, [r4, #24]
 80013a6:	7feb      	ldrb	r3, [r5, #31]
 80013a8:	b983      	cbnz	r3, 80013cc <chSchDoReschedule+0x2c>
  tp->p_prev->p_next = tp;
  tqp->p_prev = tp;
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;
 80013aa:	6823      	ldr	r3, [r4, #0]

  tqp->p_next = tp->p_next;
 80013ac:	681a      	ldr	r2, [r3, #0]
 80013ae:	6022      	str	r2, [r4, #0]
  tqp->p_next->p_prev = (thread_t *)tqp;
 80013b0:	6054      	str	r4, [r2, #4]
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
  if (otp->p_prio == IDLEPRIO) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
 80013b2:	2201      	movs	r2, #1
 80013b4:	771a      	strb	r2, [r3, #28]
#if CH_CFG_TIME_QUANTUM > 0
  otp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
  (void) chSchReadyI(otp);
 80013b6:	4628      	mov	r0, r5
    CH_CFG_IDLE_LEAVE_HOOK();
  }
#endif
  currp->p_state = CH_STATE_CURRENT;
#if CH_CFG_TIME_QUANTUM > 0
  otp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
 80013b8:	77ea      	strb	r2, [r5, #31]
void chSchDoRescheduleBehind(void) {
  thread_t *otp;

  otp = currp;
  /* Picks the first thread from the ready queue and makes it current.*/
  setcurrp(queue_fifo_remove(&ch.rlist.r_queue));
 80013ba:	61a3      	str	r3, [r4, #24]
#endif
  currp->p_state = CH_STATE_CURRENT;
#if CH_CFG_TIME_QUANTUM > 0
  otp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
  (void) chSchReadyI(otp);
 80013bc:	f7ff fda0 	bl	8000f00 <chSchReadyI>
  chSysSwitch(currp, otp);
 80013c0:	69a0      	ldr	r0, [r4, #24]
 80013c2:	4629      	mov	r1, r5
#else /* !(CH_CFG_TIME_QUANTUM > 0) */
  /* If the round-robin mechanism is disabled then the thread goes always
     ahead of its peers.*/
  chSchDoRescheduleAhead();
#endif /* !(CH_CFG_TIME_QUANTUM > 0) */
}
 80013c4:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  currp->p_state = CH_STATE_CURRENT;
#if CH_CFG_TIME_QUANTUM > 0
  otp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
  (void) chSchReadyI(otp);
  chSysSwitch(currp, otp);
 80013c8:	f7fe bf72 	b.w	80002b0 <_port_switch>
#else /* !(CH_CFG_TIME_QUANTUM > 0) */
  /* If the round-robin mechanism is disabled then the thread goes always
     ahead of its peers.*/
  chSchDoRescheduleAhead();
#endif /* !(CH_CFG_TIME_QUANTUM > 0) */
}
 80013cc:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    chSchDoRescheduleBehind();
  }
  else {
    /* The thread didn't consume all its time quantum so it is put ahead of
       threads with equal priority and does not acquire a new time quantum.*/
    chSchDoRescheduleAhead();
 80013d0:	f7ff b986 	b.w	80006e0 <chSchDoRescheduleAhead>
 80013d4:	20001a00 	.word	0x20001a00
	...

080013e0 <wakeup>:
}

/*
 * Timeout wakeup callback.
 */
static void wakeup(void *p) {
 80013e0:	b508      	push	{r3, lr}
 80013e2:	2320      	movs	r3, #32
 80013e4:	f383 8811 	msr	BASEPRI, r3
  thread_t *tp = (thread_t *)p;

  chSysLockFromISR();
  switch (tp->p_state) {
 80013e8:	7f02      	ldrb	r2, [r0, #28]
 80013ea:	2300      	movs	r3, #0
 80013ec:	2a07      	cmp	r2, #7
 80013ee:	d811      	bhi.n	8001414 <wakeup+0x34>
 80013f0:	e8df f002 	tbb	[pc, r2]
 80013f4:	04101016 	.word	0x04101016
 80013f8:	0b10070b 	.word	0x0b10070b
    /* Handling the special case where the thread has been made ready by
       another thread with higher priority.*/
    chSysUnlockFromISR();
    return;
  case CH_STATE_SUSPENDED:
    *tp->p_u.wttrp = NULL;
 80013fc:	6a02      	ldr	r2, [r0, #32]
 80013fe:	6013      	str	r3, [r2, #0]
 8001400:	e008      	b.n	8001414 <wakeup+0x34>
    break;
#if CH_CFG_USE_SEMAPHORES == TRUE
  case CH_STATE_WTSEM:
    chSemFastSignalI(tp->p_u.wtsemp);
 8001402:	6a02      	ldr	r2, [r0, #32]
 */
static inline void chSemFastSignalI(semaphore_t *sp) {

  chDbgCheckClassI();

  sp->s_cnt++;
 8001404:	6893      	ldr	r3, [r2, #8]
 8001406:	3301      	adds	r3, #1
 8001408:	6093      	str	r3, [r2, #8]
  return tp;
}

static inline thread_t *queue_dequeue(thread_t *tp) {

  tp->p_prev->p_next = tp->p_next;
 800140a:	e890 000c 	ldmia.w	r0, {r2, r3}
 800140e:	601a      	str	r2, [r3, #0]
  tp->p_next->p_prev = tp->p_prev;
 8001410:	6802      	ldr	r2, [r0, #0]
 8001412:	6053      	str	r3, [r2, #4]
    break;
  default:
    /* Any other state, nothing to do.*/
    break;
  }
  tp->p_u.rdymsg = MSG_TIMEOUT;
 8001414:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8001418:	6203      	str	r3, [r0, #32]
  (void) chSchReadyI(tp);
 800141a:	f7ff fd71 	bl	8000f00 <chSchReadyI>
 800141e:	2300      	movs	r3, #0
 8001420:	f383 8811 	msr	BASEPRI, r3
 8001424:	bd08      	pop	{r3, pc}
	...

08001430 <BusFault_Handler>:
 *          This function simply stops the system into an infinite loop.
 *
 * @notapi
 */
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void _unhandled_exception(void) {
 8001430:	e7fe      	b.n	8001430 <BusFault_Handler>
	...

08001440 <__default_exit>:
 */
#if !defined(__DOXYGEN__)
__attribute__((noreturn, weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __default_exit(void) {
 8001440:	e7fe      	b.n	8001440 <__default_exit>
	...

08001450 <__late_init>:
 */
#if !defined(__DOXYGEN__)
__attribute__((weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __late_init(void) {}
 8001450:	4770      	bx	lr
	...

08001460 <__core_init>:
 */
#if !defined(__DOXYGEN__)
__attribute__((weak))
#endif
/*lint -save -e9075 [8.4] All symbols are invoked from asm context.*/
void __core_init(void) {
 8001460:	4770      	bx	lr
	...

08001470 <notify2.lto_priv.67>:

#if STM32_SERIAL_USE_USART2 || defined(__DOXYGEN__)
static void notify2(io_queue_t *qp) {

  (void)qp;
  USART2->CR1 |= USART_CR1_TXEIE;
 8001470:	4a02      	ldr	r2, [pc, #8]	; (800147c <notify2.lto_priv.67+0xc>)
 8001472:	6813      	ldr	r3, [r2, #0]
 8001474:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8001478:	6013      	str	r3, [r2, #0]
 800147a:	4770      	bx	lr
 800147c:	40004400 	.word	0x40004400

08001480 <notify1.lto_priv.66>:

#if STM32_SERIAL_USE_USART1 || defined(__DOXYGEN__)
static void notify1(io_queue_t *qp) {

  (void)qp;
  USART1->CR1 |= USART_CR1_TXEIE;
 8001480:	4a02      	ldr	r2, [pc, #8]	; (800148c <notify1.lto_priv.66+0xc>)
 8001482:	6813      	ldr	r3, [r2, #0]
 8001484:	f043 0380 	orr.w	r3, r3, #128	; 0x80
 8001488:	6013      	str	r3, [r2, #0]
 800148a:	4770      	bx	lr
 800148c:	40013800 	.word	0x40013800

08001490 <VectorB4>:
/**
 * @brief   TIM3 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_TIM3_HANDLER) {
 8001490:	b538      	push	{r3, r4, r5, lr}
 * @param[in] pwmp      pointer to a @p PWMDriver object
 */
static void pwm_lld_serve_interrupt(PWMDriver *pwmp) {
  uint32_t sr;

  sr  = pwmp->tim->SR;
 8001492:	4c17      	ldr	r4, [pc, #92]	; (80014f0 <VectorB4+0x60>)
 8001494:	69a3      	ldr	r3, [r4, #24]
 8001496:	691a      	ldr	r2, [r3, #16]
  sr &= pwmp->tim->DIER & STM32_TIM_DIER_IRQ_MASK;
 8001498:	68dd      	ldr	r5, [r3, #12]
 800149a:	4015      	ands	r5, r2
 800149c:	b2ea      	uxtb	r2, r5
  pwmp->tim->SR = ~sr;
 800149e:	43d2      	mvns	r2, r2
 80014a0:	611a      	str	r2, [r3, #16]
  if (((sr & STM32_TIM_SR_CC1IF) != 0) &&
 80014a2:	07ab      	lsls	r3, r5, #30
 80014a4:	d504      	bpl.n	80014b0 <VectorB4+0x20>
      (pwmp->config->channels[0].callback != NULL))
 80014a6:	6863      	ldr	r3, [r4, #4]
 80014a8:	691b      	ldr	r3, [r3, #16]
  uint32_t sr;

  sr  = pwmp->tim->SR;
  sr &= pwmp->tim->DIER & STM32_TIM_DIER_IRQ_MASK;
  pwmp->tim->SR = ~sr;
  if (((sr & STM32_TIM_SR_CC1IF) != 0) &&
 80014aa:	b10b      	cbz	r3, 80014b0 <VectorB4+0x20>
      (pwmp->config->channels[0].callback != NULL))
    pwmp->config->channels[0].callback(pwmp);
 80014ac:	4620      	mov	r0, r4
 80014ae:	4798      	blx	r3
  if (((sr & STM32_TIM_SR_CC2IF) != 0) &&
 80014b0:	0768      	lsls	r0, r5, #29
 80014b2:	d504      	bpl.n	80014be <VectorB4+0x2e>
      (pwmp->config->channels[1].callback != NULL))
 80014b4:	6863      	ldr	r3, [r4, #4]
 80014b6:	699b      	ldr	r3, [r3, #24]
  sr &= pwmp->tim->DIER & STM32_TIM_DIER_IRQ_MASK;
  pwmp->tim->SR = ~sr;
  if (((sr & STM32_TIM_SR_CC1IF) != 0) &&
      (pwmp->config->channels[0].callback != NULL))
    pwmp->config->channels[0].callback(pwmp);
  if (((sr & STM32_TIM_SR_CC2IF) != 0) &&
 80014b8:	b10b      	cbz	r3, 80014be <VectorB4+0x2e>
      (pwmp->config->channels[1].callback != NULL))
    pwmp->config->channels[1].callback(pwmp);
 80014ba:	480d      	ldr	r0, [pc, #52]	; (80014f0 <VectorB4+0x60>)
 80014bc:	4798      	blx	r3
  if (((sr & STM32_TIM_SR_CC3IF) != 0) &&
 80014be:	0729      	lsls	r1, r5, #28
 80014c0:	d504      	bpl.n	80014cc <VectorB4+0x3c>
      (pwmp->config->channels[2].callback != NULL))
 80014c2:	6863      	ldr	r3, [r4, #4]
 80014c4:	6a1b      	ldr	r3, [r3, #32]
      (pwmp->config->channels[0].callback != NULL))
    pwmp->config->channels[0].callback(pwmp);
  if (((sr & STM32_TIM_SR_CC2IF) != 0) &&
      (pwmp->config->channels[1].callback != NULL))
    pwmp->config->channels[1].callback(pwmp);
  if (((sr & STM32_TIM_SR_CC3IF) != 0) &&
 80014c6:	b10b      	cbz	r3, 80014cc <VectorB4+0x3c>
      (pwmp->config->channels[2].callback != NULL))
    pwmp->config->channels[2].callback(pwmp);
 80014c8:	4809      	ldr	r0, [pc, #36]	; (80014f0 <VectorB4+0x60>)
 80014ca:	4798      	blx	r3
  if (((sr & STM32_TIM_SR_CC4IF) != 0) &&
 80014cc:	06ea      	lsls	r2, r5, #27
 80014ce:	d504      	bpl.n	80014da <VectorB4+0x4a>
      (pwmp->config->channels[3].callback != NULL))
 80014d0:	6863      	ldr	r3, [r4, #4]
 80014d2:	6a9b      	ldr	r3, [r3, #40]	; 0x28
      (pwmp->config->channels[1].callback != NULL))
    pwmp->config->channels[1].callback(pwmp);
  if (((sr & STM32_TIM_SR_CC3IF) != 0) &&
      (pwmp->config->channels[2].callback != NULL))
    pwmp->config->channels[2].callback(pwmp);
  if (((sr & STM32_TIM_SR_CC4IF) != 0) &&
 80014d4:	b10b      	cbz	r3, 80014da <VectorB4+0x4a>
      (pwmp->config->channels[3].callback != NULL))
    pwmp->config->channels[3].callback(pwmp);
 80014d6:	4806      	ldr	r0, [pc, #24]	; (80014f0 <VectorB4+0x60>)
 80014d8:	4798      	blx	r3
  if (((sr & STM32_TIM_SR_UIF) != 0) && (pwmp->config->callback != NULL))
 80014da:	07eb      	lsls	r3, r5, #31
 80014dc:	d504      	bpl.n	80014e8 <VectorB4+0x58>
 80014de:	6863      	ldr	r3, [r4, #4]
 80014e0:	689b      	ldr	r3, [r3, #8]
 80014e2:	b10b      	cbz	r3, 80014e8 <VectorB4+0x58>
    pwmp->config->callback(pwmp);
 80014e4:	4802      	ldr	r0, [pc, #8]	; (80014f0 <VectorB4+0x60>)
 80014e6:	4798      	blx	r3
  OSAL_IRQ_PROLOGUE();

  pwm_lld_serve_interrupt(&PWMD3);

  OSAL_IRQ_EPILOGUE();
}
 80014e8:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}

  OSAL_IRQ_PROLOGUE();

  pwm_lld_serve_interrupt(&PWMD3);

  OSAL_IRQ_EPILOGUE();
 80014ec:	f7ff b9c0 	b.w	8000870 <_port_irq_epilogue>
 80014f0:	200011f0 	.word	0x200011f0
	...

08001500 <Vector148>:
/**
 * @brief   EXTI[33] interrupt handler (COMP7).
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector148) {
 8001500:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();

  EXTI->PR2 = (1 << 1);
  EXTD1.config->channels[33].cb(&EXTD1, 33);
 8001502:	4806      	ldr	r0, [pc, #24]	; (800151c <Vector148+0x1c>)
 */
OSAL_IRQ_HANDLER(Vector148) {

  OSAL_IRQ_PROLOGUE();

  EXTI->PR2 = (1 << 1);
 8001504:	4b06      	ldr	r3, [pc, #24]	; (8001520 <Vector148+0x20>)
 8001506:	2202      	movs	r2, #2
 8001508:	635a      	str	r2, [r3, #52]	; 0x34
  EXTD1.config->channels[33].cb(&EXTD1, 33);
 800150a:	6843      	ldr	r3, [r0, #4]
 800150c:	2121      	movs	r1, #33	; 0x21
 800150e:	f8d3 310c 	ldr.w	r3, [r3, #268]	; 0x10c
 8001512:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
}
 8001514:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_PROLOGUE();

  EXTI->PR2 = (1 << 1);
  EXTD1.config->channels[33].cb(&EXTD1, 33);

  OSAL_IRQ_EPILOGUE();
 8001518:	f7ff b9aa 	b.w	8000870 <_port_irq_epilogue>
 800151c:	200011e8 	.word	0x200011e8
 8001520:	40010400 	.word	0x40010400
	...

08001530 <Vector144>:
/**
 * @brief   EXTI[30]...EXTI[32] interrupt handler (COMP4, COMP5, COMP6).
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector144) {
 8001530:	b538      	push	{r3, r4, r5, lr}
  uint32_t pr;

  OSAL_IRQ_PROLOGUE();

  pr = EXTI->PR & ((1 << 30) | (1 << 31));
 8001532:	4b13      	ldr	r3, [pc, #76]	; (8001580 <Vector144+0x50>)
 8001534:	695a      	ldr	r2, [r3, #20]
 8001536:	f002 4540 	and.w	r5, r2, #3221225472	; 0xc0000000
  EXTI->PR = pr;
  if (pr & (1 << 30))
 800153a:	f012 4f80 	tst.w	r2, #1073741824	; 0x40000000
  uint32_t pr;

  OSAL_IRQ_PROLOGUE();

  pr = EXTI->PR & ((1 << 30) | (1 << 31));
  EXTI->PR = pr;
 800153e:	615d      	str	r5, [r3, #20]
 8001540:	461c      	mov	r4, r3
  if (pr & (1 << 30))
 8001542:	d005      	beq.n	8001550 <Vector144+0x20>
    EXTD1.config->channels[30].cb(&EXTD1, 30);
 8001544:	480f      	ldr	r0, [pc, #60]	; (8001584 <Vector144+0x54>)
 8001546:	6843      	ldr	r3, [r0, #4]
 8001548:	211e      	movs	r1, #30
 800154a:	f8d3 30f4 	ldr.w	r3, [r3, #244]	; 0xf4
 800154e:	4798      	blx	r3
  if (pr & (1 << 31))
 8001550:	2d00      	cmp	r5, #0
 8001552:	da05      	bge.n	8001560 <Vector144+0x30>
    EXTD1.config->channels[31].cb(&EXTD1, 31);
 8001554:	480b      	ldr	r0, [pc, #44]	; (8001584 <Vector144+0x54>)
 8001556:	6843      	ldr	r3, [r0, #4]
 8001558:	211f      	movs	r1, #31
 800155a:	f8d3 30fc 	ldr.w	r3, [r3, #252]	; 0xfc
 800155e:	4798      	blx	r3

  pr = EXTI->PR2 & (1 << 0);
 8001560:	6b63      	ldr	r3, [r4, #52]	; 0x34
 8001562:	f003 0301 	and.w	r3, r3, #1
  EXTI->PR2 = pr;
 8001566:	6363      	str	r3, [r4, #52]	; 0x34
  if (pr & (1 << 0))
 8001568:	b12b      	cbz	r3, 8001576 <Vector144+0x46>
    EXTD1.config->channels[32].cb(&EXTD1, 32);
 800156a:	4806      	ldr	r0, [pc, #24]	; (8001584 <Vector144+0x54>)
 800156c:	6843      	ldr	r3, [r0, #4]
 800156e:	2120      	movs	r1, #32
 8001570:	f8d3 3104 	ldr.w	r3, [r3, #260]	; 0x104
 8001574:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
}
 8001576:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  pr = EXTI->PR2 & (1 << 0);
  EXTI->PR2 = pr;
  if (pr & (1 << 0))
    EXTD1.config->channels[32].cb(&EXTD1, 32);

  OSAL_IRQ_EPILOGUE();
 800157a:	f7ff b979 	b.w	8000870 <_port_irq_epilogue>
 800157e:	bf00      	nop
 8001580:	40010400 	.word	0x40010400
 8001584:	200011e8 	.word	0x200011e8
	...

08001590 <Vector140>:
OSAL_IRQ_HANDLER(Vector140) {
  uint32_t pr;

  OSAL_IRQ_PROLOGUE();

  pr = EXTI->PR & ((1 << 21) | (1 << 22) | (1 << 29));
 8001590:	4a10      	ldr	r2, [pc, #64]	; (80015d4 <Vector140+0x44>)
 8001592:	4b11      	ldr	r3, [pc, #68]	; (80015d8 <Vector140+0x48>)
/**
 * @brief   EXTI[21],EXTI[22],EXTI[29] interrupt handler (COMP1, COMP2, COMP3).
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector140) {
 8001594:	b510      	push	{r4, lr}
  uint32_t pr;

  OSAL_IRQ_PROLOGUE();

  pr = EXTI->PR & ((1 << 21) | (1 << 22) | (1 << 29));
 8001596:	6954      	ldr	r4, [r2, #20]
 8001598:	4023      	ands	r3, r4
  EXTI->PR = pr;
  if (pr & (1 << 21))
 800159a:	02a1      	lsls	r1, r4, #10
  uint32_t pr;

  OSAL_IRQ_PROLOGUE();

  pr = EXTI->PR & ((1 << 21) | (1 << 22) | (1 << 29));
  EXTI->PR = pr;
 800159c:	6153      	str	r3, [r2, #20]
  if (pr & (1 << 21))
 800159e:	d505      	bpl.n	80015ac <Vector140+0x1c>
    EXTD1.config->channels[21].cb(&EXTD1, 21);
 80015a0:	480e      	ldr	r0, [pc, #56]	; (80015dc <Vector140+0x4c>)
 80015a2:	6843      	ldr	r3, [r0, #4]
 80015a4:	2115      	movs	r1, #21
 80015a6:	f8d3 30ac 	ldr.w	r3, [r3, #172]	; 0xac
 80015aa:	4798      	blx	r3
  if (pr & (1 << 22))
 80015ac:	0262      	lsls	r2, r4, #9
 80015ae:	d505      	bpl.n	80015bc <Vector140+0x2c>
    EXTD1.config->channels[22].cb(&EXTD1, 22);
 80015b0:	480a      	ldr	r0, [pc, #40]	; (80015dc <Vector140+0x4c>)
 80015b2:	6843      	ldr	r3, [r0, #4]
 80015b4:	2116      	movs	r1, #22
 80015b6:	f8d3 30b4 	ldr.w	r3, [r3, #180]	; 0xb4
 80015ba:	4798      	blx	r3
  if (pr & (1 << 29))
 80015bc:	00a3      	lsls	r3, r4, #2
 80015be:	d505      	bpl.n	80015cc <Vector140+0x3c>
    EXTD1.config->channels[29].cb(&EXTD1, 29);
 80015c0:	4806      	ldr	r0, [pc, #24]	; (80015dc <Vector140+0x4c>)
 80015c2:	6843      	ldr	r3, [r0, #4]
 80015c4:	211d      	movs	r1, #29
 80015c6:	f8d3 30ec 	ldr.w	r3, [r3, #236]	; 0xec
 80015ca:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
}
 80015cc:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  if (pr & (1 << 22))
    EXTD1.config->channels[22].cb(&EXTD1, 22);
  if (pr & (1 << 29))
    EXTD1.config->channels[29].cb(&EXTD1, 29);

  OSAL_IRQ_EPILOGUE();
 80015d0:	f7ff b94e 	b.w	8000870 <_port_irq_epilogue>
 80015d4:	40010400 	.word	0x40010400
 80015d8:	20600000 	.word	0x20600000
 80015dc:	200011e8 	.word	0x200011e8

080015e0 <Vector4C>:
/**
 * @brief   EXTI[20] interrupt handler (RTC Wakeup).
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector4C) {
 80015e0:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 20);
  EXTD1.config->channels[20].cb(&EXTD1, 20);
 80015e2:	4807      	ldr	r0, [pc, #28]	; (8001600 <Vector4C+0x20>)
 */
OSAL_IRQ_HANDLER(Vector4C) {

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 20);
 80015e4:	4b07      	ldr	r3, [pc, #28]	; (8001604 <Vector4C+0x24>)
 80015e6:	f44f 1280 	mov.w	r2, #1048576	; 0x100000
 80015ea:	615a      	str	r2, [r3, #20]
  EXTD1.config->channels[20].cb(&EXTD1, 20);
 80015ec:	6843      	ldr	r3, [r0, #4]
 80015ee:	2114      	movs	r1, #20
 80015f0:	f8d3 30a4 	ldr.w	r3, [r3, #164]	; 0xa4
 80015f4:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
}
 80015f6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 20);
  EXTD1.config->channels[20].cb(&EXTD1, 20);

  OSAL_IRQ_EPILOGUE();
 80015fa:	f7ff b939 	b.w	8000870 <_port_irq_epilogue>
 80015fe:	bf00      	nop
 8001600:	200011e8 	.word	0x200011e8
 8001604:	40010400 	.word	0x40010400
	...

08001610 <Vector48>:
/**
 * @brief   EXTI[19] interrupt handler (Tamper TimeStamp).
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector48) {
 8001610:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 19);
  EXTD1.config->channels[19].cb(&EXTD1, 19);
 8001612:	4807      	ldr	r0, [pc, #28]	; (8001630 <Vector48+0x20>)
 */
OSAL_IRQ_HANDLER(Vector48) {

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 19);
 8001614:	4b07      	ldr	r3, [pc, #28]	; (8001634 <Vector48+0x24>)
 8001616:	f44f 2200 	mov.w	r2, #524288	; 0x80000
 800161a:	615a      	str	r2, [r3, #20]
  EXTD1.config->channels[19].cb(&EXTD1, 19);
 800161c:	6843      	ldr	r3, [r0, #4]
 800161e:	2113      	movs	r1, #19
 8001620:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
 8001624:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
}
 8001626:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 19);
  EXTD1.config->channels[19].cb(&EXTD1, 19);

  OSAL_IRQ_EPILOGUE();
 800162a:	f7ff b921 	b.w	8000870 <_port_irq_epilogue>
 800162e:	bf00      	nop
 8001630:	200011e8 	.word	0x200011e8
 8001634:	40010400 	.word	0x40010400
	...

08001640 <VectorE8>:
/**
 * @brief   EXTI[18] interrupt handler (USB Wakeup).
 *
 * @isr
 */
OSAL_IRQ_HANDLER(VectorE8) {
 8001640:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 18);
  EXTD1.config->channels[18].cb(&EXTD1, 18);
 8001642:	4807      	ldr	r0, [pc, #28]	; (8001660 <VectorE8+0x20>)
 */
OSAL_IRQ_HANDLER(VectorE8) {

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 18);
 8001644:	4b07      	ldr	r3, [pc, #28]	; (8001664 <VectorE8+0x24>)
 8001646:	f44f 2280 	mov.w	r2, #262144	; 0x40000
 800164a:	615a      	str	r2, [r3, #20]
  EXTD1.config->channels[18].cb(&EXTD1, 18);
 800164c:	6843      	ldr	r3, [r0, #4]
 800164e:	2112      	movs	r1, #18
 8001650:	f8d3 3094 	ldr.w	r3, [r3, #148]	; 0x94
 8001654:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
}
 8001656:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 18);
  EXTD1.config->channels[18].cb(&EXTD1, 18);

  OSAL_IRQ_EPILOGUE();
 800165a:	f7ff b909 	b.w	8000870 <_port_irq_epilogue>
 800165e:	bf00      	nop
 8001660:	200011e8 	.word	0x200011e8
 8001664:	40010400 	.word	0x40010400
	...

08001670 <VectorE4>:
/**
 * @brief   EXTI[17] interrupt handler (RTC Alarm).
 *
 * @isr
 */
OSAL_IRQ_HANDLER(VectorE4) {
 8001670:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 17);
  EXTD1.config->channels[17].cb(&EXTD1, 17);
 8001672:	4807      	ldr	r0, [pc, #28]	; (8001690 <VectorE4+0x20>)
 */
OSAL_IRQ_HANDLER(VectorE4) {

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 17);
 8001674:	4b07      	ldr	r3, [pc, #28]	; (8001694 <VectorE4+0x24>)
 8001676:	f44f 3200 	mov.w	r2, #131072	; 0x20000
 800167a:	615a      	str	r2, [r3, #20]
  EXTD1.config->channels[17].cb(&EXTD1, 17);
 800167c:	6843      	ldr	r3, [r0, #4]
 800167e:	2111      	movs	r1, #17
 8001680:	f8d3 308c 	ldr.w	r3, [r3, #140]	; 0x8c
 8001684:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
}
 8001686:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 17);
  EXTD1.config->channels[17].cb(&EXTD1, 17);

  OSAL_IRQ_EPILOGUE();
 800168a:	f7ff b8f1 	b.w	8000870 <_port_irq_epilogue>
 800168e:	bf00      	nop
 8001690:	200011e8 	.word	0x200011e8
 8001694:	40010400 	.word	0x40010400
	...

080016a0 <Vector44>:
/**
 * @brief   EXTI[16] interrupt handler (PVD).
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector44) {
 80016a0:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 16);
  EXTD1.config->channels[16].cb(&EXTD1, 16);
 80016a2:	4807      	ldr	r0, [pc, #28]	; (80016c0 <Vector44+0x20>)
 */
OSAL_IRQ_HANDLER(Vector44) {

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 16);
 80016a4:	4b07      	ldr	r3, [pc, #28]	; (80016c4 <Vector44+0x24>)
 80016a6:	f44f 3280 	mov.w	r2, #65536	; 0x10000
 80016aa:	615a      	str	r2, [r3, #20]
  EXTD1.config->channels[16].cb(&EXTD1, 16);
 80016ac:	6843      	ldr	r3, [r0, #4]
 80016ae:	2110      	movs	r1, #16
 80016b0:	f8d3 3084 	ldr.w	r3, [r3, #132]	; 0x84
 80016b4:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
}
 80016b6:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 16);
  EXTD1.config->channels[16].cb(&EXTD1, 16);

  OSAL_IRQ_EPILOGUE();
 80016ba:	f7ff b8d9 	b.w	8000870 <_port_irq_epilogue>
 80016be:	bf00      	nop
 80016c0:	200011e8 	.word	0x200011e8
 80016c4:	40010400 	.word	0x40010400
	...

080016d0 <VectorE0>:
OSAL_IRQ_HANDLER(VectorE0) {
  uint32_t pr;

  OSAL_IRQ_PROLOGUE();

  pr = EXTI->PR & ((1 << 10) | (1 << 11) | (1 << 12) | (1 << 13) | (1 << 14) |
 80016d0:	4b19      	ldr	r3, [pc, #100]	; (8001738 <VectorE0+0x68>)
/**
 * @brief   EXTI[10]...EXTI[15] interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(VectorE0) {
 80016d2:	b510      	push	{r4, lr}
  uint32_t pr;

  OSAL_IRQ_PROLOGUE();

  pr = EXTI->PR & ((1 << 10) | (1 << 11) | (1 << 12) | (1 << 13) | (1 << 14) |
 80016d4:	695c      	ldr	r4, [r3, #20]
 80016d6:	f404 427c 	and.w	r2, r4, #64512	; 0xfc00
                   (1 << 15));
  EXTI->PR = pr;
 80016da:	615a      	str	r2, [r3, #20]
  if (pr & (1 << 10))
 80016dc:	0562      	lsls	r2, r4, #21
 80016de:	d504      	bpl.n	80016ea <VectorE0+0x1a>
    EXTD1.config->channels[10].cb(&EXTD1, 10);
 80016e0:	4816      	ldr	r0, [pc, #88]	; (800173c <VectorE0+0x6c>)
 80016e2:	6843      	ldr	r3, [r0, #4]
 80016e4:	210a      	movs	r1, #10
 80016e6:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 80016e8:	4798      	blx	r3
  if (pr & (1 << 11))
 80016ea:	0523      	lsls	r3, r4, #20
 80016ec:	d504      	bpl.n	80016f8 <VectorE0+0x28>
    EXTD1.config->channels[11].cb(&EXTD1, 11);
 80016ee:	4813      	ldr	r0, [pc, #76]	; (800173c <VectorE0+0x6c>)
 80016f0:	6843      	ldr	r3, [r0, #4]
 80016f2:	210b      	movs	r1, #11
 80016f4:	6ddb      	ldr	r3, [r3, #92]	; 0x5c
 80016f6:	4798      	blx	r3
  if (pr & (1 << 12))
 80016f8:	04e0      	lsls	r0, r4, #19
 80016fa:	d504      	bpl.n	8001706 <VectorE0+0x36>
    EXTD1.config->channels[12].cb(&EXTD1, 12);
 80016fc:	480f      	ldr	r0, [pc, #60]	; (800173c <VectorE0+0x6c>)
 80016fe:	6843      	ldr	r3, [r0, #4]
 8001700:	210c      	movs	r1, #12
 8001702:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 8001704:	4798      	blx	r3
  if (pr & (1 << 13))
 8001706:	04a1      	lsls	r1, r4, #18
 8001708:	d504      	bpl.n	8001714 <VectorE0+0x44>
    EXTD1.config->channels[13].cb(&EXTD1, 13);
 800170a:	480c      	ldr	r0, [pc, #48]	; (800173c <VectorE0+0x6c>)
 800170c:	6843      	ldr	r3, [r0, #4]
 800170e:	210d      	movs	r1, #13
 8001710:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 8001712:	4798      	blx	r3
  if (pr & (1 << 14))
 8001714:	0462      	lsls	r2, r4, #17
 8001716:	d504      	bpl.n	8001722 <VectorE0+0x52>
    EXTD1.config->channels[14].cb(&EXTD1, 14);
 8001718:	4808      	ldr	r0, [pc, #32]	; (800173c <VectorE0+0x6c>)
 800171a:	6843      	ldr	r3, [r0, #4]
 800171c:	210e      	movs	r1, #14
 800171e:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 8001720:	4798      	blx	r3
  if (pr & (1 << 15))
 8001722:	0423      	lsls	r3, r4, #16
 8001724:	d504      	bpl.n	8001730 <VectorE0+0x60>
    EXTD1.config->channels[15].cb(&EXTD1, 15);
 8001726:	4805      	ldr	r0, [pc, #20]	; (800173c <VectorE0+0x6c>)
 8001728:	6843      	ldr	r3, [r0, #4]
 800172a:	210f      	movs	r1, #15
 800172c:	6fdb      	ldr	r3, [r3, #124]	; 0x7c
 800172e:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
}
 8001730:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  if (pr & (1 << 14))
    EXTD1.config->channels[14].cb(&EXTD1, 14);
  if (pr & (1 << 15))
    EXTD1.config->channels[15].cb(&EXTD1, 15);

  OSAL_IRQ_EPILOGUE();
 8001734:	f7ff b89c 	b.w	8000870 <_port_irq_epilogue>
 8001738:	40010400 	.word	0x40010400
 800173c:	200011e8 	.word	0x200011e8

08001740 <Vector9C>:
OSAL_IRQ_HANDLER(Vector9C) {
  uint32_t pr;

  OSAL_IRQ_PROLOGUE();

  pr = EXTI->PR & ((1 << 5) | (1 << 6) | (1 << 7) | (1 << 8) | (1 << 9));
 8001740:	4b16      	ldr	r3, [pc, #88]	; (800179c <Vector9C+0x5c>)
/**
 * @brief   EXTI[5]...EXTI[9] interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector9C) {
 8001742:	b510      	push	{r4, lr}
  uint32_t pr;

  OSAL_IRQ_PROLOGUE();

  pr = EXTI->PR & ((1 << 5) | (1 << 6) | (1 << 7) | (1 << 8) | (1 << 9));
 8001744:	695c      	ldr	r4, [r3, #20]
 8001746:	f404 7278 	and.w	r2, r4, #992	; 0x3e0
  EXTI->PR = pr;
 800174a:	615a      	str	r2, [r3, #20]
  if (pr & (1 << 5))
 800174c:	06a3      	lsls	r3, r4, #26
 800174e:	d504      	bpl.n	800175a <Vector9C+0x1a>
    EXTD1.config->channels[5].cb(&EXTD1, 5);
 8001750:	4813      	ldr	r0, [pc, #76]	; (80017a0 <Vector9C+0x60>)
 8001752:	6843      	ldr	r3, [r0, #4]
 8001754:	2105      	movs	r1, #5
 8001756:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 8001758:	4798      	blx	r3
  if (pr & (1 << 6))
 800175a:	0660      	lsls	r0, r4, #25
 800175c:	d504      	bpl.n	8001768 <Vector9C+0x28>
    EXTD1.config->channels[6].cb(&EXTD1, 6);
 800175e:	4810      	ldr	r0, [pc, #64]	; (80017a0 <Vector9C+0x60>)
 8001760:	6843      	ldr	r3, [r0, #4]
 8001762:	2106      	movs	r1, #6
 8001764:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 8001766:	4798      	blx	r3
  if (pr & (1 << 7))
 8001768:	0621      	lsls	r1, r4, #24
 800176a:	d504      	bpl.n	8001776 <Vector9C+0x36>
    EXTD1.config->channels[7].cb(&EXTD1, 7);
 800176c:	480c      	ldr	r0, [pc, #48]	; (80017a0 <Vector9C+0x60>)
 800176e:	6843      	ldr	r3, [r0, #4]
 8001770:	2107      	movs	r1, #7
 8001772:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 8001774:	4798      	blx	r3
  if (pr & (1 << 8))
 8001776:	05e2      	lsls	r2, r4, #23
 8001778:	d504      	bpl.n	8001784 <Vector9C+0x44>
    EXTD1.config->channels[8].cb(&EXTD1, 8);
 800177a:	4809      	ldr	r0, [pc, #36]	; (80017a0 <Vector9C+0x60>)
 800177c:	6843      	ldr	r3, [r0, #4]
 800177e:	2108      	movs	r1, #8
 8001780:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 8001782:	4798      	blx	r3
  if (pr & (1 << 9))
 8001784:	05a3      	lsls	r3, r4, #22
 8001786:	d504      	bpl.n	8001792 <Vector9C+0x52>
    EXTD1.config->channels[9].cb(&EXTD1, 9);
 8001788:	4805      	ldr	r0, [pc, #20]	; (80017a0 <Vector9C+0x60>)
 800178a:	6843      	ldr	r3, [r0, #4]
 800178c:	2109      	movs	r1, #9
 800178e:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 8001790:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
}
 8001792:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  if (pr & (1 << 8))
    EXTD1.config->channels[8].cb(&EXTD1, 8);
  if (pr & (1 << 9))
    EXTD1.config->channels[9].cb(&EXTD1, 9);

  OSAL_IRQ_EPILOGUE();
 8001796:	f7ff b86b 	b.w	8000870 <_port_irq_epilogue>
 800179a:	bf00      	nop
 800179c:	40010400 	.word	0x40010400
 80017a0:	200011e8 	.word	0x200011e8
	...

080017b0 <Vector68>:
/**
 * @brief   EXTI[4] interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector68) {
 80017b0:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 4);
  EXTD1.config->channels[4].cb(&EXTD1, 4);
 80017b2:	4806      	ldr	r0, [pc, #24]	; (80017cc <Vector68+0x1c>)
 */
OSAL_IRQ_HANDLER(Vector68) {

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 4);
 80017b4:	4b06      	ldr	r3, [pc, #24]	; (80017d0 <Vector68+0x20>)
 80017b6:	2210      	movs	r2, #16
 80017b8:	615a      	str	r2, [r3, #20]
  EXTD1.config->channels[4].cb(&EXTD1, 4);
 80017ba:	6843      	ldr	r3, [r0, #4]
 80017bc:	2104      	movs	r1, #4
 80017be:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80017c0:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
}
 80017c2:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 4);
  EXTD1.config->channels[4].cb(&EXTD1, 4);

  OSAL_IRQ_EPILOGUE();
 80017c6:	f7ff b853 	b.w	8000870 <_port_irq_epilogue>
 80017ca:	bf00      	nop
 80017cc:	200011e8 	.word	0x200011e8
 80017d0:	40010400 	.word	0x40010400
	...

080017e0 <Vector64>:
/**
 * @brief   EXTI[3] interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector64) {
 80017e0:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 3);
  EXTD1.config->channels[3].cb(&EXTD1, 3);
 80017e2:	4806      	ldr	r0, [pc, #24]	; (80017fc <Vector64+0x1c>)
 */
OSAL_IRQ_HANDLER(Vector64) {

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 3);
 80017e4:	4b06      	ldr	r3, [pc, #24]	; (8001800 <Vector64+0x20>)
 80017e6:	2208      	movs	r2, #8
 80017e8:	615a      	str	r2, [r3, #20]
  EXTD1.config->channels[3].cb(&EXTD1, 3);
 80017ea:	6843      	ldr	r3, [r0, #4]
 80017ec:	2103      	movs	r1, #3
 80017ee:	69db      	ldr	r3, [r3, #28]
 80017f0:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
}
 80017f2:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 3);
  EXTD1.config->channels[3].cb(&EXTD1, 3);

  OSAL_IRQ_EPILOGUE();
 80017f6:	f7ff b83b 	b.w	8000870 <_port_irq_epilogue>
 80017fa:	bf00      	nop
 80017fc:	200011e8 	.word	0x200011e8
 8001800:	40010400 	.word	0x40010400
	...

08001810 <Vector60>:
/**
 * @brief   EXTI[2] interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector60) {
 8001810:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 2);
  EXTD1.config->channels[2].cb(&EXTD1, 2);
 8001812:	4806      	ldr	r0, [pc, #24]	; (800182c <Vector60+0x1c>)
 */
OSAL_IRQ_HANDLER(Vector60) {

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 2);
 8001814:	4b06      	ldr	r3, [pc, #24]	; (8001830 <Vector60+0x20>)
 8001816:	2204      	movs	r2, #4
 8001818:	615a      	str	r2, [r3, #20]
  EXTD1.config->channels[2].cb(&EXTD1, 2);
 800181a:	6843      	ldr	r3, [r0, #4]
 800181c:	2102      	movs	r1, #2
 800181e:	695b      	ldr	r3, [r3, #20]
 8001820:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
}
 8001822:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 2);
  EXTD1.config->channels[2].cb(&EXTD1, 2);

  OSAL_IRQ_EPILOGUE();
 8001826:	f7ff b823 	b.w	8000870 <_port_irq_epilogue>
 800182a:	bf00      	nop
 800182c:	200011e8 	.word	0x200011e8
 8001830:	40010400 	.word	0x40010400
	...

08001840 <Vector5C>:
/**
 * @brief   EXTI[1] interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector5C) {
 8001840:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 1);
  EXTD1.config->channels[1].cb(&EXTD1, 1);
 8001842:	4806      	ldr	r0, [pc, #24]	; (800185c <Vector5C+0x1c>)
 */
OSAL_IRQ_HANDLER(Vector5C) {

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 1);
 8001844:	4b06      	ldr	r3, [pc, #24]	; (8001860 <Vector5C+0x20>)
 8001846:	2202      	movs	r2, #2
 8001848:	615a      	str	r2, [r3, #20]
  EXTD1.config->channels[1].cb(&EXTD1, 1);
 800184a:	6843      	ldr	r3, [r0, #4]
 800184c:	2101      	movs	r1, #1
 800184e:	68db      	ldr	r3, [r3, #12]
 8001850:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
}
 8001852:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 1);
  EXTD1.config->channels[1].cb(&EXTD1, 1);

  OSAL_IRQ_EPILOGUE();
 8001856:	f7ff b80b 	b.w	8000870 <_port_irq_epilogue>
 800185a:	bf00      	nop
 800185c:	200011e8 	.word	0x200011e8
 8001860:	40010400 	.word	0x40010400
	...

08001870 <Vector58>:
/**
 * @brief   EXTI[0] interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector58) {
 8001870:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 0);
  EXTD1.config->channels[0].cb(&EXTD1, 0);
 8001872:	4806      	ldr	r0, [pc, #24]	; (800188c <Vector58+0x1c>)
 */
OSAL_IRQ_HANDLER(Vector58) {

  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 0);
 8001874:	4b06      	ldr	r3, [pc, #24]	; (8001890 <Vector58+0x20>)
 8001876:	2201      	movs	r2, #1
 8001878:	615a      	str	r2, [r3, #20]
  EXTD1.config->channels[0].cb(&EXTD1, 0);
 800187a:	6843      	ldr	r3, [r0, #4]
 800187c:	2100      	movs	r1, #0
 800187e:	685b      	ldr	r3, [r3, #4]
 8001880:	4798      	blx	r3

  OSAL_IRQ_EPILOGUE();
}
 8001882:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  OSAL_IRQ_PROLOGUE();

  EXTI->PR = (1 << 0);
  EXTD1.config->channels[0].cb(&EXTD1, 0);

  OSAL_IRQ_EPILOGUE();
 8001886:	f7fe bff3 	b.w	8000870 <_port_irq_epilogue>
 800188a:	bf00      	nop
 800188c:	200011e8 	.word	0x200011e8
 8001890:	40010400 	.word	0x40010400
	...

080018a0 <serve_interrupt>:
/**
 * @brief   Common IRQ handler.
 *
 * @param[in] sdp       communication channel associated to the USART
 */
static void serve_interrupt(SerialDriver *sdp) {
 80018a0:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
  USART_TypeDef *u = sdp->usart;
 80018a4:	6f46      	ldr	r6, [r0, #116]	; 0x74
  uint32_t cr1 = u->CR1;
 80018a6:	6837      	ldr	r7, [r6, #0]
  uint32_t isr;

  /* Reading and clearing status.*/
  isr = u->ISR;
 80018a8:	69f5      	ldr	r5, [r6, #28]
  u->ICR = isr;
 80018aa:	6235      	str	r5, [r6, #32]

  /* Error condition detection.*/
  if (isr & (USART_ISR_ORE | USART_ISR_NE | USART_ISR_FE  | USART_ISR_PE))
 80018ac:	072a      	lsls	r2, r5, #28
/**
 * @brief   Common IRQ handler.
 *
 * @param[in] sdp       communication channel associated to the USART
 */
static void serve_interrupt(SerialDriver *sdp) {
 80018ae:	4604      	mov	r4, r0
  /* Reading and clearing status.*/
  isr = u->ISR;
  u->ICR = isr;

  /* Error condition detection.*/
  if (isr & (USART_ISR_ORE | USART_ISR_NE | USART_ISR_FE  | USART_ISR_PE))
 80018b0:	d019      	beq.n	80018e6 <serve_interrupt+0x46>
 */
static void set_error(SerialDriver *sdp, uint32_t isr) {
  eventflags_t sts = 0;

  if (isr & USART_ISR_ORE)
    sts |= SD_OVERRUN_ERROR;
 80018b2:	f015 0f08 	tst.w	r5, #8
 80018b6:	bf0c      	ite	eq
 80018b8:	2100      	moveq	r1, #0
 80018ba:	2180      	movne	r1, #128	; 0x80
  if (isr & USART_ISR_PE)
 80018bc:	07eb      	lsls	r3, r5, #31
    sts |= SD_PARITY_ERROR;
 80018be:	bf48      	it	mi
 80018c0:	f041 0120 	orrmi.w	r1, r1, #32
  if (isr & USART_ISR_FE)
 80018c4:	07a8      	lsls	r0, r5, #30
    sts |= SD_FRAMING_ERROR;
 80018c6:	bf48      	it	mi
 80018c8:	f041 0140 	orrmi.w	r1, r1, #64	; 0x40
  if (isr & USART_ISR_NE)
 80018cc:	076a      	lsls	r2, r5, #29
    sts |= SD_NOISE_ERROR;
 80018ce:	bf48      	it	mi
 80018d0:	f441 7180 	orrmi.w	r1, r1, #256	; 0x100
 80018d4:	2320      	movs	r3, #32
 80018d6:	f383 8811 	msr	BASEPRI, r3
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {

  chEvtBroadcastFlagsI(esp, flags);
 80018da:	1d20      	adds	r0, r4, #4
 80018dc:	f7ff fb20 	bl	8000f20 <chEvtBroadcastFlagsI>
 80018e0:	2300      	movs	r3, #0
 80018e2:	f383 8811 	msr	BASEPRI, r3
  /* Error condition detection.*/
  if (isr & (USART_ISR_ORE | USART_ISR_NE | USART_ISR_FE  | USART_ISR_PE))
    set_error(sdp, isr);

  /* Special case, LIN break detection.*/
  if (isr & USART_ISR_LBDF) {
 80018e6:	05eb      	lsls	r3, r5, #23
 80018e8:	d50a      	bpl.n	8001900 <serve_interrupt+0x60>
 80018ea:	2320      	movs	r3, #32
 80018ec:	f383 8811 	msr	BASEPRI, r3
 80018f0:	f44f 7100 	mov.w	r1, #512	; 0x200
 80018f4:	1d20      	adds	r0, r4, #4
 80018f6:	f7ff fb13 	bl	8000f20 <chEvtBroadcastFlagsI>
 80018fa:	2300      	movs	r3, #0
 80018fc:	f383 8811 	msr	BASEPRI, r3
    chnAddFlagsI(sdp, SD_BREAK_DETECTED);
    osalSysUnlockFromISR();
  }

  /* Data available.*/
  if (isr & USART_ISR_RXNE) {
 8001900:	06a8      	lsls	r0, r5, #26
 8001902:	d52f      	bpl.n	8001964 <serve_interrupt+0xc4>
 8001904:	2320      	movs	r3, #32
 8001906:	f383 8811 	msr	BASEPRI, r3
    osalSysLockFromISR();
    sdIncomingDataI(sdp, (uint8_t)u->RDR);
 800190a:	f8b6 8024 	ldrh.w	r8, [r6, #36]	; 0x24
 800190e:	6963      	ldr	r3, [r4, #20]
 8001910:	fa5f f888 	uxtb.w	r8, r8
void sdIncomingDataI(SerialDriver *sdp, uint8_t b) {

  osalDbgCheckClassI();
  osalDbgCheck(sdp != NULL);

  if (iqIsEmptyI(&sdp->iqueue))
 8001914:	b91b      	cbnz	r3, 800191e <serve_interrupt+0x7e>
 8001916:	1d20      	adds	r0, r4, #4
 8001918:	2104      	movs	r1, #4
 800191a:	f7ff fb01 	bl	8000f20 <chEvtBroadcastFlagsI>
 */
static inline bool chIQIsFullI(input_queue_t *iqp) {

  chDbgCheckClassI();

  return (bool)((iqp->q_wrptr == iqp->q_rdptr) && (iqp->q_counter != 0U));
 800191e:	6a23      	ldr	r3, [r4, #32]
 8001920:	6a62      	ldr	r2, [r4, #36]	; 0x24
 8001922:	4293      	cmp	r3, r2
 8001924:	d102      	bne.n	800192c <serve_interrupt+0x8c>
 8001926:	6962      	ldr	r2, [r4, #20]
 8001928:	2a00      	cmp	r2, #0
 800192a:	d15b      	bne.n	80019e4 <serve_interrupt+0x144>

  if (chIQIsFullI(iqp)) {
    return Q_FULL;
  }

  iqp->q_counter++;
 800192c:	6962      	ldr	r2, [r4, #20]
 800192e:	3201      	adds	r2, #1
 8001930:	6162      	str	r2, [r4, #20]
  *iqp->q_wrptr++ = b;
 8001932:	1c5a      	adds	r2, r3, #1
 8001934:	6222      	str	r2, [r4, #32]
 8001936:	f883 8000 	strb.w	r8, [r3]
  if (iqp->q_wrptr >= iqp->q_top) {
 800193a:	6a22      	ldr	r2, [r4, #32]
 800193c:	69e3      	ldr	r3, [r4, #28]
 800193e:	429a      	cmp	r2, r3
 8001940:	d301      	bcc.n	8001946 <serve_interrupt+0xa6>
    iqp->q_wrptr = iqp->q_buffer;
 8001942:	69a3      	ldr	r3, [r4, #24]
 8001944:	6223      	str	r3, [r4, #32]
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->p_next != (const thread_t *)tqp);
 8001946:	68e0      	ldr	r0, [r4, #12]
  }

  chThdDequeueNextI(&iqp->q_waiting, Q_OK);
 8001948:	f104 020c 	add.w	r2, r4, #12
 *
 * @iclass
 */
void chThdDequeueNextI(threads_queue_t *tqp, msg_t msg) {

  if (queue_notempty(tqp)) {
 800194c:	4290      	cmp	r0, r2
 800194e:	d006      	beq.n	800195e <serve_interrupt+0xbe>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  tqp->p_next = tp->p_next;
 8001950:	6803      	ldr	r3, [r0, #0]
 8001952:	60e3      	str	r3, [r4, #12]
  tqp->p_next->p_prev = (thread_t *)tqp;
 8001954:	605a      	str	r2, [r3, #4]

  tp = queue_fifo_remove(tqp);

  chDbgAssert(tp->p_state == CH_STATE_QUEUED, "invalid state");

  tp->p_u.rdymsg = msg;
 8001956:	2300      	movs	r3, #0
 8001958:	6203      	str	r3, [r0, #32]
  (void) chSchReadyI(tp);
 800195a:	f7ff fad1 	bl	8000f00 <chSchReadyI>
 800195e:	2300      	movs	r3, #0
 8001960:	f383 8811 	msr	BASEPRI, r3
    osalSysUnlockFromISR();
  }

  /* Transmission buffer empty.*/
  if ((cr1 & USART_CR1_TXEIE) && (isr & USART_ISR_TXE)) {
 8001964:	0639      	lsls	r1, r7, #24
 8001966:	d52a      	bpl.n	80019be <serve_interrupt+0x11e>
 8001968:	062a      	lsls	r2, r5, #24
 800196a:	d528      	bpl.n	80019be <serve_interrupt+0x11e>
 800196c:	2320      	movs	r3, #32
 800196e:	f383 8811 	msr	BASEPRI, r3
 */
static inline bool chOQIsEmptyI(output_queue_t *oqp) {

  chDbgCheckClassI();

  return (bool)((oqp->q_wrptr == oqp->q_rdptr) && (oqp->q_counter != 0U));
 8001972:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 8001974:	6c62      	ldr	r2, [r4, #68]	; 0x44
 8001976:	429a      	cmp	r2, r3
 8001978:	d102      	bne.n	8001980 <serve_interrupt+0xe0>
 800197a:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 800197c:	2a00      	cmp	r2, #0
 800197e:	d136      	bne.n	80019ee <serve_interrupt+0x14e>

  if (chOQIsEmptyI(oqp)) {
    return Q_EMPTY;
  }

  oqp->q_counter++;
 8001980:	6ba2      	ldr	r2, [r4, #56]	; 0x38
 8001982:	3201      	adds	r2, #1
 8001984:	63a2      	str	r2, [r4, #56]	; 0x38
  b = *oqp->q_rdptr++;
 8001986:	1c5a      	adds	r2, r3, #1
 8001988:	64a2      	str	r2, [r4, #72]	; 0x48
 800198a:	f893 8000 	ldrb.w	r8, [r3]
  if (oqp->q_rdptr >= oqp->q_top) {
 800198e:	6c23      	ldr	r3, [r4, #64]	; 0x40
 8001990:	429a      	cmp	r2, r3
 8001992:	d301      	bcc.n	8001998 <serve_interrupt+0xf8>
    oqp->q_rdptr = oqp->q_buffer;
 8001994:	6be3      	ldr	r3, [r4, #60]	; 0x3c
 8001996:	64a3      	str	r3, [r4, #72]	; 0x48
 *
 * @notapi
 */
static inline bool queue_notempty(const threads_queue_t *tqp) {

  return (bool)(tqp->p_next != (const thread_t *)tqp);
 8001998:	6b20      	ldr	r0, [r4, #48]	; 0x30
  }

  chThdDequeueNextI(&oqp->q_waiting, Q_OK);
 800199a:	f104 0230 	add.w	r2, r4, #48	; 0x30
 800199e:	4290      	cmp	r0, r2
 80019a0:	d006      	beq.n	80019b0 <serve_interrupt+0x110>
}

static inline thread_t *queue_fifo_remove(threads_queue_t *tqp) {
  thread_t *tp = tqp->p_next;

  tqp->p_next = tp->p_next;
 80019a2:	6803      	ldr	r3, [r0, #0]
 80019a4:	6323      	str	r3, [r4, #48]	; 0x30
  tqp->p_next->p_prev = (thread_t *)tqp;
 80019a6:	605a      	str	r2, [r3, #4]

  tp = queue_fifo_remove(tqp);

  chDbgAssert(tp->p_state == CH_STATE_QUEUED, "invalid state");

  tp->p_u.rdymsg = msg;
 80019a8:	2300      	movs	r3, #0
 80019aa:	6203      	str	r3, [r0, #32]
  (void) chSchReadyI(tp);
 80019ac:	f7ff faa8 	bl	8000f00 <chSchReadyI>
    if (b < Q_OK) {
      chnAddFlagsI(sdp, CHN_OUTPUT_EMPTY);
      u->CR1 = (cr1 & ~USART_CR1_TXEIE) | USART_CR1_TCIE;
    }
    else
      u->TDR = b;
 80019b0:	fa1f f888 	uxth.w	r8, r8
 80019b4:	f8a6 8028 	strh.w	r8, [r6, #40]	; 0x28
 80019b8:	2300      	movs	r3, #0
 80019ba:	f383 8811 	msr	BASEPRI, r3
    osalSysUnlockFromISR();
  }

  /* Physical transmission end.*/
  if (isr & USART_ISR_TC) {
 80019be:	066b      	lsls	r3, r5, #25
 80019c0:	d524      	bpl.n	8001a0c <serve_interrupt+0x16c>
 80019c2:	2320      	movs	r3, #32
 80019c4:	f383 8811 	msr	BASEPRI, r3
 80019c8:	6c62      	ldr	r2, [r4, #68]	; 0x44
 80019ca:	6ca3      	ldr	r3, [r4, #72]	; 0x48
 80019cc:	429a      	cmp	r2, r3
 80019ce:	d101      	bne.n	80019d4 <serve_interrupt+0x134>
 80019d0:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 80019d2:	b9b3      	cbnz	r3, 8001a02 <serve_interrupt+0x162>
    osalSysLockFromISR();
    if (oqIsEmptyI(&sdp->oqueue))
      chnAddFlagsI(sdp, CHN_TRANSMISSION_END);
    u->CR1 = cr1 & ~USART_CR1_TCIE;
 80019d4:	f027 0740 	bic.w	r7, r7, #64	; 0x40
 80019d8:	6037      	str	r7, [r6, #0]
 80019da:	2300      	movs	r3, #0
 80019dc:	f383 8811 	msr	BASEPRI, r3
 80019e0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80019e4:	1d20      	adds	r0, r4, #4
 80019e6:	2180      	movs	r1, #128	; 0x80
 80019e8:	f7ff fa9a 	bl	8000f20 <chEvtBroadcastFlagsI>
 80019ec:	e7b7      	b.n	800195e <serve_interrupt+0xbe>
 80019ee:	1d20      	adds	r0, r4, #4
 80019f0:	2108      	movs	r1, #8
 80019f2:	f7ff fa95 	bl	8000f20 <chEvtBroadcastFlagsI>
    msg_t b;
    osalSysLockFromISR();
    b = oqGetI(&sdp->oqueue);
    if (b < Q_OK) {
      chnAddFlagsI(sdp, CHN_OUTPUT_EMPTY);
      u->CR1 = (cr1 & ~USART_CR1_TXEIE) | USART_CR1_TCIE;
 80019f6:	f027 03c0 	bic.w	r3, r7, #192	; 0xc0
 80019fa:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 80019fe:	6033      	str	r3, [r6, #0]
 8001a00:	e7da      	b.n	80019b8 <serve_interrupt+0x118>
 8001a02:	1d20      	adds	r0, r4, #4
 8001a04:	2110      	movs	r1, #16
 8001a06:	f7ff fa8b 	bl	8000f20 <chEvtBroadcastFlagsI>
 8001a0a:	e7e3      	b.n	80019d4 <serve_interrupt+0x134>
 8001a0c:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

08001a10 <VectorD8>:
/**
 * @brief   USART2 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_USART2_HANDLER) {
 8001a10:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();

  serve_interrupt(&SD2);
 8001a12:	4803      	ldr	r0, [pc, #12]	; (8001a20 <VectorD8+0x10>)
 8001a14:	f7ff ff44 	bl	80018a0 <serve_interrupt>

  OSAL_IRQ_EPILOGUE();
}
 8001a18:	e8bd 4008 	ldmia.w	sp!, {r3, lr}

  OSAL_IRQ_PROLOGUE();

  serve_interrupt(&SD2);

  OSAL_IRQ_EPILOGUE();
 8001a1c:	f7fe bf28 	b.w	8000870 <_port_irq_epilogue>
 8001a20:	20000f04 	.word	0x20000f04
	...

08001a30 <VectorD4>:
/**
 * @brief   USART1 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(STM32_USART1_HANDLER) {
 8001a30:	b508      	push	{r3, lr}

  OSAL_IRQ_PROLOGUE();

  serve_interrupt(&SD1);
 8001a32:	4803      	ldr	r0, [pc, #12]	; (8001a40 <VectorD4+0x10>)
 8001a34:	f7ff ff34 	bl	80018a0 <serve_interrupt>

  OSAL_IRQ_EPILOGUE();
}
 8001a38:	e8bd 4008 	ldmia.w	sp!, {r3, lr}

  OSAL_IRQ_PROLOGUE();

  serve_interrupt(&SD1);

  OSAL_IRQ_EPILOGUE();
 8001a3c:	f7fe bf18 	b.w	8000870 <_port_irq_epilogue>
 8001a40:	20000e88 	.word	0x20000e88
	...

08001a50 <VectorC0>:
  i2c_lld_serve_interrupt(&I2CD1, isr);

  OSAL_IRQ_EPILOGUE();
}

OSAL_IRQ_HANDLER(STM32_I2C1_ERROR_HANDLER) {
 8001a50:	b538      	push	{r3, r4, r5, lr}
  uint32_t isr = I2CD1.i2c->ISR;
 8001a52:	4b22      	ldr	r3, [pc, #136]	; (8001adc <VectorC0+0x8c>)
 8001a54:	6b19      	ldr	r1, [r3, #48]	; 0x30
 8001a56:	698a      	ldr	r2, [r1, #24]

  OSAL_IRQ_PROLOGUE();

  /* Clearing IRQ bits.*/
  I2CD1.i2c->ICR = isr & I2C_ERROR_MASK;
 8001a58:	f402 507c 	and.w	r0, r2, #16128	; 0x3f00
 8001a5c:	61c8      	str	r0, [r1, #28]
 */
static void i2c_lld_serve_error_interrupt(I2CDriver *i2cp, uint32_t isr) {

#if STM32_I2C_USE_DMA == TRUE
  /* Clears DMA interrupt flags just to be safe.*/
  dmaStreamDisable(i2cp->dmatx);
 8001a5e:	6ad9      	ldr	r1, [r3, #44]	; 0x2c
 8001a60:	680c      	ldr	r4, [r1, #0]
 8001a62:	6820      	ldr	r0, [r4, #0]
 8001a64:	f020 000f 	bic.w	r0, r0, #15
 8001a68:	6020      	str	r0, [r4, #0]
 8001a6a:	7a0c      	ldrb	r4, [r1, #8]
 8001a6c:	6848      	ldr	r0, [r1, #4]
 8001a6e:	210f      	movs	r1, #15
 8001a70:	fa01 f404 	lsl.w	r4, r1, r4
 8001a74:	6004      	str	r4, [r0, #0]
  dmaStreamDisable(i2cp->dmarx);
 8001a76:	6a98      	ldr	r0, [r3, #40]	; 0x28
 8001a78:	6805      	ldr	r5, [r0, #0]
 8001a7a:	682c      	ldr	r4, [r5, #0]
 8001a7c:	f024 040f 	bic.w	r4, r4, #15
 8001a80:	602c      	str	r4, [r5, #0]
 8001a82:	6844      	ldr	r4, [r0, #4]
 8001a84:	7a00      	ldrb	r0, [r0, #8]
 8001a86:	4081      	lsls	r1, r0
 8001a88:	6021      	str	r1, [r4, #0]
#else
  /* Disabling RX and TX interrupts.*/
  i2cp->i2c->CR1 &= ~(I2C_CR1_TXIE | I2C_CR1_RXIE);
#endif

  if (isr & I2C_ISR_BERR)
 8001a8a:	05d4      	lsls	r4, r2, #23
    i2cp->errors |= I2C_BUS_ERROR;
 8001a8c:	bf42      	ittt	mi
 8001a8e:	6899      	ldrmi	r1, [r3, #8]
 8001a90:	f041 0101 	orrmi.w	r1, r1, #1
 8001a94:	6099      	strmi	r1, [r3, #8]

  if (isr & I2C_ISR_ARLO)
 8001a96:	0590      	lsls	r0, r2, #22
    i2cp->errors |= I2C_ARBITRATION_LOST;
 8001a98:	bf42      	ittt	mi
 8001a9a:	6899      	ldrmi	r1, [r3, #8]
 8001a9c:	f041 0102 	orrmi.w	r1, r1, #2
 8001aa0:	6099      	strmi	r1, [r3, #8]

  if (isr & I2C_ISR_OVR)
 8001aa2:	0551      	lsls	r1, r2, #21
    i2cp->errors |= I2C_OVERRUN;
 8001aa4:	bf42      	ittt	mi
 8001aa6:	6899      	ldrmi	r1, [r3, #8]
 8001aa8:	f041 0108 	orrmi.w	r1, r1, #8
 8001aac:	6099      	strmi	r1, [r3, #8]

  if (isr & I2C_ISR_TIMEOUT)
 8001aae:	04d2      	lsls	r2, r2, #19
    i2cp->errors |= I2C_TIMEOUT;
 8001ab0:	bf42      	ittt	mi
 8001ab2:	689a      	ldrmi	r2, [r3, #8]
 8001ab4:	f042 0220 	orrmi.w	r2, r2, #32
 8001ab8:	609a      	strmi	r2, [r3, #8]

  /* If some error has been identified then sends wakes the waiting thread.*/
  if (i2cp->errors != I2C_NO_ERROR)
 8001aba:	689b      	ldr	r3, [r3, #8]
 8001abc:	b153      	cbz	r3, 8001ad4 <VectorC0+0x84>
 8001abe:	2320      	movs	r3, #32
 8001ac0:	f383 8811 	msr	BASEPRI, r3
 *
 * @iclass
 */
static inline void osalThreadResumeI(thread_reference_t *trp, msg_t msg) {

  chThdResumeI(trp, msg);
 8001ac4:	4806      	ldr	r0, [pc, #24]	; (8001ae0 <VectorC0+0x90>)
 8001ac6:	f06f 0101 	mvn.w	r1, #1
 8001aca:	f7ff fb41 	bl	8001150 <chThdResumeI>
 8001ace:	2300      	movs	r3, #0
 8001ad0:	f383 8811 	msr	BASEPRI, r3
  I2CD1.i2c->ICR = isr & I2C_ERROR_MASK;

  i2c_lld_serve_error_interrupt(&I2CD1, isr);

  OSAL_IRQ_EPILOGUE();
}
 8001ad4:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  /* Clearing IRQ bits.*/
  I2CD1.i2c->ICR = isr & I2C_ERROR_MASK;

  i2c_lld_serve_error_interrupt(&I2CD1, isr);

  OSAL_IRQ_EPILOGUE();
 8001ad8:	f7fe beca 	b.w	8000870 <_port_irq_epilogue>
 8001adc:	20001bd8 	.word	0x20001bd8
 8001ae0:	20001bf4 	.word	0x20001bf4
	...

08001af0 <VectorBC>:

  OSAL_IRQ_EPILOGUE();
}

#elif defined(STM32_I2C1_EVENT_HANDLER) && defined(STM32_I2C1_ERROR_HANDLER)
OSAL_IRQ_HANDLER(STM32_I2C1_EVENT_HANDLER) {
 8001af0:	b538      	push	{r3, r4, r5, lr}
  uint32_t isr = I2CD1.i2c->ISR;
 8001af2:	4c40      	ldr	r4, [pc, #256]	; (8001bf4 <VectorBC+0x104>)
 8001af4:	6b25      	ldr	r5, [r4, #48]	; 0x30
 8001af6:	69ab      	ldr	r3, [r5, #24]

  OSAL_IRQ_PROLOGUE();

  /* Clearing IRQ bits.*/
  I2CD1.i2c->ICR = isr & I2C_INT_MASK;
 8001af8:	f003 02fe 	and.w	r2, r3, #254	; 0xfe
 */
static void i2c_lld_serve_interrupt(I2CDriver *i2cp, uint32_t isr) {
  I2C_TypeDef *dp = i2cp->i2c;

  /* Special case of a received NACK, the transfer is aborted.*/
  if ((isr & I2C_ISR_NACKF) != 0U) {
 8001afc:	06d9      	lsls	r1, r3, #27
  uint32_t isr = I2CD1.i2c->ISR;

  OSAL_IRQ_PROLOGUE();

  /* Clearing IRQ bits.*/
  I2CD1.i2c->ICR = isr & I2C_INT_MASK;
 8001afe:	61ea      	str	r2, [r5, #28]
 */
static void i2c_lld_serve_interrupt(I2CDriver *i2cp, uint32_t isr) {
  I2C_TypeDef *dp = i2cp->i2c;

  /* Special case of a received NACK, the transfer is aborted.*/
  if ((isr & I2C_ISR_NACKF) != 0U) {
 8001b00:	d529      	bpl.n	8001b56 <VectorBC+0x66>
#if STM32_I2C_USE_DMA == TRUE
    /* Stops the associated DMA streams.*/
    dmaStreamDisable(i2cp->dmatx);
 8001b02:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8001b04:	6819      	ldr	r1, [r3, #0]
 8001b06:	680a      	ldr	r2, [r1, #0]
 8001b08:	f022 020f 	bic.w	r2, r2, #15
 8001b0c:	600a      	str	r2, [r1, #0]
 8001b0e:	7a19      	ldrb	r1, [r3, #8]
 8001b10:	685a      	ldr	r2, [r3, #4]
 8001b12:	230f      	movs	r3, #15
 8001b14:	fa03 f101 	lsl.w	r1, r3, r1
 8001b18:	6011      	str	r1, [r2, #0]
    dmaStreamDisable(i2cp->dmarx);
 8001b1a:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 8001b1c:	6810      	ldr	r0, [r2, #0]
 8001b1e:	6801      	ldr	r1, [r0, #0]
 8001b20:	f021 010f 	bic.w	r1, r1, #15
 8001b24:	6001      	str	r1, [r0, #0]
 8001b26:	6851      	ldr	r1, [r2, #4]
 8001b28:	7a12      	ldrb	r2, [r2, #8]
 8001b2a:	4093      	lsls	r3, r2
 8001b2c:	600b      	str	r3, [r1, #0]
#endif

    /* Error flag.*/
    i2cp->errors |= I2C_ACK_FAILURE;
 8001b2e:	68a3      	ldr	r3, [r4, #8]
 8001b30:	f043 0304 	orr.w	r3, r3, #4
 8001b34:	60a3      	str	r3, [r4, #8]

    /* Transaction finished sending the STOP.*/
    dp->CR2 |= I2C_CR2_STOP;
 8001b36:	686b      	ldr	r3, [r5, #4]
 8001b38:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8001b3c:	606b      	str	r3, [r5, #4]

    /* Make sure no more interrupts.*/
    dp->CR1 &= ~(I2C_CR1_TCIE | I2C_CR1_TXIE | I2C_CR1_RXIE);
 8001b3e:	682b      	ldr	r3, [r5, #0]
 8001b40:	f023 0346 	bic.w	r3, r3, #70	; 0x46
 8001b44:	602b      	str	r3, [r5, #0]
 8001b46:	2320      	movs	r3, #32
 8001b48:	f383 8811 	msr	BASEPRI, r3
 8001b4c:	f06f 0101 	mvn.w	r1, #1
 8001b50:	f104 001c 	add.w	r0, r4, #28
 8001b54:	e045      	b.n	8001be2 <VectorBC+0xf2>
    }
  }
#endif

  /* Partial transfer handling, restarting the transfer and returning.*/
  if ((isr & I2C_ISR_TCR) != 0U) {
 8001b56:	061a      	lsls	r2, r3, #24
 8001b58:	d508      	bpl.n	8001b6c <VectorBC+0x7c>
    if (i2cp->state == I2C_ACTIVE_TX) {
 8001b5a:	7823      	ldrb	r3, [r4, #0]
 8001b5c:	2b03      	cmp	r3, #3
 8001b5e:	d102      	bne.n	8001b66 <VectorBC+0x76>
      i2c_lld_setup_tx_transfer(i2cp);
 8001b60:	f001 fdb6 	bl	80036d0 <i2c_lld_setup_tx_transfer.constprop.20>
 8001b64:	e042      	b.n	8001bec <VectorBC+0xfc>
    }
    else {
      i2c_lld_setup_rx_transfer(i2cp);
 8001b66:	f001 fe33 	bl	80037d0 <i2c_lld_setup_rx_transfer.constprop.16>
 8001b6a:	e03f      	b.n	8001bec <VectorBC+0xfc>
    }
    return;
  }

  /* The following condition is true if a transfer phase has been completed.*/
  if ((isr & I2C_ISR_TC) != 0U) {
 8001b6c:	065b      	lsls	r3, r3, #25
 8001b6e:	d53d      	bpl.n	8001bec <VectorBC+0xfc>
    if (i2cp->state == I2C_ACTIVE_TX) {
 8001b70:	7823      	ldrb	r3, [r4, #0]
 8001b72:	2b03      	cmp	r3, #3
 8001b74:	d11d      	bne.n	8001bb2 <VectorBC+0xc2>
      /* End of the transmit phase.*/

#if STM32_I2C_USE_DMA == TRUE
      /* Disabling TX DMA channel.*/
      dmaStreamDisable(i2cp->dmatx);
 8001b76:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 8001b78:	6819      	ldr	r1, [r3, #0]
 8001b7a:	680a      	ldr	r2, [r1, #0]
 8001b7c:	f022 020f 	bic.w	r2, r2, #15
 8001b80:	600a      	str	r2, [r1, #0]
 8001b82:	7a19      	ldrb	r1, [r3, #8]
 8001b84:	685a      	ldr	r2, [r3, #4]
 8001b86:	230f      	movs	r3, #15
 8001b88:	408b      	lsls	r3, r1
 8001b8a:	6013      	str	r3, [r2, #0]
#endif

      /* Starting receive phase if necessary.*/
      if (i2c_lld_get_rxbytes(i2cp) > 0U) {
 8001b8c:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8001b8e:	681b      	ldr	r3, [r3, #0]
 8001b90:	685b      	ldr	r3, [r3, #4]
 8001b92:	b1cb      	cbz	r3, 8001bc8 <VectorBC+0xd8>
        /* Setting up the peripheral.*/
        i2c_lld_setup_rx_transfer(i2cp);
 8001b94:	f001 fe1c 	bl	80037d0 <i2c_lld_setup_rx_transfer.constprop.16>

#if STM32_I2C_USE_DMA == TRUE
        /* Enabling RX DMA.*/
        dmaStreamEnable(i2cp->dmarx);
 8001b98:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8001b9a:	681a      	ldr	r2, [r3, #0]
 8001b9c:	6813      	ldr	r3, [r2, #0]
 8001b9e:	f043 0301 	orr.w	r3, r3, #1
 8001ba2:	6013      	str	r3, [r2, #0]
        /* RX interrupt enabled.*/
        dp->CR1 |= I2C_CR1_RXIE;
#endif

        /* Starts the read operation.*/
        dp->CR2 |= I2C_CR2_START;
 8001ba4:	686b      	ldr	r3, [r5, #4]
 8001ba6:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 8001baa:	606b      	str	r3, [r5, #4]

        /* State change.*/
        i2cp->state = I2C_ACTIVE_RX;
 8001bac:	2304      	movs	r3, #4
 8001bae:	7023      	strb	r3, [r4, #0]
 8001bb0:	e01c      	b.n	8001bec <VectorBC+0xfc>
    }
    else {
      /* End of the receive phase.*/
#if STM32_I2C_USE_DMA == TRUE
      /* Disabling RX DMA channel.*/
      dmaStreamDisable(i2cp->dmarx);
 8001bb2:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8001bb4:	6819      	ldr	r1, [r3, #0]
 8001bb6:	680a      	ldr	r2, [r1, #0]
 8001bb8:	f022 020f 	bic.w	r2, r2, #15
 8001bbc:	600a      	str	r2, [r1, #0]
 8001bbe:	7a19      	ldrb	r1, [r3, #8]
 8001bc0:	685a      	ldr	r2, [r3, #4]
 8001bc2:	230f      	movs	r3, #15
 8001bc4:	408b      	lsls	r3, r1
 8001bc6:	6013      	str	r3, [r2, #0]
#endif
    }

    /* Transaction finished sending the STOP.*/
    dp->CR2 |= I2C_CR2_STOP;
 8001bc8:	686b      	ldr	r3, [r5, #4]
 8001bca:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 8001bce:	606b      	str	r3, [r5, #4]

    /* Make sure no more 'Transfer Complete' interrupts.*/
    dp->CR1 &= ~I2C_CR1_TCIE;
 8001bd0:	682b      	ldr	r3, [r5, #0]
 8001bd2:	f023 0340 	bic.w	r3, r3, #64	; 0x40
 8001bd6:	602b      	str	r3, [r5, #0]
 8001bd8:	2320      	movs	r3, #32
 8001bda:	f383 8811 	msr	BASEPRI, r3
 8001bde:	4806      	ldr	r0, [pc, #24]	; (8001bf8 <VectorBC+0x108>)
 8001be0:	2100      	movs	r1, #0
 8001be2:	f7ff fab5 	bl	8001150 <chThdResumeI>
 8001be6:	2300      	movs	r3, #0
 8001be8:	f383 8811 	msr	BASEPRI, r3
  I2CD1.i2c->ICR = isr & I2C_INT_MASK;

  i2c_lld_serve_interrupt(&I2CD1, isr);

  OSAL_IRQ_EPILOGUE();
}
 8001bec:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  /* Clearing IRQ bits.*/
  I2CD1.i2c->ICR = isr & I2C_INT_MASK;

  i2c_lld_serve_interrupt(&I2CD1, isr);

  OSAL_IRQ_EPILOGUE();
 8001bf0:	f7fe be3e 	b.w	8000870 <_port_irq_epilogue>
 8001bf4:	20001bd8 	.word	0x20001bd8
 8001bf8:	20001bf4 	.word	0x20001bf4
 8001bfc:	00000000 	.word	0x00000000

08001c00 <Vector134>:
/**
 * @brief   ADC4 interrupt handler (as ADC3 slave).
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector134) {
 8001c00:	b508      	push	{r3, lr}
  uint32_t isr;

  OSAL_IRQ_PROLOGUE();

  isr  = ADC4->ISR;
 8001c02:	4b05      	ldr	r3, [pc, #20]	; (8001c18 <Vector134+0x18>)
  ADC4->ISR = isr;

  adc_lld_serve_interrupt(&ADCD3, isr);
 8001c04:	4805      	ldr	r0, [pc, #20]	; (8001c1c <Vector134+0x1c>)
OSAL_IRQ_HANDLER(Vector134) {
  uint32_t isr;

  OSAL_IRQ_PROLOGUE();

  isr  = ADC4->ISR;
 8001c06:	6819      	ldr	r1, [r3, #0]
  ADC4->ISR = isr;
 8001c08:	6019      	str	r1, [r3, #0]

  adc_lld_serve_interrupt(&ADCD3, isr);
 8001c0a:	f7ff fab1 	bl	8001170 <adc_lld_serve_interrupt.lto_priv.89>

  OSAL_IRQ_EPILOGUE();
}
 8001c0e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  isr  = ADC4->ISR;
  ADC4->ISR = isr;

  adc_lld_serve_interrupt(&ADCD3, isr);

  OSAL_IRQ_EPILOGUE();
 8001c12:	f7fe be2d 	b.w	8000870 <_port_irq_epilogue>
 8001c16:	bf00      	nop
 8001c18:	50000500 	.word	0x50000500
 8001c1c:	20001218 	.word	0x20001218

08001c20 <VectorFC>:
/**
 * @brief   ADC3 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(VectorFC) {
 8001c20:	b508      	push	{r3, lr}
  uint32_t isr;

  OSAL_IRQ_PROLOGUE();

  isr  = ADC3->ISR;
 8001c22:	4b05      	ldr	r3, [pc, #20]	; (8001c38 <VectorFC+0x18>)
  ADC3->ISR = isr;

  adc_lld_serve_interrupt(&ADCD3, isr);
 8001c24:	4805      	ldr	r0, [pc, #20]	; (8001c3c <VectorFC+0x1c>)
OSAL_IRQ_HANDLER(VectorFC) {
  uint32_t isr;

  OSAL_IRQ_PROLOGUE();

  isr  = ADC3->ISR;
 8001c26:	6819      	ldr	r1, [r3, #0]
  ADC3->ISR = isr;
 8001c28:	6019      	str	r1, [r3, #0]

  adc_lld_serve_interrupt(&ADCD3, isr);
 8001c2a:	f7ff faa1 	bl	8001170 <adc_lld_serve_interrupt.lto_priv.89>

  OSAL_IRQ_EPILOGUE();
}
 8001c2e:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  isr  = ADC3->ISR;
  ADC3->ISR = isr;

  adc_lld_serve_interrupt(&ADCD3, isr);

  OSAL_IRQ_EPILOGUE();
 8001c32:	f7fe be1d 	b.w	8000870 <_port_irq_epilogue>
 8001c36:	bf00      	nop
 8001c38:	50000400 	.word	0x50000400
 8001c3c:	20001218 	.word	0x20001218

08001c40 <Vector88>:
  uint32_t isr;

  OSAL_IRQ_PROLOGUE();

#if STM32_ADC_DUAL_MODE
  isr  = ADC1->ISR;
 8001c40:	f04f 40a0 	mov.w	r0, #1342177280	; 0x50000000
  isr |= ADC2->ISR;
 8001c44:	4a06      	ldr	r2, [pc, #24]	; (8001c60 <Vector88+0x20>)
/**
 * @brief   ADC1/ADC2 interrupt handler.
 *
 * @isr
 */
OSAL_IRQ_HANDLER(Vector88) {
 8001c46:	b508      	push	{r3, lr}
  uint32_t isr;

  OSAL_IRQ_PROLOGUE();

#if STM32_ADC_DUAL_MODE
  isr  = ADC1->ISR;
 8001c48:	6803      	ldr	r3, [r0, #0]
  isr |= ADC2->ISR;
 8001c4a:	6811      	ldr	r1, [r2, #0]
 8001c4c:	4319      	orrs	r1, r3
  ADC1->ISR = isr;
 8001c4e:	6001      	str	r1, [r0, #0]
  ADC2->ISR = isr;
 8001c50:	6011      	str	r1, [r2, #0]
#else /* !STM32_ADC_DUAL_MODE */
  isr  = ADC1->ISR;
  ADC1->ISR = isr;
#endif /* !STM32_ADC_DUAL_MODE */

  adc_lld_serve_interrupt(&ADCD1, isr);
 8001c52:	4804      	ldr	r0, [pc, #16]	; (8001c64 <Vector88+0x24>)
 8001c54:	f7ff fa8c 	bl	8001170 <adc_lld_serve_interrupt.lto_priv.89>

  OSAL_IRQ_EPILOGUE();
}
 8001c58:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
  ADC1->ISR = isr;
#endif /* !STM32_ADC_DUAL_MODE */

  adc_lld_serve_interrupt(&ADCD1, isr);

  OSAL_IRQ_EPILOGUE();
 8001c5c:	f7fe be08 	b.w	8000870 <_port_irq_epilogue>
 8001c60:	50000100 	.word	0x50000100
 8001c64:	200019c0 	.word	0x200019c0
	...

08001c70 <chvprintf>:
 * @return              The number of bytes that would have been
 *                      written to @p chp if no stream error occurs
 *
 * @api
 */
int chvprintf(BaseSequentialStream *chp, const char *fmt, va_list ap) {
 8001c70:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8001c74:	460b      	mov	r3, r1
 8001c76:	b087      	sub	sp, #28
 8001c78:	4683      	mov	fp, r0
 8001c7a:	4615      	mov	r5, r2
  char *p, *s, c, filler;
  int i, precision, width;
  int n = 0;
 8001c7c:	f04f 0900 	mov.w	r9, #0
#else
  char tmpbuf[MAX_FILLER + 1];
#endif

  while (TRUE) {
    c = *fmt++;
 8001c80:	7819      	ldrb	r1, [r3, #0]
 8001c82:	1c5f      	adds	r7, r3, #1
    if (c == 0)
 8001c84:	2900      	cmp	r1, #0
 8001c86:	f000 80e6 	beq.w	8001e56 <chvprintf+0x1e6>
      return n;
    if (c != '%') {
 8001c8a:	2925      	cmp	r1, #37	; 0x25
 8001c8c:	d008      	beq.n	8001ca0 <chvprintf+0x30>
      chSequentialStreamPut(chp, (uint8_t)c);
 8001c8e:	f8db 3000 	ldr.w	r3, [fp]
 8001c92:	4658      	mov	r0, fp
 8001c94:	689b      	ldr	r3, [r3, #8]
 8001c96:	4798      	blx	r3
      n++;
 8001c98:	f109 0901 	add.w	r9, r9, #1
    while (--i >= 0) {
      chSequentialStreamPut(chp, (uint8_t)*s++);
      n++;
    }

    while (width) {
 8001c9c:	463b      	mov	r3, r7
 8001c9e:	e7ef      	b.n	8001c80 <chvprintf+0x10>
      continue;
    }
    p = tmpbuf;
    s = tmpbuf;
    left_align = FALSE;
    if (*fmt == '-') {
 8001ca0:	785a      	ldrb	r2, [r3, #1]
 8001ca2:	2a2d      	cmp	r2, #45	; 0x2d
      fmt++;
 8001ca4:	bf04      	itt	eq
 8001ca6:	1c9f      	addeq	r7, r3, #2
      left_align = TRUE;
 8001ca8:	f04f 0a01 	moveq.w	sl, #1
    }
    filler = ' ';
    if (*fmt == '0') {
 8001cac:	f897 8000 	ldrb.w	r8, [r7]
      n++;
      continue;
    }
    p = tmpbuf;
    s = tmpbuf;
    left_align = FALSE;
 8001cb0:	bf18      	it	ne
 8001cb2:	f04f 0a00 	movne.w	sl, #0
    if (*fmt == '-') {
      fmt++;
      left_align = TRUE;
    }
    filler = ' ';
    if (*fmt == '0') {
 8001cb6:	f1b8 0f30 	cmp.w	r8, #48	; 0x30
      fmt++;
 8001cba:	bf0c      	ite	eq
 8001cbc:	3701      	addeq	r7, #1
    left_align = FALSE;
    if (*fmt == '-') {
      fmt++;
      left_align = TRUE;
    }
    filler = ' ';
 8001cbe:	f04f 0820 	movne.w	r8, #32
    if (*fmt == '0') {
      fmt++;
      filler = '0';
    }
    width = 0;
 8001cc2:	2600      	movs	r6, #0
    while (TRUE) {
      c = *fmt++;
 8001cc4:	f817 3b01 	ldrb.w	r3, [r7], #1
      if (c >= '0' && c <= '9')
 8001cc8:	f1a3 0230 	sub.w	r2, r3, #48	; 0x30
 8001ccc:	b2d2      	uxtb	r2, r2
 8001cce:	2a09      	cmp	r2, #9
 8001cd0:	d903      	bls.n	8001cda <chvprintf+0x6a>
        c -= '0';
      else if (c == '*')
 8001cd2:	2b2a      	cmp	r3, #42	; 0x2a
 8001cd4:	d105      	bne.n	8001ce2 <chvprintf+0x72>
        c = va_arg(ap, int);
 8001cd6:	782a      	ldrb	r2, [r5, #0]
 8001cd8:	3504      	adds	r5, #4
      else
        break;
      width = width * 10 + c;
 8001cda:	230a      	movs	r3, #10
 8001cdc:	fb03 2606 	mla	r6, r3, r6, r2
 8001ce0:	e7f0      	b.n	8001cc4 <chvprintf+0x54>
    }
    precision = 0;
    if (c == '.') {
 8001ce2:	2b2e      	cmp	r3, #46	; 0x2e
 8001ce4:	f04f 0200 	mov.w	r2, #0
 8001ce8:	d10e      	bne.n	8001d08 <chvprintf+0x98>
      while (TRUE) {
        c = *fmt++;
 8001cea:	f817 3b01 	ldrb.w	r3, [r7], #1
        if (c >= '0' && c <= '9')
 8001cee:	f1a3 0130 	sub.w	r1, r3, #48	; 0x30
 8001cf2:	b2c9      	uxtb	r1, r1
 8001cf4:	2909      	cmp	r1, #9
 8001cf6:	d903      	bls.n	8001d00 <chvprintf+0x90>
          c -= '0';
        else if (c == '*')
 8001cf8:	2b2a      	cmp	r3, #42	; 0x2a
 8001cfa:	d105      	bne.n	8001d08 <chvprintf+0x98>
          c = va_arg(ap, int);
 8001cfc:	7829      	ldrb	r1, [r5, #0]
 8001cfe:	3504      	adds	r5, #4
        else
          break;
        precision *= 10;
        precision += c;
 8001d00:	230a      	movs	r3, #10
 8001d02:	fb03 1202 	mla	r2, r3, r2, r1
 8001d06:	e7f0      	b.n	8001cea <chvprintf+0x7a>
      }
    }
    /* Long modifier.*/
    if (c == 'l' || c == 'L') {
 8001d08:	f003 01df 	and.w	r1, r3, #223	; 0xdf
 8001d0c:	294c      	cmp	r1, #76	; 0x4c
 8001d0e:	d103      	bne.n	8001d18 <chvprintf+0xa8>
      is_long = TRUE;
      if (*fmt)
 8001d10:	7839      	ldrb	r1, [r7, #0]
 8001d12:	b109      	cbz	r1, 8001d18 <chvprintf+0xa8>
        c = *fmt++;
 8001d14:	3701      	adds	r7, #1
 8001d16:	460b      	mov	r3, r1
    }
    else
      is_long = (c >= 'A') && (c <= 'Z');

    /* Command decoding.*/
    switch (c) {
 8001d18:	2b63      	cmp	r3, #99	; 0x63
 8001d1a:	d108      	bne.n	8001d2e <chvprintf+0xbe>
    case 'c':
      filler = ' ';
      *p++ = va_arg(ap, int);
 8001d1c:	1d2b      	adds	r3, r5, #4
 8001d1e:	ac06      	add	r4, sp, #24
 8001d20:	9301      	str	r3, [sp, #4]
 8001d22:	682b      	ldr	r3, [r5, #0]
 8001d24:	f804 3d0c 	strb.w	r3, [r4, #-12]!
      is_long = (c >= 'A') && (c <= 'Z');

    /* Command decoding.*/
    switch (c) {
    case 'c':
      filler = ' ';
 8001d28:	f04f 0820 	mov.w	r8, #32
 8001d2c:	e00b      	b.n	8001d46 <chvprintf+0xd6>
    }
    else
      is_long = (c >= 'A') && (c <= 'Z');

    /* Command decoding.*/
    switch (c) {
 8001d2e:	d861      	bhi.n	8001df4 <chvprintf+0x184>
 8001d30:	2b4f      	cmp	r3, #79	; 0x4f
 8001d32:	d061      	beq.n	8001df8 <chvprintf+0x188>
 8001d34:	d90a      	bls.n	8001d4c <chvprintf+0xdc>
 8001d36:	2b55      	cmp	r3, #85	; 0x55
 8001d38:	d063      	beq.n	8001e02 <chvprintf+0x192>
 8001d3a:	2b58      	cmp	r3, #88	; 0x58
 8001d3c:	d06b      	beq.n	8001e16 <chvprintf+0x1a6>
      else
        l = va_arg(ap, unsigned int);
      p = ch_ltoa(p, l, c);
      break;
    default:
      *p++ = c;
 8001d3e:	ac06      	add	r4, sp, #24
 8001d40:	9501      	str	r5, [sp, #4]
 8001d42:	f804 3d0c 	strb.w	r3, [r4, #-12]!
 8001d46:	f10d 000d 	add.w	r0, sp, #13
 8001d4a:	e012      	b.n	8001d72 <chvprintf+0x102>
    }
    else
      is_long = (c >= 'A') && (c <= 'Z');

    /* Command decoding.*/
    switch (c) {
 8001d4c:	2b44      	cmp	r3, #68	; 0x44
 8001d4e:	d15e      	bne.n	8001e0e <chvprintf+0x19e>
    case 'I':
    case 'i':
      if (is_long)
        l = va_arg(ap, long);
      else
        l = va_arg(ap, int);
 8001d50:	6829      	ldr	r1, [r5, #0]
 8001d52:	1d2b      	adds	r3, r5, #4
      if (l < 0) {
 8001d54:	2900      	cmp	r1, #0
    case 'I':
    case 'i':
      if (is_long)
        l = va_arg(ap, long);
      else
        l = va_arg(ap, int);
 8001d56:	9301      	str	r3, [sp, #4]
      if (l < 0) {
        *p++ = '-';
 8001d58:	bfbf      	itttt	lt
 8001d5a:	232d      	movlt	r3, #45	; 0x2d
 8001d5c:	f88d 300c 	strblt.w	r3, [sp, #12]
        l = -l;
 8001d60:	4249      	neglt	r1, r1
      if (is_long)
        l = va_arg(ap, long);
      else
        l = va_arg(ap, int);
      if (l < 0) {
        *p++ = '-';
 8001d62:	f10d 000d 	addlt.w	r0, sp, #13
    if (c != '%') {
      chSequentialStreamPut(chp, (uint8_t)c);
      n++;
      continue;
    }
    p = tmpbuf;
 8001d66:	bfa8      	it	ge
 8001d68:	a803      	addge	r0, sp, #12
  return p;
}

static char *ch_ltoa(char *p, long num, unsigned radix) {

  return long_to_string_with_divisor(p, num, radix, 0);
 8001d6a:	220a      	movs	r2, #10
 8001d6c:	f001 fd88 	bl	8003880 <long_to_string_with_divisor.constprop.5>
      chSequentialStreamPut(chp, (uint8_t)c);
      n++;
      continue;
    }
    p = tmpbuf;
    s = tmpbuf;
 8001d70:	ac03      	add	r4, sp, #12
      break;
    default:
      *p++ = c;
      break;
    }
    i = (int)(p - s);
 8001d72:	1b05      	subs	r5, r0, r4
    if ((width -= i) < 0)
 8001d74:	1b76      	subs	r6, r6, r5
 8001d76:	ea26 76e6 	bic.w	r6, r6, r6, asr #31
      width = 0;
    if (left_align == FALSE)
 8001d7a:	f1ba 0f00 	cmp.w	sl, #0
 8001d7e:	d11d      	bne.n	8001dbc <chvprintf+0x14c>
      width = -width;
 8001d80:	4276      	negs	r6, r6
    if (width < 0) {
 8001d82:	b1de      	cbz	r6, 8001dbc <chvprintf+0x14c>
      if (*s == '-' && filler == '0') {
 8001d84:	7821      	ldrb	r1, [r4, #0]
 8001d86:	292d      	cmp	r1, #45	; 0x2d
 8001d88:	d10b      	bne.n	8001da2 <chvprintf+0x132>
 8001d8a:	f1b8 0f30 	cmp.w	r8, #48	; 0x30
 8001d8e:	d108      	bne.n	8001da2 <chvprintf+0x132>
        chSequentialStreamPut(chp, (uint8_t)*s++);
 8001d90:	f8db 3000 	ldr.w	r3, [fp]
 8001d94:	4658      	mov	r0, fp
 8001d96:	689b      	ldr	r3, [r3, #8]
 8001d98:	4798      	blx	r3
 8001d9a:	3401      	adds	r4, #1
        n++;
 8001d9c:	f109 0901 	add.w	r9, r9, #1
        i--;
 8001da0:	3d01      	subs	r5, #1
      else
        l = va_arg(ap, unsigned int);
      p = ch_ltoa(p, l, c);
      break;
    default:
      *p++ = c;
 8001da2:	46b2      	mov	sl, r6
        chSequentialStreamPut(chp, (uint8_t)*s++);
        n++;
        i--;
      }
      do {
        chSequentialStreamPut(chp, (uint8_t)filler);
 8001da4:	f8db 3000 	ldr.w	r3, [fp]
 8001da8:	4658      	mov	r0, fp
 8001daa:	689b      	ldr	r3, [r3, #8]
 8001dac:	4641      	mov	r1, r8
 8001dae:	4798      	blx	r3
        n++;
      } while (++width != 0);
 8001db0:	f11a 0a01 	adds.w	sl, sl, #1
 8001db4:	d1f6      	bne.n	8001da4 <chvprintf+0x134>
 8001db6:	ebc6 0909 	rsb	r9, r6, r9
 8001dba:	4656      	mov	r6, sl
 8001dbc:	46aa      	mov	sl, r5
    }
    while (--i >= 0) {
 8001dbe:	f1ba 0a01 	subs.w	sl, sl, #1
 8001dc2:	d407      	bmi.n	8001dd4 <chvprintf+0x164>
      chSequentialStreamPut(chp, (uint8_t)*s++);
 8001dc4:	f8db 3000 	ldr.w	r3, [fp]
 8001dc8:	f814 1b01 	ldrb.w	r1, [r4], #1
 8001dcc:	689b      	ldr	r3, [r3, #8]
 8001dce:	4658      	mov	r0, fp
 8001dd0:	4798      	blx	r3
 8001dd2:	e7f4      	b.n	8001dbe <chvprintf+0x14e>
 8001dd4:	2d00      	cmp	r5, #0
 8001dd6:	bfa8      	it	ge
 8001dd8:	44a9      	addge	r9, r5
      do {
        chSequentialStreamPut(chp, (uint8_t)filler);
        n++;
      } while (++width != 0);
    }
    while (--i >= 0) {
 8001dda:	4634      	mov	r4, r6
      chSequentialStreamPut(chp, (uint8_t)*s++);
      n++;
    }

    while (width) {
 8001ddc:	b914      	cbnz	r4, 8001de4 <chvprintf+0x174>
 8001dde:	44b1      	add	r9, r6
 8001de0:	9d01      	ldr	r5, [sp, #4]
 8001de2:	e75b      	b.n	8001c9c <chvprintf+0x2c>
      chSequentialStreamPut(chp, (uint8_t)filler);
 8001de4:	f8db 3000 	ldr.w	r3, [fp]
 8001de8:	4658      	mov	r0, fp
 8001dea:	689b      	ldr	r3, [r3, #8]
 8001dec:	4641      	mov	r1, r8
 8001dee:	4798      	blx	r3
      n++;
      width--;
 8001df0:	3c01      	subs	r4, #1
 8001df2:	e7f3      	b.n	8001ddc <chvprintf+0x16c>
    }
    else
      is_long = (c >= 'A') && (c <= 'Z');

    /* Command decoding.*/
    switch (c) {
 8001df4:	2b6f      	cmp	r3, #111	; 0x6f
 8001df6:	d101      	bne.n	8001dfc <chvprintf+0x18c>
    case 'u':
      c = 10;
      goto unsigned_common;
    case 'O':
    case 'o':
      c = 8;
 8001df8:	2208      	movs	r2, #8
 8001dfa:	e003      	b.n	8001e04 <chvprintf+0x194>
    }
    else
      is_long = (c >= 'A') && (c <= 'Z');

    /* Command decoding.*/
    switch (c) {
 8001dfc:	d90d      	bls.n	8001e1a <chvprintf+0x1aa>
 8001dfe:	2b75      	cmp	r3, #117	; 0x75
 8001e00:	d107      	bne.n	8001e12 <chvprintf+0x1a2>
    case 'x':
      c = 16;
      goto unsigned_common;
    case 'U':
    case 'u':
      c = 10;
 8001e02:	220a      	movs	r2, #10
      c = 8;
unsigned_common:
      if (is_long)
        l = va_arg(ap, unsigned long);
      else
        l = va_arg(ap, unsigned int);
 8001e04:	1d2b      	adds	r3, r5, #4
 8001e06:	9301      	str	r3, [sp, #4]
 8001e08:	6829      	ldr	r1, [r5, #0]
  return p;
}

static char *ch_ltoa(char *p, long num, unsigned radix) {

  return long_to_string_with_divisor(p, num, radix, 0);
 8001e0a:	a803      	add	r0, sp, #12
 8001e0c:	e7ae      	b.n	8001d6c <chvprintf+0xfc>
    }
    else
      is_long = (c >= 'A') && (c <= 'Z');

    /* Command decoding.*/
    switch (c) {
 8001e0e:	2b49      	cmp	r3, #73	; 0x49
 8001e10:	e006      	b.n	8001e20 <chvprintf+0x1b0>
 8001e12:	2b78      	cmp	r3, #120	; 0x78
 8001e14:	d106      	bne.n	8001e24 <chvprintf+0x1b4>
      p = ftoa(p, f, precision);
      break;
#endif
    case 'X':
    case 'x':
      c = 16;
 8001e16:	2210      	movs	r2, #16
 8001e18:	e7f4      	b.n	8001e04 <chvprintf+0x194>
    }
    else
      is_long = (c >= 'A') && (c <= 'Z');

    /* Command decoding.*/
    switch (c) {
 8001e1a:	2b64      	cmp	r3, #100	; 0x64
 8001e1c:	d098      	beq.n	8001d50 <chvprintf+0xe0>
 8001e1e:	2b69      	cmp	r3, #105	; 0x69
 8001e20:	d096      	beq.n	8001d50 <chvprintf+0xe0>
 8001e22:	e78c      	b.n	8001d3e <chvprintf+0xce>
 8001e24:	2b73      	cmp	r3, #115	; 0x73
 8001e26:	d18a      	bne.n	8001d3e <chvprintf+0xce>
      filler = ' ';
      *p++ = va_arg(ap, int);
      break;
    case 's':
      filler = ' ';
      if ((s = va_arg(ap, char *)) == 0)
 8001e28:	1d2b      	adds	r3, r5, #4
 8001e2a:	9301      	str	r3, [sp, #4]
 8001e2c:	682c      	ldr	r4, [r5, #0]
        s = "(null)";
 8001e2e:	4b0c      	ldr	r3, [pc, #48]	; (8001e60 <chvprintf+0x1f0>)
 8001e30:	2c00      	cmp	r4, #0
 8001e32:	bf08      	it	eq
 8001e34:	461c      	moveq	r4, r3
      if (precision == 0)
        precision = 32767;
 8001e36:	f647 73ff 	movw	r3, #32767	; 0x7fff
 8001e3a:	2a00      	cmp	r2, #0
 8001e3c:	bf08      	it	eq
 8001e3e:	461a      	moveq	r2, r3
 8001e40:	4422      	add	r2, r4
 8001e42:	4620      	mov	r0, r4
      for (p = s; *p && (--precision >= 0); p++)
 8001e44:	7803      	ldrb	r3, [r0, #0]
 8001e46:	b11b      	cbz	r3, 8001e50 <chvprintf+0x1e0>
 8001e48:	4290      	cmp	r0, r2
 8001e4a:	d001      	beq.n	8001e50 <chvprintf+0x1e0>
 8001e4c:	3001      	adds	r0, #1
 8001e4e:	e7f9      	b.n	8001e44 <chvprintf+0x1d4>
    case 'c':
      filler = ' ';
      *p++ = va_arg(ap, int);
      break;
    case 's':
      filler = ' ';
 8001e50:	f04f 0820 	mov.w	r8, #32
 8001e54:	e78d      	b.n	8001d72 <chvprintf+0x102>
      chSequentialStreamPut(chp, (uint8_t)filler);
      n++;
      width--;
    }
  }
}
 8001e56:	4648      	mov	r0, r9
 8001e58:	b007      	add	sp, #28
 8001e5a:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 8001e5e:	bf00      	nop
 8001e60:	08003c50 	.word	0x08003c50
	...

08001e70 <chprintf.lto_priv.86>:
 * @param[in] chp       pointer to a @p BaseSequentialStream implementing object
 * @param[in] fmt       formatting string
 *
 * @api
 */
static inline int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
 8001e70:	b40e      	push	{r1, r2, r3}
 8001e72:	b503      	push	{r0, r1, lr}
 8001e74:	aa03      	add	r2, sp, #12
 8001e76:	f852 1b04 	ldr.w	r1, [r2], #4
  va_list ap;
  int formatted_bytes;

  va_start(ap, fmt);
 8001e7a:	9201      	str	r2, [sp, #4]
  formatted_bytes = chvprintf(chp, fmt, ap);
 8001e7c:	f7ff fef8 	bl	8001c70 <chvprintf>
  va_end(ap);

  return formatted_bytes;
}
 8001e80:	b002      	add	sp, #8
 8001e82:	f85d eb04 	ldr.w	lr, [sp], #4
 8001e86:	b003      	add	sp, #12
 8001e88:	4770      	bx	lr
 8001e8a:	0000      	movs	r0, r0
 8001e8c:	0000      	movs	r0, r0
	...

08001e90 <__early_init>:
void stm32_clock_init(void) {

#if !STM32_NO_INIT
  /* HSI setup, it enforces the reset situation in order to handle possible
     problems with JTAG probes and re-initializations.*/
  RCC->CR |= RCC_CR_HSION;                  /* Make sure HSI is ON.         */
 8001e90:	4b23      	ldr	r3, [pc, #140]	; (8001f20 <__early_init+0x90>)
 8001e92:	681a      	ldr	r2, [r3, #0]
 8001e94:	f042 0201 	orr.w	r2, r2, #1
 8001e98:	601a      	str	r2, [r3, #0]
  while (!(RCC->CR & RCC_CR_HSIRDY))
 8001e9a:	6819      	ldr	r1, [r3, #0]
 8001e9c:	4a20      	ldr	r2, [pc, #128]	; (8001f20 <__early_init+0x90>)
 8001e9e:	0789      	lsls	r1, r1, #30
 8001ea0:	d5fb      	bpl.n	8001e9a <__early_init+0xa>
    ;                                       /* Wait until HSI is stable.    */

  /* HSI is selected as new source without touching the other fields in
     CFGR. Clearing the register has to be postponed after HSI is the
     new source.*/
  RCC->CFGR &= ~RCC_CFGR_SW;                /* Reset SW */
 8001ea2:	6851      	ldr	r1, [r2, #4]
 8001ea4:	f021 0103 	bic.w	r1, r1, #3
 8001ea8:	6051      	str	r1, [r2, #4]
  RCC->CFGR |= RCC_CFGR_SWS_HSI;            /* Select HSI as internal*/
 8001eaa:	6851      	ldr	r1, [r2, #4]
 8001eac:	6051      	str	r1, [r2, #4]
  while ((RCC->CFGR & RCC_CFGR_SWS) != RCC_CFGR_SWS_HSI)
 8001eae:	6859      	ldr	r1, [r3, #4]
 8001eb0:	4a1b      	ldr	r2, [pc, #108]	; (8001f20 <__early_init+0x90>)
 8001eb2:	f011 010c 	ands.w	r1, r1, #12
 8001eb6:	d1fa      	bne.n	8001eae <__early_init+0x1e>
    ;                                       /* Wait until HSI is selected.  */

  /* Registers finally cleared to reset values.*/
  RCC->CR &= RCC_CR_HSITRIM | RCC_CR_HSION; /* CR Reset value.              */
 8001eb8:	6810      	ldr	r0, [r2, #0]
 8001eba:	f000 00f9 	and.w	r0, r0, #249	; 0xf9
 8001ebe:	6010      	str	r0, [r2, #0]
  RCC->CFGR = 0;                            /* CFGR reset value.            */
 8001ec0:	6051      	str	r1, [r2, #4]
#if defined(STM32_HSE_BYPASS)
  /* HSE Bypass.*/
  RCC->CR |= RCC_CR_HSEON | RCC_CR_HSEBYP;
#else
  /* No HSE Bypass.*/
  RCC->CR |= RCC_CR_HSEON;
 8001ec2:	6811      	ldr	r1, [r2, #0]
 8001ec4:	f441 3180 	orr.w	r1, r1, #65536	; 0x10000
 8001ec8:	6011      	str	r1, [r2, #0]
#endif
  while (!(RCC->CR & RCC_CR_HSERDY))
 8001eca:	681a      	ldr	r2, [r3, #0]
 8001ecc:	4914      	ldr	r1, [pc, #80]	; (8001f20 <__early_init+0x90>)
 8001ece:	0390      	lsls	r0, r2, #14
 8001ed0:	d5fb      	bpl.n	8001eca <__early_init+0x3a>
    ;                                       /* Waits until HSE is stable.   */
#endif

#if STM32_LSI_ENABLED
  /* LSI activation.*/
  RCC->CSR |= RCC_CSR_LSION;
 8001ed2:	6a4a      	ldr	r2, [r1, #36]	; 0x24
 8001ed4:	f042 0201 	orr.w	r2, r2, #1
 8001ed8:	624a      	str	r2, [r1, #36]	; 0x24
  while ((RCC->CSR & RCC_CSR_LSIRDY) == 0)
 8001eda:	6a59      	ldr	r1, [r3, #36]	; 0x24
 8001edc:	4a10      	ldr	r2, [pc, #64]	; (8001f20 <__early_init+0x90>)
 8001ede:	0789      	lsls	r1, r1, #30
 8001ee0:	d5fb      	bpl.n	8001eda <__early_init+0x4a>
    ;                                       /* Waits until LSI is stable.   */
#endif

  /* Clock settings.*/
  RCC->CFGR  = STM32_MCOSEL    | STM32_USBPRE    | STM32_PLLMUL   |
 8001ee2:	4910      	ldr	r1, [pc, #64]	; (8001f24 <__early_init+0x94>)
 8001ee4:	6051      	str	r1, [r2, #4]
               STM32_PLLSRC    | STM32_PPRE1     | STM32_PPRE2    |
               STM32_HPRE;
  RCC->CFGR2 = STM32_ADC34PRES | STM32_ADC12PRES | STM32_PREDIV;
 8001ee6:	f242 1101 	movw	r1, #8449	; 0x2101
 8001eea:	62d1      	str	r1, [r2, #44]	; 0x2c
  RCC->CFGR3 = STM32_UART5SW   | STM32_UART4SW   | STM32_USART3SW |
 8001eec:	2130      	movs	r1, #48	; 0x30
 8001eee:	6311      	str	r1, [r2, #48]	; 0x30
               STM32_USART2SW  | STM32_I2C2SW    | STM32_I2C1SW   |
               STM32_USART1SW;

#if STM32_ACTIVATE_PLL
  /* PLL activation.*/
  RCC->CR   |= RCC_CR_PLLON;
 8001ef0:	6811      	ldr	r1, [r2, #0]
 8001ef2:	f041 7180 	orr.w	r1, r1, #16777216	; 0x1000000
 8001ef6:	6011      	str	r1, [r2, #0]
  while (!(RCC->CR & RCC_CR_PLLRDY))
 8001ef8:	681a      	ldr	r2, [r3, #0]
 8001efa:	4909      	ldr	r1, [pc, #36]	; (8001f20 <__early_init+0x90>)
 8001efc:	0192      	lsls	r2, r2, #6
 8001efe:	d5fb      	bpl.n	8001ef8 <__early_init+0x68>
    ;                                       /* Waits until PLL is stable.   */
#endif

  /* Flash setup and final clock selection.   */
  FLASH->ACR = STM32_FLASHBITS;
 8001f00:	4a09      	ldr	r2, [pc, #36]	; (8001f28 <__early_init+0x98>)
 8001f02:	2011      	movs	r0, #17
 8001f04:	6010      	str	r0, [r2, #0]

  /* Switching to the configured clock source if it is different from HSI.*/
#if (STM32_SW != STM32_SW_HSI)
  /* Switches clock source.*/
  RCC->CFGR |= STM32_SW;
 8001f06:	684a      	ldr	r2, [r1, #4]
 8001f08:	f042 0202 	orr.w	r2, r2, #2
 8001f0c:	604a      	str	r2, [r1, #4]
  while ((RCC->CFGR & RCC_CFGR_SWS) != (STM32_SW << 2))
 8001f0e:	685a      	ldr	r2, [r3, #4]
 8001f10:	4903      	ldr	r1, [pc, #12]	; (8001f20 <__early_init+0x90>)
 8001f12:	f002 020c 	and.w	r2, r2, #12
 8001f16:	2a08      	cmp	r2, #8
 8001f18:	d1f9      	bne.n	8001f0e <__early_init+0x7e>
    ;                                       /* Waits selection complete.    */
#endif

  /* After PLL activation because the special requirements for TIM1 and
     TIM8 bits.*/
  RCC->CFGR3 |= STM32_TIM8SW | STM32_TIM1SW;
 8001f1a:	6b0b      	ldr	r3, [r1, #48]	; 0x30
 8001f1c:	630b      	str	r3, [r1, #48]	; 0x30
 8001f1e:	4770      	bx	lr
 8001f20:	40021000 	.word	0x40021000
 8001f24:	00512400 	.word	0x00512400
 8001f28:	40022000 	.word	0x40022000
 8001f2c:	00000000 	.word	0x00000000

08001f30 <i2c_lld_init>:
 *
 * @init
 */
void i2cObjectInit(I2CDriver *i2cp) {

  i2cp->state  = I2C_STOP;
 8001f30:	4b08      	ldr	r3, [pc, #32]	; (8001f54 <i2c_lld_init+0x24>)
 8001f32:	2201      	movs	r2, #1
 8001f34:	701a      	strb	r2, [r3, #0]
  i2cp->config = NULL;
 8001f36:	2200      	movs	r2, #0
 8001f38:	605a      	str	r2, [r3, #4]
void chMtxObjectInit(mutex_t *mp) {

  chDbgCheck(mp != NULL);

  queue_init(&mp->m_queue);
  mp->m_owner = NULL;
 8001f3a:	615a      	str	r2, [r3, #20]
 */
void i2c_lld_init(void) {

#if STM32_I2C_USE_I2C1
  i2cObjectInit(&I2CD1);
  I2CD1.thread = NULL;
 8001f3c:	61da      	str	r2, [r3, #28]
  I2CD1.i2c    = I2C1;
 8001f3e:	4a06      	ldr	r2, [pc, #24]	; (8001f58 <i2c_lld_init+0x28>)
 8001f40:	631a      	str	r2, [r3, #48]	; 0x30
#if STM32_I2C_USE_DMA == TRUE
  I2CD1.dmarx  = STM32_DMA_STREAM(STM32_I2C_I2C1_RX_DMA_STREAM);
 8001f42:	4a06      	ldr	r2, [pc, #24]	; (8001f5c <i2c_lld_init+0x2c>)
 8001f44:	629a      	str	r2, [r3, #40]	; 0x28
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8001f46:	f103 010c 	add.w	r1, r3, #12
  I2CD1.dmatx  = STM32_DMA_STREAM(STM32_I2C_I2C1_TX_DMA_STREAM);
 8001f4a:	3a0c      	subs	r2, #12
 8001f4c:	60d9      	str	r1, [r3, #12]
  tqp->p_prev = (thread_t *)tqp;
 8001f4e:	6119      	str	r1, [r3, #16]
 8001f50:	62da      	str	r2, [r3, #44]	; 0x2c
 8001f52:	4770      	bx	lr
 8001f54:	20001bd8 	.word	0x20001bd8
 8001f58:	40005400 	.word	0x40005400
 8001f5c:	08003d48 	.word	0x08003d48

08001f60 <initgpio.lto_priv.81>:
/* Driver local functions.                                                   */
/*===========================================================================*/

static void initgpio(stm32_gpio_t *gpiop, const stm32_gpio_setup_t *config) {

  gpiop->OTYPER  = config->otyper;
 8001f60:	684b      	ldr	r3, [r1, #4]
 8001f62:	6043      	str	r3, [r0, #4]
  gpiop->OSPEEDR = config->ospeedr;
 8001f64:	688b      	ldr	r3, [r1, #8]
 8001f66:	6083      	str	r3, [r0, #8]
  gpiop->PUPDR   = config->pupdr;
 8001f68:	68cb      	ldr	r3, [r1, #12]
 8001f6a:	60c3      	str	r3, [r0, #12]
  gpiop->ODR     = config->odr;
 8001f6c:	690b      	ldr	r3, [r1, #16]
 8001f6e:	6143      	str	r3, [r0, #20]
  gpiop->AFRL    = config->afrl;
 8001f70:	694b      	ldr	r3, [r1, #20]
 8001f72:	6203      	str	r3, [r0, #32]
  gpiop->AFRH    = config->afrh;
 8001f74:	698b      	ldr	r3, [r1, #24]
 8001f76:	6243      	str	r3, [r0, #36]	; 0x24
  gpiop->MODER   = config->moder;
 8001f78:	680b      	ldr	r3, [r1, #0]
 8001f7a:	6003      	str	r3, [r0, #0]
 8001f7c:	4770      	bx	lr
	...

08001f80 <adc_lld_stop_conversion>:
 *
 * @notapi
 */
void adc_lld_stop_conversion(ADCDriver *adcp) {

  dmaStreamDisable(adcp->dmastp);
 8001f80:	6b43      	ldr	r3, [r0, #52]	; 0x34
 8001f82:	6819      	ldr	r1, [r3, #0]
 8001f84:	680a      	ldr	r2, [r1, #0]
 8001f86:	f022 020f 	bic.w	r2, r2, #15
 8001f8a:	600a      	str	r2, [r1, #0]
 8001f8c:	7a19      	ldrb	r1, [r3, #8]
 8001f8e:	685a      	ldr	r2, [r3, #4]
 8001f90:	230f      	movs	r3, #15
 8001f92:	408b      	lsls	r3, r1
 8001f94:	6013      	str	r3, [r2, #0]
 8001f96:	6ac3      	ldr	r3, [r0, #44]	; 0x2c
 *
 * @param[in] adcp      pointer to the @p ADCDriver object
 */
static void adc_lld_stop_adc(ADCDriver *adcp) {

  if (adcp->adcm->CR & ADC_CR_ADSTART) {
 8001f98:	689a      	ldr	r2, [r3, #8]
 8001f9a:	0751      	lsls	r1, r2, #29
 8001f9c:	d506      	bpl.n	8001fac <adc_lld_stop_conversion+0x2c>
    adcp->adcm->CR |= ADC_CR_ADSTP;
 8001f9e:	689a      	ldr	r2, [r3, #8]
 8001fa0:	f042 0210 	orr.w	r2, r2, #16
 8001fa4:	609a      	str	r2, [r3, #8]
    while (adcp->adcm->CR & ADC_CR_ADSTP)
 8001fa6:	689a      	ldr	r2, [r3, #8]
 8001fa8:	06d2      	lsls	r2, r2, #27
 8001faa:	d4fc      	bmi.n	8001fa6 <adc_lld_stop_conversion+0x26>
 8001fac:	4770      	bx	lr
	...

08001fb0 <Thread5>:
/*
 * GAS sensor test thread
 */
static THD_WORKING_AREA(waThread5, 128);
static THD_FUNCTION(Thread5, arg)
{
 8001fb0:	b508      	push	{r3, lr}
 * @api
 */
static inline void chRegSetThreadName(const char *name) {

#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.r_current->p_name = name;
 8001fb2:	4b04      	ldr	r3, [pc, #16]	; (8001fc4 <Thread5+0x14>)
 8001fb4:	4a04      	ldr	r2, [pc, #16]	; (8001fc8 <Thread5+0x18>)
 8001fb6:	699b      	ldr	r3, [r3, #24]
 8001fb8:	619a      	str	r2, [r3, #24]
	(void)arg;
	chRegSetThreadName("gas_sensor_tst");
	
	while(TRUE)
	{
		chThdSleepMilliseconds(30);
 8001fba:	f44f 7096 	mov.w	r0, #300	; 0x12c
 8001fbe:	f7fe ff8f 	bl	8000ee0 <chThdSleep>
 8001fc2:	e7fa      	b.n	8001fba <Thread5+0xa>
 8001fc4:	20001a00 	.word	0x20001a00
 8001fc8:	08003de0 	.word	0x08003de0
 8001fcc:	00000000 	.word	0x00000000

08001fd0 <Thread4>:
 8001fd0:	4e75      	ldr	r6, [pc, #468]	; (80021a8 <Thread4+0x1d8>)
/*
 * Si7006 relative himidity sensor readout
 */
static THD_WORKING_AREA(waThread4, 128);
static THD_FUNCTION(Thread4, arg)
{
 8001fd2:	b58f      	push	{r0, r1, r2, r3, r7, lr}
 8001fd4:	69b3      	ldr	r3, [r6, #24]
 8001fd6:	4a75      	ldr	r2, [pc, #468]	; (80021ac <Thread4+0x1dc>)
 * @api
 */
static inline void osalMutexLock(mutex_t *mp) {

#if CH_CFG_USE_MUTEXES
  chMtxLock(mp);
 8001fd8:	4875      	ldr	r0, [pc, #468]	; (80021b0 <Thread4+0x1e0>)
 8001fda:	619a      	str	r2, [r3, #24]
 8001fdc:	f7ff f800 	bl	8000fe0 <chMtxLock>
 * @api
 */
static inline void osalMutexUnlock(mutex_t *mp) {

#if CH_CFG_USE_MUTEXES
  chMtxUnlock(mp);
 8001fe0:	4873      	ldr	r0, [pc, #460]	; (80021b0 <Thread4+0x1e0>)
 8001fe2:	f7fe ffc5 	bl	8000f70 <chMtxUnlock>
 * @api
 */
static inline void osalMutexLock(mutex_t *mp) {

#if CH_CFG_USE_MUTEXES
  chMtxLock(mp);
 8001fe6:	4872      	ldr	r0, [pc, #456]	; (80021b0 <Thread4+0x1e0>)
	
	while (true) {
		i2cAcquireBus(&I2CD1);
		i2c_tx_data[0]=0xF5;   // measure RH, no hold master mode
		i2c_tx_data[1]=0;      // nb byte to read
		status = i2cMasterTransmitTimeout(&I2CD1, i2c_device_address, i2c_tx_data, 1, NULL, 0, tmo);
 8001fe8:	4f72      	ldr	r7, [pc, #456]	; (80021b4 <Thread4+0x1e4>)
 8001fea:	4c73      	ldr	r4, [pc, #460]	; (80021b8 <Thread4+0x1e8>)
 8001fec:	f7fe fff8 	bl	8000fe0 <chMtxLock>

	i2cReleaseBus(&I2CD1);
	
	while (true) {
		i2cAcquireBus(&I2CD1);
		i2c_tx_data[0]=0xF5;   // measure RH, no hold master mode
 8001ff0:	23f5      	movs	r3, #245	; 0xf5
 8001ff2:	f88d 3008 	strb.w	r3, [sp, #8]
		i2c_tx_data[1]=0;      // nb byte to read
 8001ff6:	2300      	movs	r3, #0
		status = i2cMasterTransmitTimeout(&I2CD1, i2c_device_address, i2c_tx_data, 1, NULL, 0, tmo);
 8001ff8:	9300      	str	r3, [sp, #0]
 8001ffa:	2040      	movs	r0, #64	; 0x40
 8001ffc:	a902      	add	r1, sp, #8
 8001ffe:	2201      	movs	r2, #1
	i2cReleaseBus(&I2CD1);
	
	while (true) {
		i2cAcquireBus(&I2CD1);
		i2c_tx_data[0]=0xF5;   // measure RH, no hold master mode
		i2c_tx_data[1]=0;      // nb byte to read
 8002000:	f88d 3009 	strb.w	r3, [sp, #9]
		status = i2cMasterTransmitTimeout(&I2CD1, i2c_device_address, i2c_tx_data, 1, NULL, 0, tmo);
 8002004:	f001 fb84 	bl	8003710 <i2cMasterTransmitTimeout.constprop.17>
 8002008:	6038      	str	r0, [r7, #0]
		if (status != MSG_OK) {
 800200a:	b150      	cbz	r0, 8002022 <Thread4+0x52>
			errors = i2cGetErrors(&I2CD1);
 800200c:	4b6b      	ldr	r3, [pc, #428]	; (80021bc <Thread4+0x1ec>)
 */
i2cflags_t i2cGetErrors(I2CDriver *i2cp) {

  osalDbgCheck(i2cp != NULL);

  return i2c_lld_get_errors(i2cp);
 800200e:	68a4      	ldr	r4, [r4, #8]
 8002010:	601c      	str	r4, [r3, #0]
			chprintf((BaseSequentialStream *)&SD1, "[%010d] i2c write error : %02.2x at address %02.2x\r\n", chVTGetSystemTime(), errors, i2c_device_address); 
 8002012:	f001 fa05 	bl	8003420 <chVTGetSystemTime.lto_priv.80>
 8002016:	2340      	movs	r3, #64	; 0x40
 8002018:	4602      	mov	r2, r0
 800201a:	9300      	str	r3, [sp, #0]
 800201c:	4868      	ldr	r0, [pc, #416]	; (80021c0 <Thread4+0x1f0>)
 800201e:	4969      	ldr	r1, [pc, #420]	; (80021c4 <Thread4+0x1f4>)
 8002020:	e088      	b.n	8002134 <Thread4+0x164>
	while (true) {
		i2cAcquireBus(&I2CD1);
		i2c_tx_data[0]=0xF5;   // measure RH, no hold master mode
		i2c_tx_data[1]=0;      // nb byte to read
		status = i2cMasterTransmitTimeout(&I2CD1, i2c_device_address, i2c_tx_data, 1, NULL, 0, tmo);
		if (status != MSG_OK) {
 8002022:	f04f 0897 	mov.w	r8, #151	; 0x97
 8002026:	2320      	movs	r3, #32
 8002028:	f383 8811 	msr	BASEPRI, r3
               (timeout != TIME_IMMEDIATE));

  osalDbgAssert(i2cp->state == I2C_READY, "not ready");

  osalSysLock();
  i2cp->errors = I2C_NO_ERROR;
 800202c:	2300      	movs	r3, #0
  i2cp->state = I2C_ACTIVE_RX;
 800202e:	2204      	movs	r2, #4
               (timeout != TIME_IMMEDIATE));

  osalDbgAssert(i2cp->state == I2C_READY, "not ready");

  osalSysLock();
  i2cp->errors = I2C_NO_ERROR;
 8002030:	60a3      	str	r3, [r4, #8]
  i2cp->state = I2C_ACTIVE_RX;
 8002032:	7022      	strb	r2, [r4, #0]
 */
msg_t i2c_lld_master_receive_timeout(I2CDriver *i2cp, i2caddr_t addr,
                                     uint8_t *rxbuf, size_t rxbytes,
                                     systime_t timeout) {
  msg_t msg;
  I2C_TypeDef *dp = i2cp->i2c;
 8002034:	6b25      	ldr	r5, [r4, #48]	; 0x30
 8002036:	f383 8811 	msr	BASEPRI, r3
  /* Releases the lock from high level driver.*/
  osalSysUnlock();

#if STM32_I2C_USE_DMA == TRUE
  /* RX DMA setup.*/
  dmaStreamSetMode(i2cp->dmarx, i2cp->rxdmamode);
 800203a:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 800203c:	6a22      	ldr	r2, [r4, #32]
 800203e:	681b      	ldr	r3, [r3, #0]
  dmaStreamSetMemory0(i2cp->dmarx, rxbuf);
 8002040:	f10d 090c 	add.w	r9, sp, #12
  /* Releases the lock from high level driver.*/
  osalSysUnlock();

#if STM32_I2C_USE_DMA == TRUE
  /* RX DMA setup.*/
  dmaStreamSetMode(i2cp->dmarx, i2cp->rxdmamode);
 8002044:	601a      	str	r2, [r3, #0]
  dmaStreamSetMemory0(i2cp->dmarx, rxbuf);
  dmaStreamSetTransactionSize(i2cp->dmarx, rxbytes);
 8002046:	2203      	movs	r2, #3
  osalSysUnlock();

#if STM32_I2C_USE_DMA == TRUE
  /* RX DMA setup.*/
  dmaStreamSetMode(i2cp->dmarx, i2cp->rxdmamode);
  dmaStreamSetMemory0(i2cp->dmarx, rxbuf);
 8002048:	f8c3 900c 	str.w	r9, [r3, #12]
  dmaStreamSetTransactionSize(i2cp->dmarx, rxbytes);
 800204c:	605a      	str	r2, [r3, #4]
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {

#if CH_CFG_ST_TIMEDELTA == 0
  return ch.vtlist.vt_systime;
 800204e:	6ab2      	ldr	r2, [r6, #40]	; 0x28
 8002050:	2320      	movs	r3, #32
 8002052:	f383 8811 	msr	BASEPRI, r3
  while (true) {
    osalSysLock();

    /* If the bus is not busy then the operation can continue, note, the
       loop is exited in the locked state.*/
    if ((dp->ISR & I2C_ISR_BUSY) == 0)
 8002056:	69ab      	ldr	r3, [r5, #24]
 8002058:	0419      	lsls	r1, r3, #16
 800205a:	d508      	bpl.n	800206e <Thread4+0x9e>
 800205c:	6ab3      	ldr	r3, [r6, #40]	; 0x28
 */
static inline bool chVTIsTimeWithinX(systime_t time,
                                     systime_t start,
                                     systime_t end) {

  return (bool)((systime_t)(time - start) < (systime_t)(end - start));
 800205e:	1a9b      	subs	r3, r3, r2
      break;

    /* If the system time went outside the allowed window then a timeout
       condition is returned.*/
    if (!osalOsIsTimeWithinX(osalOsGetSystemTimeX(), start, end)) {
 8002060:	f5b3 7ffa 	cmp.w	r3, #500	; 0x1f4
 8002064:	d22c      	bcs.n	80020c0 <Thread4+0xf0>
 8002066:	2300      	movs	r3, #0
 8002068:	f383 8811 	msr	BASEPRI, r3
 800206c:	e7f0      	b.n	8002050 <Thread4+0x80>
 */
static void i2c_lld_set_address(I2CDriver *i2cp, i2caddr_t addr) {
  I2C_TypeDef *dp = i2cp->i2c;

  /* Address alignment depends on the addressing mode selected.*/
  if ((i2cp->config->cr2 & I2C_CR2_ADD10) == 0U)
 800206e:	6862      	ldr	r2, [r4, #4]
 * @param[in] addr      slave device address
 *
 * @notapi
 */
static void i2c_lld_set_address(I2CDriver *i2cp, i2caddr_t addr) {
  I2C_TypeDef *dp = i2cp->i2c;
 8002070:	6b23      	ldr	r3, [r4, #48]	; 0x30

  /* Address alignment depends on the addressing mode selected.*/
  if ((i2cp->config->cr2 & I2C_CR2_ADD10) == 0U)
 8002072:	6892      	ldr	r2, [r2, #8]
  /* Setting up the peripheral.*/
  i2c_lld_setup_rx_transfer(i2cp);

#if STM32_I2C_USE_DMA == TRUE
  /* Enabling RX DMA.*/
  dmaStreamEnable(i2cp->dmarx);
 8002074:	f8df a140 	ldr.w	sl, [pc, #320]	; 80021b8 <Thread4+0x1e8>
 */
static void i2c_lld_set_address(I2CDriver *i2cp, i2caddr_t addr) {
  I2C_TypeDef *dp = i2cp->i2c;

  /* Address alignment depends on the addressing mode selected.*/
  if ((i2cp->config->cr2 & I2C_CR2_ADD10) == 0U)
 8002078:	0512      	lsls	r2, r2, #20
    dp->CR2 = (uint32_t)addr << 1U;
 800207a:	bf54      	ite	pl
 800207c:	2280      	movpl	r2, #128	; 0x80
  else
    dp->CR2 = (uint32_t)addr;
 800207e:	2240      	movmi	r2, #64	; 0x40
 8002080:	605a      	str	r2, [r3, #4]

  /* Setting up the slave address.*/
  i2c_lld_set_address(i2cp, addr);

  /* Setting up the peripheral.*/
  i2c_lld_setup_rx_transfer(i2cp);
 8002082:	f001 fba5 	bl	80037d0 <i2c_lld_setup_rx_transfer.constprop.16>

#if STM32_I2C_USE_DMA == TRUE
  /* Enabling RX DMA.*/
  dmaStreamEnable(i2cp->dmarx);
 8002086:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 8002088:	681a      	ldr	r2, [r3, #0]
 800208a:	6813      	ldr	r3, [r2, #0]
 800208c:	f043 0301 	orr.w	r3, r3, #1
 8002090:	6013      	str	r3, [r2, #0]

  /* Transfer complete interrupt enabled.*/
  dp->CR1 |= I2C_CR1_TCIE;
 8002092:	682b      	ldr	r3, [r5, #0]
 8002094:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 8002098:	602b      	str	r3, [r5, #0]
  /* Transfer complete and RX interrupts enabled.*/
  dp->CR1 |= I2C_CR1_TCIE | I2C_CR1_RXIE;
#endif

  /* Starts the operation.*/
  dp->CR2 |= I2C_CR2_START;
 800209a:	686b      	ldr	r3, [r5, #4]
 800209c:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 80020a0:	606b      	str	r3, [r5, #4]
  *
  * @xclass
  */
static inline thread_t *chThdGetSelfX(void) {

  return ch.rlist.r_current;
 80020a2:	69b3      	ldr	r3, [r6, #24]

  if (TIME_IMMEDIATE == timeout) {
    return MSG_TIMEOUT;
  }

  *trp = tp;
 80020a4:	61e3      	str	r3, [r4, #28]
  tp->p_u.wttrp = trp;
 80020a6:	f10a 021c 	add.w	r2, sl, #28
 80020aa:	621a      	str	r2, [r3, #32]

  return chSchGoSleepTimeoutS(CH_STATE_SUSPENDED, timeout);
 80020ac:	2003      	movs	r0, #3
 80020ae:	2128      	movs	r1, #40	; 0x28
 80020b0:	f7fe fdbe 	bl	8000c30 <chSchGoSleepTimeoutS>
  /* Waits for the operation completion or a timeout.*/
  msg = osalThreadSuspendTimeoutS(&i2cp->thread, timeout);

  /* In case of a software timeout a STOP is sent as an extreme attempt
     to release the bus.*/
  if (msg == MSG_TIMEOUT) {
 80020b4:	1c43      	adds	r3, r0, #1
 80020b6:	d16f      	bne.n	8002198 <Thread4+0x1c8>
    dp->CR2 |= I2C_CR2_STOP;
 80020b8:	686a      	ldr	r2, [r5, #4]
 80020ba:	f442 4280 	orr.w	r2, r2, #16384	; 0x4000
 80020be:	606a      	str	r2, [r5, #4]
  rdymsg = i2c_lld_master_receive_timeout(i2cp, addr, rxbuf, rxbytes, timeout);
  if (rdymsg == MSG_TIMEOUT) {
    i2cp->state = I2C_LOCKED;
 80020c0:	2305      	movs	r3, #5
 80020c2:	7023      	strb	r3, [r4, #0]
 80020c4:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 80020c8:	2300      	movs	r3, #0
 80020ca:	f383 8811 	msr	BASEPRI, r3
		}
		else
		{
			for(retry=0; retry<=150; retry++)
			{
				status = i2cMasterReceiveTimeout(&I2CD1, i2c_device_address, i2c_rx_data, 3, tmo);
 80020ce:	6038      	str	r0, [r7, #0]
				if (status != MSG_OK) {
 80020d0:	bb90      	cbnz	r0, 8002138 <Thread4+0x168>
					errors = i2cGetErrors(&I2CD1);
				}
				else
				{
					tempRHumidity = (((uint16_t) i2c_rx_data[0]) << 8);
					tempRHumidity |= ((uint16_t) i2c_rx_data[1]);
 80020d2:	f89d 200d 	ldrb.w	r2, [sp, #13]
				if (status != MSG_OK) {
					errors = i2cGetErrors(&I2CD1);
				}
				else
				{
					tempRHumidity = (((uint16_t) i2c_rx_data[0]) << 8);
 80020d6:	f89d 300c 	ldrb.w	r3, [sp, #12]
					tempRHumidity |= ((uint16_t) i2c_rx_data[1]);
					rhumidity = (((float_t)tempRHumidity * 125.0) / 65536.0) - 6.0;
 80020da:	ed9f 7a3b 	vldr	s14, [pc, #236]	; 80021c8 <Thread4+0x1f8>
 80020de:	ed9f 8a3b 	vldr	s16, [pc, #236]	; 80021cc <Thread4+0x1fc>
 80020e2:	ea42 2303 	orr.w	r3, r2, r3, lsl #8
 80020e6:	ee07 3a90 	vmov	s15, r3
 80020ea:	eef8 7a67 	vcvt.f32.u32	s15, s15
 80020ee:	4b38      	ldr	r3, [pc, #224]	; (80021d0 <Thread4+0x200>)
 80020f0:	ee67 7a87 	vmul.f32	s15, s15, s14
 80020f4:	eeb9 7a08 	vmov.f32	s14, #152	; 0xc0c00000 -6.0
 80020f8:	eea7 7a88 	vfma.f32	s14, s15, s16
			else
			{ 
				//	chprintf((BaseSequentialStream *)&SD1, "[%010d] Si7006 readout after retry %d\r\n", chVTGetSystemTime(), retry);
				i2c_tx_data[0]=0xE0;   // read temperature value from previous RH measurement
				i2c_tx_data[1]=2;      // nb byte to read
				status = i2cMasterTransmitTimeout(&I2CD1, i2c_device_address, i2c_tx_data, 1, i2c_rx_data, i2c_tx_data[1], tmo);
 80020fc:	2040      	movs	r0, #64	; 0x40
 80020fe:	a902      	add	r1, sp, #8
 8002100:	2201      	movs	r2, #1
				}
				else
				{
					tempRHumidity = (((uint16_t) i2c_rx_data[0]) << 8);
					tempRHumidity |= ((uint16_t) i2c_rx_data[1]);
					rhumidity = (((float_t)tempRHumidity * 125.0) / 65536.0) - 6.0;
 8002102:	ed83 7a00 	vstr	s14, [r3]
				chprintf((BaseSequentialStream *)&SD1, "[%010d] i2c read error : %02.2x at address %02.2x\r\n", chVTGetSystemTime(), errors, i2c_device_address);
			}
			else
			{ 
				//	chprintf((BaseSequentialStream *)&SD1, "[%010d] Si7006 readout after retry %d\r\n", chVTGetSystemTime(), retry);
				i2c_tx_data[0]=0xE0;   // read temperature value from previous RH measurement
 8002106:	23e0      	movs	r3, #224	; 0xe0
 8002108:	f88d 3008 	strb.w	r3, [sp, #8]
				i2c_tx_data[1]=2;      // nb byte to read
 800210c:	2302      	movs	r3, #2
 800210e:	f88d 3009 	strb.w	r3, [sp, #9]
				status = i2cMasterTransmitTimeout(&I2CD1, i2c_device_address, i2c_tx_data, 1, i2c_rx_data, i2c_tx_data[1], tmo);
 8002112:	9300      	str	r3, [sp, #0]
 8002114:	464b      	mov	r3, r9
 8002116:	f001 fafb 	bl	8003710 <i2cMasterTransmitTimeout.constprop.17>
 800211a:	4b26      	ldr	r3, [pc, #152]	; (80021b4 <Thread4+0x1e4>)
 800211c:	6018      	str	r0, [r3, #0]
				if (status != MSG_OK) {
 800211e:	b1f0      	cbz	r0, 800215e <Thread4+0x18e>
					errors = i2cGetErrors(&I2CD1);
 8002120:	4b26      	ldr	r3, [pc, #152]	; (80021bc <Thread4+0x1ec>)
 */
i2cflags_t i2cGetErrors(I2CDriver *i2cp) {

  osalDbgCheck(i2cp != NULL);

  return i2c_lld_get_errors(i2cp);
 8002122:	68a4      	ldr	r4, [r4, #8]
 8002124:	601c      	str	r4, [r3, #0]
					chprintf((BaseSequentialStream *)&SD1, "[%010d] i2c error : %02.2x at address %02.2x\r\n", chVTGetSystemTime(), errors, i2c_device_address);
 8002126:	f001 f97b 	bl	8003420 <chVTGetSystemTime.lto_priv.80>
 800212a:	2340      	movs	r3, #64	; 0x40
 800212c:	4602      	mov	r2, r0
 800212e:	4929      	ldr	r1, [pc, #164]	; (80021d4 <Thread4+0x204>)
 8002130:	4823      	ldr	r0, [pc, #140]	; (80021c0 <Thread4+0x1f0>)
 8002132:	9300      	str	r3, [sp, #0]
 8002134:	4623      	mov	r3, r4
 8002136:	e033      	b.n	80021a0 <Thread4+0x1d0>
		{
			for(retry=0; retry<=150; retry++)
			{
				status = i2cMasterReceiveTimeout(&I2CD1, i2c_device_address, i2c_rx_data, 3, tmo);
				if (status != MSG_OK) {
					errors = i2cGetErrors(&I2CD1);
 8002138:	4d20      	ldr	r5, [pc, #128]	; (80021bc <Thread4+0x1ec>)
 800213a:	68a3      	ldr	r3, [r4, #8]
 800213c:	602b      	str	r3, [r5, #0]
					tempRHumidity = (((uint16_t) i2c_rx_data[0]) << 8);
					tempRHumidity |= ((uint16_t) i2c_rx_data[1]);
					rhumidity = (((float_t)tempRHumidity * 125.0) / 65536.0) - 6.0;
					break;
				}
				chThdSleepMilliseconds(1);
 800213e:	200a      	movs	r0, #10
 8002140:	f7fe fece 	bl	8000ee0 <chThdSleep>
			errors = i2cGetErrors(&I2CD1);
			chprintf((BaseSequentialStream *)&SD1, "[%010d] i2c write error : %02.2x at address %02.2x\r\n", chVTGetSystemTime(), errors, i2c_device_address); 
		}
		else
		{
			for(retry=0; retry<=150; retry++)
 8002144:	f1b8 0801 	subs.w	r8, r8, #1
 8002148:	f47f af6d 	bne.w	8002026 <Thread4+0x56>
				}
				chThdSleepMilliseconds(1);
			}
			if(retry > 150)
			{
				chprintf((BaseSequentialStream *)&SD1, "[%010d] i2c read error : %02.2x at address %02.2x\r\n", chVTGetSystemTime(), errors, i2c_device_address);
 800214c:	f001 f968 	bl	8003420 <chVTGetSystemTime.lto_priv.80>
 8002150:	2340      	movs	r3, #64	; 0x40
 8002152:	9300      	str	r3, [sp, #0]
 8002154:	4602      	mov	r2, r0
 8002156:	4920      	ldr	r1, [pc, #128]	; (80021d8 <Thread4+0x208>)
 8002158:	4819      	ldr	r0, [pc, #100]	; (80021c0 <Thread4+0x1f0>)
 800215a:	682b      	ldr	r3, [r5, #0]
 800215c:	e020      	b.n	80021a0 <Thread4+0x1d0>
					errors = i2cGetErrors(&I2CD1);
					chprintf((BaseSequentialStream *)&SD1, "[%010d] i2c error : %02.2x at address %02.2x\r\n", chVTGetSystemTime(), errors, i2c_device_address);
				}
				else
				{
					tempTemperature = (((uint16_t) i2c_rx_data[0]) << 8);
 800215e:	f89d 200c 	ldrb.w	r2, [sp, #12]
					tempTemperature |= ((uint16_t) i2c_rx_data[1]);
 8002162:	f89d 300d 	ldrb.w	r3, [sp, #13]
					temperature2 = (((float_t)tempTemperature * 175.72) / 65536.0) - 46.85;
 8002166:	ed9f 7a1d 	vldr	s14, [pc, #116]	; 80021dc <Thread4+0x20c>
 800216a:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 800216e:	ee07 3a90 	vmov	s15, r3
 8002172:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8002176:	4b1a      	ldr	r3, [pc, #104]	; (80021e0 <Thread4+0x210>)
 8002178:	ee67 7a87 	vmul.f32	s15, s15, s14
 800217c:	ed9f 7a19 	vldr	s14, [pc, #100]	; 80021e4 <Thread4+0x214>
 8002180:	eea7 7a88 	vfma.f32	s14, s15, s16
 8002184:	ed83 7a00 	vstr	s14, [r3]
 * @api
 */
static inline void osalMutexUnlock(mutex_t *mp) {

#if CH_CFG_USE_MUTEXES
  chMtxUnlock(mp);
 8002188:	4809      	ldr	r0, [pc, #36]	; (80021b0 <Thread4+0x1e0>)
 800218a:	f7fe fef1 	bl	8000f70 <chMtxUnlock>
				}
			}
		}
		i2cReleaseBus(&I2CD1);
		chThdSleepMilliseconds(1050);
 800218e:	f642 1004 	movw	r0, #10500	; 0x2904
 8002192:	f7fe fea5 	bl	8000ee0 <chThdSleep>
 8002196:	e726      	b.n	8001fe6 <Thread4+0x16>
  rdymsg = i2c_lld_master_receive_timeout(i2cp, addr, rxbuf, rxbytes, timeout);
  if (rdymsg == MSG_TIMEOUT) {
    i2cp->state = I2C_LOCKED;
  }
  else {
    i2cp->state = I2C_READY;
 8002198:	2302      	movs	r3, #2
 800219a:	f88a 3000 	strb.w	r3, [sl]
 800219e:	e793      	b.n	80020c8 <Thread4+0xf8>
				}
				chThdSleepMilliseconds(1);
			}
			if(retry > 150)
			{
				chprintf((BaseSequentialStream *)&SD1, "[%010d] i2c read error : %02.2x at address %02.2x\r\n", chVTGetSystemTime(), errors, i2c_device_address);
 80021a0:	f000 fece 	bl	8002f40 <chprintf.lto_priv.79>
 80021a4:	e7f0      	b.n	8002188 <Thread4+0x1b8>
 80021a6:	bf00      	nop
 80021a8:	20001a00 	.word	0x20001a00
 80021ac:	08003def 	.word	0x08003def
 80021b0:	20001be4 	.word	0x20001be4
 80021b4:	20000f80 	.word	0x20000f80
 80021b8:	20001bd8 	.word	0x20001bd8
 80021bc:	2000120c 	.word	0x2000120c
 80021c0:	20000e88 	.word	0x20000e88
 80021c4:	08003dfd 	.word	0x08003dfd
 80021c8:	42fa0000 	.word	0x42fa0000
 80021cc:	37800000 	.word	0x37800000
 80021d0:	20001210 	.word	0x20001210
 80021d4:	08003e32 	.word	0x08003e32
 80021d8:	08003e61 	.word	0x08003e61
 80021dc:	432fb852 	.word	0x432fb852
 80021e0:	20001260 	.word	0x20001260
 80021e4:	c23b6666 	.word	0xc23b6666
	...

080021f0 <main>:
}

/*
 * Application entry point.
 */
int main(void) {
 80021f0:	e92d 4880 	stmdb	sp!, {r7, fp, lr}
 * @notapi
 */
void hal_lld_init(void) {

  /* Reset of all peripherals.*/
  rccResetAHB(0xFFFFFFFF);
 80021f4:	4fb2      	ldr	r7, [pc, #712]	; (80024c0 <main+0x2d0>)
 80021f6:	f04f 32ff 	mov.w	r2, #4294967295	; 0xffffffff
 80021fa:	6abb      	ldr	r3, [r7, #40]	; 0x28
 80021fc:	62ba      	str	r2, [r7, #40]	; 0x28
 80021fe:	2300      	movs	r3, #0
 8002200:	62bb      	str	r3, [r7, #40]	; 0x28
  rccResetAPB1(0xFFFFFFFF);
 8002202:	6939      	ldr	r1, [r7, #16]
 8002204:	613a      	str	r2, [r7, #16]
 8002206:	613b      	str	r3, [r7, #16]
  rccResetAPB2(0xFFFFFFFF);
 8002208:	68f9      	ldr	r1, [r7, #12]
 800220a:	60fa      	str	r2, [r7, #12]
 800220c:	60fb      	str	r3, [r7, #12]

  /* PWR clock enabled.*/
  rccEnablePWRInterface(FALSE);
 800220e:	69fa      	ldr	r2, [r7, #28]
 *          of the whole BKP domain.
 */
static void hal_lld_backup_domain_init(void) {

  /* Backup domain access enabled and left open.*/
  PWR->CR |= PWR_CR_DBP;
 8002210:	49ac      	ldr	r1, [pc, #688]	; (80024c4 <main+0x2d4>)
  rccResetAHB(0xFFFFFFFF);
  rccResetAPB1(0xFFFFFFFF);
  rccResetAPB2(0xFFFFFFFF);

  /* PWR clock enabled.*/
  rccEnablePWRInterface(FALSE);
 8002212:	f042 5280 	orr.w	r2, r2, #268435456	; 0x10000000
 8002216:	61fa      	str	r2, [r7, #28]
 *          of the whole BKP domain.
 */
static void hal_lld_backup_domain_init(void) {

  /* Backup domain access enabled and left open.*/
  PWR->CR |= PWR_CR_DBP;
 8002218:	680a      	ldr	r2, [r1, #0]
 800221a:	f442 7280 	orr.w	r2, r2, #256	; 0x100
 800221e:	600a      	str	r2, [r1, #0]

  /* Reset BKP domain if different clock source selected.*/
  if ((RCC->BDCR & STM32_RTCSEL_MASK) != STM32_RTCSEL){
 8002220:	6a3a      	ldr	r2, [r7, #32]
 8002222:	f402 7240 	and.w	r2, r2, #768	; 0x300
 8002226:	f5b2 7f00 	cmp.w	r2, #512	; 0x200
    /* Backup domain reset.*/
    RCC->BDCR = RCC_BDCR_BDRST;
 800222a:	bf1e      	ittt	ne
 800222c:	f44f 3280 	movne.w	r2, #65536	; 0x10000
 8002230:	623a      	strne	r2, [r7, #32]
    RCC->BDCR = 0;
 8002232:	623b      	strne	r3, [r7, #32]
#endif

#if STM32_RTCSEL != STM32_RTCSEL_NOCLOCK
  /* If the backup domain hasn't been initialized yet then proceed with
     initialization.*/
  if ((RCC->BDCR & RCC_BDCR_RTCEN) == 0) {
 8002234:	6a3a      	ldr	r2, [r7, #32]
 8002236:	4ba2      	ldr	r3, [pc, #648]	; (80024c0 <main+0x2d0>)
 8002238:	0410      	lsls	r0, r2, #16
    /* Selects clock source.*/
    RCC->BDCR |= STM32_RTCSEL;
 800223a:	bf5f      	itttt	pl
 800223c:	6a1a      	ldrpl	r2, [r3, #32]
 800223e:	f442 7200 	orrpl.w	r2, r2, #512	; 0x200
 8002242:	621a      	strpl	r2, [r3, #32]

    /* RTC clock enabled.*/
    RCC->BDCR |= RCC_BDCR_RTCEN;
 8002244:	6a1a      	ldrpl	r2, [r3, #32]
 8002246:	bf5c      	itt	pl
 8002248:	f442 4200 	orrpl.w	r2, r2, #32768	; 0x8000
 800224c:	621a      	strpl	r2, [r3, #32]
 * @init
 */
void dmaInit(void) {
  int i;

  dma_streams_mask = 0;
 800224e:	4a9e      	ldr	r2, [pc, #632]	; (80024c8 <main+0x2d8>)
 8002250:	2300      	movs	r3, #0
 8002252:	b08d      	sub	sp, #52	; 0x34
 8002254:	6013      	str	r3, [r2, #0]
 8002256:	220c      	movs	r2, #12
 8002258:	435a      	muls	r2, r3
  for (i = 0; i < STM32_DMA_STREAMS; i++) {
    _stm32_dma_streams[i].channel->CCR = 0;
 800225a:	4c9c      	ldr	r4, [pc, #624]	; (80024cc <main+0x2dc>)
 800225c:	5912      	ldr	r2, [r2, r4]
 800225e:	2500      	movs	r5, #0
 8002260:	6015      	str	r5, [r2, #0]
    dma_isr_redir[i].dma_func = NULL;
 8002262:	4a9b      	ldr	r2, [pc, #620]	; (80024d0 <main+0x2e0>)
 8002264:	f842 5033 	str.w	r5, [r2, r3, lsl #3]
 */
void dmaInit(void) {
  int i;

  dma_streams_mask = 0;
  for (i = 0; i < STM32_DMA_STREAMS; i++) {
 8002268:	3301      	adds	r3, #1
 800226a:	2b0c      	cmp	r3, #12
 800226c:	d1f3      	bne.n	8002256 <main+0x66>
    _stm32_dma_streams[i].channel->CCR = 0;
    dma_isr_redir[i].dma_func = NULL;
  }
  DMA1->IFCR = 0xFFFFFFFF;
 800226e:	4b99      	ldr	r3, [pc, #612]	; (80024d4 <main+0x2e4>)
     among multiple drivers.*/
  rccEnableAPB2(RCC_APB2ENR_SYSCFGEN, TRUE);

#if STM32_HAS_USB
  /* USB IRQ relocated to not conflict with CAN.*/
  SYSCFG->CFGR1 |= SYSCFG_CFGR1_USB_IT_RMP;
 8002270:	4a99      	ldr	r2, [pc, #612]	; (80024d8 <main+0x2e8>)

  /*
   * Initial GPIO setup.
   */
#if STM32_HAS_GPIOA
  initgpio(GPIOA, &config->PAData);
 8002272:	499a      	ldr	r1, [pc, #616]	; (80024dc <main+0x2ec>)
 *
 * @init
 */
void adcObjectInit(ADCDriver *adcp) {

  adcp->state    = ADC_STOP;
 8002274:	4e9a      	ldr	r6, [pc, #616]	; (80024e0 <main+0x2f0>)

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8002276:	f8df 92e8 	ldr.w	r9, [pc, #744]	; 8002560 <main+0x370>
void sd_lld_init(void) {

#if STM32_SERIAL_USE_USART1
  sdObjectInit(&SD1, NULL, notify1);
  SD1.usart = USART1;
  SD1.clock = STM32_USART1CLK;
 800227a:	f8df a2e8 	ldr.w	sl, [pc, #744]	; 8002564 <main+0x374>
  PWR->CR |= PWR_CR_PVDE | (STM32_PLS & STM32_PLS_MASK);
#endif /* STM32_PVD_ENABLE */

  /* SYSCFG clock enabled here because it is a multi-functional unit shared
     among multiple drivers.*/
  rccEnableAPB2(RCC_APB2ENR_SYSCFGEN, TRUE);
 800227e:	f8df b240 	ldr.w	fp, [pc, #576]	; 80024c0 <main+0x2d0>
 8002282:	f04f 38ff 	mov.w	r8, #4294967295	; 0xffffffff
 8002286:	f8c3 8004 	str.w	r8, [r3, #4]
#if STM32_HAS_DMA2
  DMA2->IFCR = 0xFFFFFFFF;
 800228a:	f8c3 8404 	str.w	r8, [r3, #1028]	; 0x404
 800228e:	69bb      	ldr	r3, [r7, #24]
 8002290:	f043 0301 	orr.w	r3, r3, #1
 8002294:	61bb      	str	r3, [r7, #24]

#if STM32_HAS_USB
  /* USB IRQ relocated to not conflict with CAN.*/
  SYSCFG->CFGR1 |= SYSCFG_CFGR1_USB_IT_RMP;
 8002296:	6813      	ldr	r3, [r2, #0]
 8002298:	f043 0320 	orr.w	r3, r3, #32
 800229c:	6013      	str	r3, [r2, #0]
  rccEnableAHB(AHB_EN_MASK, TRUE);
  RCC->AHBLPENR |= AHB_LPEN_MASK;
#elif defined(STM32F0XX)
  rccEnableAHB(AHB_EN_MASK, TRUE);
#elif defined(STM32F3XX) || defined(STM32F37X)
  rccEnableAHB(AHB_EN_MASK, TRUE);
 800229e:	697b      	ldr	r3, [r7, #20]
 80022a0:	f443 03fc 	orr.w	r3, r3, #8257536	; 0x7e0000
 80022a4:	617b      	str	r3, [r7, #20]

  /*
   * Initial GPIO setup.
   */
#if STM32_HAS_GPIOA
  initgpio(GPIOA, &config->PAData);
 80022a6:	f04f 4090 	mov.w	r0, #1207959552	; 0x48000000
 80022aa:	f7ff fe59 	bl	8001f60 <initgpio.lto_priv.81>
#endif
#if STM32_HAS_GPIOB
  initgpio(GPIOB, &config->PBData);
 80022ae:	488d      	ldr	r0, [pc, #564]	; (80024e4 <main+0x2f4>)
 80022b0:	498d      	ldr	r1, [pc, #564]	; (80024e8 <main+0x2f8>)
 80022b2:	f7ff fe55 	bl	8001f60 <initgpio.lto_priv.81>
#endif
#if STM32_HAS_GPIOC
  initgpio(GPIOC, &config->PCData);
 80022b6:	488d      	ldr	r0, [pc, #564]	; (80024ec <main+0x2fc>)
 80022b8:	498d      	ldr	r1, [pc, #564]	; (80024f0 <main+0x300>)
 80022ba:	f7ff fe51 	bl	8001f60 <initgpio.lto_priv.81>
#endif
#if STM32_HAS_GPIOD
  initgpio(GPIOD, &config->PDData);
 80022be:	488d      	ldr	r0, [pc, #564]	; (80024f4 <main+0x304>)
 80022c0:	498d      	ldr	r1, [pc, #564]	; (80024f8 <main+0x308>)
 80022c2:	f7ff fe4d 	bl	8001f60 <initgpio.lto_priv.81>
#endif
#if STM32_HAS_GPIOE
  initgpio(GPIOE, &config->PEData);
 80022c6:	488d      	ldr	r0, [pc, #564]	; (80024fc <main+0x30c>)
 80022c8:	498d      	ldr	r1, [pc, #564]	; (8002500 <main+0x310>)
 80022ca:	f7ff fe49 	bl	8001f60 <initgpio.lto_priv.81>
#endif
#if STM32_HAS_GPIOF
  initgpio(GPIOF, &config->PFData);
 80022ce:	488d      	ldr	r0, [pc, #564]	; (8002504 <main+0x314>)
 80022d0:	498d      	ldr	r1, [pc, #564]	; (8002508 <main+0x318>)
 80022d2:	f7ff fe45 	bl	8001f60 <initgpio.lto_priv.81>
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 80022d6:	f106 0318 	add.w	r3, r6, #24
 80022da:	61b3      	str	r3, [r6, #24]
  tqp->p_prev = (thread_t *)tqp;
 80022dc:	61f3      	str	r3, [r6, #28]

#if STM32_ADC_USE_ADC1
  /* Driver initialization.*/
  adcObjectInit(&ADCD1);
#if defined(ADC1_2_COMMON)
  ADCD1.adcc = ADC1_2_COMMON;
 80022de:	4b8b      	ldr	r3, [pc, #556]	; (800250c <main+0x31c>)
 80022e0:	62b3      	str	r3, [r6, #40]	; 0x28
#else
  ADCD1.adcc = ADC1_COMMON;
#endif
  ADCD1.adcm = ADC1;
 80022e2:	f04f 43a0 	mov.w	r3, #1342177280	; 0x50000000
 80022e6:	62f3      	str	r3, [r6, #44]	; 0x2c
#if STM32_ADC_DUAL_MODE
  ADCD1.adcs = ADC2;
 80022e8:	f503 7380 	add.w	r3, r3, #256	; 0x100
 80022ec:	6333      	str	r3, [r6, #48]	; 0x30
 80022ee:	2201      	movs	r2, #1
 80022f0:	2150      	movs	r1, #80	; 0x50
#endif
  ADCD1.dmastp  = STM32_DMA1_STREAM1;
  ADCD1.dmamode = ADC_DMA_SIZE |
 80022f2:	f642 208a 	movw	r0, #10890	; 0x2a8a
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 80022f6:	f44f 2380 	mov.w	r3, #262144	; 0x40000
 80022fa:	7032      	strb	r2, [r6, #0]
 80022fc:	63b0      	str	r0, [r6, #56]	; 0x38
#endif
  ADCD1.adcm = ADC1;
#if STM32_ADC_DUAL_MODE
  ADCD1.adcs = ADC2;
#endif
  ADCD1.dmastp  = STM32_DMA1_STREAM1;
 80022fe:	6374      	str	r4, [r6, #52]	; 0x34
  adcp->config   = NULL;
 8002300:	6075      	str	r5, [r6, #4]
  adcp->samples  = NULL;
 8002302:	60b5      	str	r5, [r6, #8]
  adcp->depth    = 0;
 8002304:	60f5      	str	r5, [r6, #12]
  adcp->grpp     = NULL;
 8002306:	6135      	str	r5, [r6, #16]
#if ADC_USE_WAIT == TRUE
  adcp->thread   = NULL;
 8002308:	6175      	str	r5, [r6, #20]
 800230a:	6235      	str	r5, [r6, #32]

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 800230c:	f889 1312 	strb.w	r1, [r9, #786]	; 0x312
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8002310:	f8c9 3180 	str.w	r3, [r9, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8002314:	f8c9 3000 	str.w	r3, [r9]
 *
 * @init
 */
void adcObjectInit(ADCDriver *adcp) {

  adcp->state    = ADC_STOP;
 8002318:	4b7d      	ldr	r3, [pc, #500]	; (8002510 <main+0x320>)
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 800231a:	f103 0e18 	add.w	lr, r3, #24
 800231e:	f8c3 e018 	str.w	lr, [r3, #24]
  tqp->p_prev = (thread_t *)tqp;
 8002322:	f8c3 e01c 	str.w	lr, [r3, #28]

#if STM32_ADC_USE_ADC3
  /* Driver initialization.*/
  adcObjectInit(&ADCD3);
#if defined(ADC3_4_COMMON)
  ADCD3.adcc = ADC3_4_COMMON;
 8002326:	f8df e240 	ldr.w	lr, [pc, #576]	; 8002568 <main+0x378>
 800232a:	f8c3 e028 	str.w	lr, [r3, #40]	; 0x28
#else
  ADCD3.adcc = ADC3_COMMON;
#endif
  ADCD3.adcm = ADC3;
 800232e:	f5ae 7e40 	sub.w	lr, lr, #768	; 0x300
 8002332:	f8c3 e02c 	str.w	lr, [r3, #44]	; 0x2c
#if STM32_ADC_DUAL_MODE
  ADCD3.adcs = ADC4;
#endif
  ADCD3.dmastp  = STM32_DMA2_STREAM5;
 8002336:	3484      	adds	r4, #132	; 0x84
#else
  ADCD3.adcc = ADC3_COMMON;
#endif
  ADCD3.adcm = ADC3;
#if STM32_ADC_DUAL_MODE
  ADCD3.adcs = ADC4;
 8002338:	f50e 7e80 	add.w	lr, lr, #256	; 0x100
 800233c:	f8c3 e030 	str.w	lr, [r3, #48]	; 0x30
 8002340:	701a      	strb	r2, [r3, #0]
#endif
  ADCD3.dmastp  = STM32_DMA2_STREAM5;
  ADCD3.dmamode = ADC_DMA_SIZE |
 8002342:	6398      	str	r0, [r3, #56]	; 0x38
  adcp->config   = NULL;
 8002344:	605d      	str	r5, [r3, #4]
  adcp->samples  = NULL;
 8002346:	609d      	str	r5, [r3, #8]
  adcp->depth    = 0;
 8002348:	60dd      	str	r5, [r3, #12]
  adcp->grpp     = NULL;
 800234a:	611d      	str	r5, [r3, #16]
#if ADC_USE_WAIT == TRUE
  adcp->thread   = NULL;
 800234c:	615d      	str	r5, [r3, #20]
 800234e:	621d      	str	r5, [r3, #32]
#endif
  ADCD3.adcm = ADC3;
#if STM32_ADC_DUAL_MODE
  ADCD3.adcs = ADC4;
#endif
  ADCD3.dmastp  = STM32_DMA2_STREAM5;
 8002350:	635c      	str	r4, [r3, #52]	; 0x34
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8002352:	f44f 4300 	mov.w	r3, #32768	; 0x8000

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8002356:	f889 132f 	strb.w	r1, [r9, #815]	; 0x32f
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 800235a:	f8c9 3184 	str.w	r3, [r9, #388]	; 0x184
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 800235e:	f8c9 3004 	str.w	r3, [r9, #4]
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8002362:	f04f 5300 	mov.w	r3, #536870912	; 0x20000000

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 8002366:	f889 133d 	strb.w	r1, [r9, #829]	; 0x33d
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 800236a:	f8c9 3184 	str.w	r3, [r9, #388]	; 0x184
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 800236e:	f8c9 3004 	str.w	r3, [r9, #4]
 *
 * @init
 */
void extObjectInit(EXTDriver *extp) {

  extp->state  = EXT_STOP;
 8002372:	4b68      	ldr	r3, [pc, #416]	; (8002514 <main+0x324>)
 8002374:	9204      	str	r2, [sp, #16]
 8002376:	701a      	strb	r2, [r3, #0]
  extp->config = NULL;
 8002378:	605d      	str	r5, [r3, #4]
 *
 * @init
 */
void i2cInit(void) {

  i2c_lld_init();
 800237a:	f7ff fdd9 	bl	8001f30 <i2c_lld_init>
 *
 * @init
 */
void pwmObjectInit(PWMDriver *pwmp) {

  pwmp->state    = PWM_STOP;
 800237e:	4b66      	ldr	r3, [pc, #408]	; (8002518 <main+0x328>)
 8002380:	9a04      	ldr	r2, [sp, #16]
#endif

#if STM32_SERIAL_USE_USART2
  sdObjectInit(&SD2, NULL, notify2);
 8002382:	4c66      	ldr	r4, [pc, #408]	; (800251c <main+0x32c>)
 * @notapi
 */
void sd_lld_init(void) {

#if STM32_SERIAL_USE_USART1
  sdObjectInit(&SD1, NULL, notify1);
 8002384:	4866      	ldr	r0, [pc, #408]	; (8002520 <main+0x330>)
 8002386:	701a      	strb	r2, [r3, #0]
#endif

#if STM32_PWM_USE_TIM3
  /* Driver initialization.*/
  pwmObjectInit(&PWMD3);
  PWMD3.channels = STM32_TIM3_CHANNELS;
 8002388:	2104      	movs	r1, #4
 800238a:	7419      	strb	r1, [r3, #16]
  PWMD3.tim = STM32_TIM3;
 800238c:	4965      	ldr	r1, [pc, #404]	; (8002524 <main+0x334>)
 800238e:	6199      	str	r1, [r3, #24]
 8002390:	4965      	ldr	r1, [pc, #404]	; (8002528 <main+0x338>)
 8002392:	9205      	str	r2, [sp, #20]
  pwmp->config   = NULL;
 8002394:	605d      	str	r5, [r3, #4]
  pwmp->enabled  = 0;
 8002396:	60dd      	str	r5, [r3, #12]
 8002398:	f001 f91a 	bl	80035d0 <sdObjectInit.constprop.37>
  SD1.usart = USART1;
 800239c:	4a60      	ldr	r2, [pc, #384]	; (8002520 <main+0x330>)
 800239e:	4b63      	ldr	r3, [pc, #396]	; (800252c <main+0x33c>)
  SD1.clock = STM32_USART1CLK;
#endif

#if STM32_SERIAL_USE_USART2
  sdObjectInit(&SD2, NULL, notify2);
 80023a0:	4963      	ldr	r1, [pc, #396]	; (8002530 <main+0x340>)
 */
void sd_lld_init(void) {

#if STM32_SERIAL_USE_USART1
  sdObjectInit(&SD1, NULL, notify1);
  SD1.usart = USART1;
 80023a2:	6753      	str	r3, [r2, #116]	; 0x74
  SD1.clock = STM32_USART1CLK;
#endif

#if STM32_SERIAL_USE_USART2
  sdObjectInit(&SD2, NULL, notify2);
 80023a4:	4620      	mov	r0, r4
void sd_lld_init(void) {

#if STM32_SERIAL_USE_USART1
  sdObjectInit(&SD1, NULL, notify1);
  SD1.usart = USART1;
  SD1.clock = STM32_USART1CLK;
 80023a6:	f8c2 a078 	str.w	sl, [r2, #120]	; 0x78
#endif

#if STM32_SERIAL_USE_USART2
  sdObjectInit(&SD2, NULL, notify2);
 80023aa:	f001 f911 	bl	80035d0 <sdObjectInit.constprop.37>
  SD2.usart = USART2;
 80023ae:	4b61      	ldr	r3, [pc, #388]	; (8002534 <main+0x344>)
 80023b0:	6763      	str	r3, [r4, #116]	; 0x74
#endif /* OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING */

#if OSAL_ST_MODE == OSAL_ST_MODE_PERIODIC
  /* Periodic systick mode, the Cortex-Mx internal systick timer is used
     in this mode.*/
  SysTick->LOAD = (STM32_HCLK / OSAL_ST_FREQUENCY) - 1;
 80023b2:	4b61      	ldr	r3, [pc, #388]	; (8002538 <main+0x348>)
  SD2.clock = STM32_USART2CLK;
 80023b4:	f8c4 a078 	str.w	sl, [r4, #120]	; 0x78
 80023b8:	f241 21bf 	movw	r1, #4799	; 0x12bf
 80023bc:	6059      	str	r1, [r3, #4]
  SysTick->VAL = 0;
  SysTick->CTRL = SysTick_CTRL_CLKSOURCE_Msk |
 80023be:	2107      	movs	r1, #7

#if OSAL_ST_MODE == OSAL_ST_MODE_PERIODIC
  /* Periodic systick mode, the Cortex-Mx internal systick timer is used
     in this mode.*/
  SysTick->LOAD = (STM32_HCLK / OSAL_ST_FREQUENCY) - 1;
  SysTick->VAL = 0;
 80023c0:	609d      	str	r5, [r3, #8]
  SysTick->CTRL = SysTick_CTRL_CLKSOURCE_Msk |
 80023c2:	6019      	str	r1, [r3, #0]
  SCB->SHP[_SHP_IDX(handler)] = (SCB->SHP[_SHP_IDX(handler)] & ~(0xFFU << _BIT_SHIFT(handler))) |
                                (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(handler));
#elif defined(__CORE_CM7_H_GENERIC)
  SCB->SHPR[handler] = NVIC_PRIORITY_MASK(prio);
#else
  SCB->SHP[handler] = NVIC_PRIORITY_MASK(prio);
 80023c4:	2180      	movs	r1, #128	; 0x80
 80023c6:	f883 1d13 	strb.w	r1, [r3, #3347]	; 0xd13
 * @brief   Port-related initialization code.
 */
static inline void port_init(void) {

  /* Initialization of the vector table and priority related settings.*/
  SCB->VTOR = CORTEX_VTOR_INIT;
 80023ca:	f8c3 5cf8 	str.w	r5, [r3, #3320]	; 0xcf8
__STATIC_INLINE void NVIC_SetPriorityGrouping(uint32_t PriorityGroup)
{
  uint32_t reg_value;
  uint32_t PriorityGroupTmp = (PriorityGroup & (uint32_t)0x07);               /* only values 0..7 are used          */

  reg_value  =  SCB->AIRCR;                                                   /* read old register configuration    */
 80023ce:	f8d3 1cfc 	ldr.w	r1, [r3, #3324]	; 0xcfc
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 80023d2:	4c5a      	ldr	r4, [pc, #360]	; (800253c <main+0x34c>)
  reg_value &= ~(SCB_AIRCR_VECTKEY_Msk | SCB_AIRCR_PRIGROUP_Msk);             /* clear bits to change               */
 80023d4:	f64f 00ff 	movw	r0, #63743	; 0xf8ff
 80023d8:	4008      	ands	r0, r1
  reg_value  =  (reg_value                                 |
 80023da:	4959      	ldr	r1, [pc, #356]	; (8002540 <main+0x350>)
 80023dc:	4301      	orrs	r1, r0

  /* Initializing priority grouping.*/
  NVIC_SetPriorityGrouping(CORTEX_PRIGROUP_INIT);

  /* DWT cycle counter enable.*/
  CoreDebug->DEMCR |= CoreDebug_DEMCR_TRCENA_Msk;
 80023de:	4859      	ldr	r0, [pc, #356]	; (8002544 <main+0x354>)
                ((uint32_t)0x5FA << SCB_AIRCR_VECTKEY_Pos) |
                (PriorityGroupTmp << 8));                                     /* Insert write key and priorty group */
  SCB->AIRCR =  reg_value;
 80023e0:	f8c3 1cfc 	str.w	r1, [r3, #3324]	; 0xcfc
 80023e4:	68c1      	ldr	r1, [r0, #12]
 80023e6:	f041 7180 	orr.w	r1, r1, #16777216	; 0x1000000
 80023ea:	60c1      	str	r1, [r0, #12]
  DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
 80023ec:	4856      	ldr	r0, [pc, #344]	; (8002548 <main+0x358>)
 80023ee:	6801      	ldr	r1, [r0, #0]
 80023f0:	f041 0101 	orr.w	r1, r1, #1
 80023f4:	6001      	str	r1, [r0, #0]
    \param [in]  priority  Priority to set.
 */
__STATIC_INLINE void NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if(IRQn < 0) {
    SCB->SHP[((uint32_t)(IRQn) & 0xF)-4] = ((priority << (8 - __NVIC_PRIO_BITS)) & 0xff); } /* set Priority for Cortex-M  System Interrupts */
 80023f6:	2110      	movs	r1, #16
 80023f8:	f883 1d0f 	strb.w	r1, [r3, #3343]	; 0xd0f
 80023fc:	f04f 0c20 	mov.w	ip, #32

  tmp->best       = (rtcnt_t)-1;
  tmp->worst      = (rtcnt_t)0;
  tmp->last       = (rtcnt_t)0;
  tmp->n          = (ucnt_t)0;
  tmp->cumulative = (rttime_t)0;
 8002400:	2100      	movs	r1, #0
  /* Time Measurement subsystem calibration, it does a null measurement
     and calculates the call overhead which is subtracted to real
     measurements.*/
  ch.tm.offset = (rtcnt_t)0;
  chTMObjectInit(&tm);
  chTMStartMeasurementX(&tm);
 8002402:	f10d 0a18 	add.w	sl, sp, #24

  tmp->best       = (rtcnt_t)-1;
  tmp->worst      = (rtcnt_t)0;
  tmp->last       = (rtcnt_t)0;
  tmp->n          = (ucnt_t)0;
  tmp->cumulative = (rttime_t)0;
 8002406:	2000      	movs	r0, #0
 8002408:	f883 cd12 	strb.w	ip, [r3, #3346]	; 0xd12
 *
 * @notapi
 */
void _vt_init(void) {

  ch.vtlist.vt_next = (virtual_timer_t *)&ch.vtlist;
 800240c:	f104 031c 	add.w	r3, r4, #28
 8002410:	e9cd 010a 	strd	r0, r1, [sp, #40]	; 0x28
 8002414:	6024      	str	r4, [r4, #0]
  /* Time Measurement subsystem calibration, it does a null measurement
     and calculates the call overhead which is subtracted to real
     measurements.*/
  ch.tm.offset = (rtcnt_t)0;
  chTMObjectInit(&tm);
  chTMStartMeasurementX(&tm);
 8002416:	4650      	mov	r0, sl
  tqp->p_prev = (thread_t *)tqp;
 8002418:	6064      	str	r4, [r4, #4]
 800241a:	61e3      	str	r3, [r4, #28]
  ch.vtlist.vt_prev = (virtual_timer_t *)&ch.vtlist;
 800241c:	6223      	str	r3, [r4, #32]
 800241e:	f8cd c010 	str.w	ip, [sp, #16]
  ch.vtlist.vt_delta = (systime_t)-1;
 8002422:	f8c4 8024 	str.w	r8, [r4, #36]	; 0x24
 *
 * @init
 */
void chTMObjectInit(time_measurement_t *tmp) {

  tmp->best       = (rtcnt_t)-1;
 8002426:	f8cd 8018 	str.w	r8, [sp, #24]
 * @notapi
 */
void _scheduler_init(void) {

  queue_init(&ch.rlist.r_queue);
  ch.rlist.r_prio = NOPRIO;
 800242a:	60a5      	str	r5, [r4, #8]
#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.r_newer = (thread_t *)&ch.rlist;
 800242c:	6124      	str	r4, [r4, #16]
  ch.rlist.r_older = (thread_t *)&ch.rlist;
 800242e:	6164      	str	r4, [r4, #20]
#if CH_CFG_ST_TIMEDELTA == 0
  ch.vtlist.vt_systime = (systime_t)0;
 8002430:	62a5      	str	r5, [r4, #40]	; 0x28
  time_measurement_t tm;

  /* Time Measurement subsystem calibration, it does a null measurement
     and calculates the call overhead which is subtracted to real
     measurements.*/
  ch.tm.offset = (rtcnt_t)0;
 8002432:	6765      	str	r5, [r4, #116]	; 0x74
 * @init
 */
void chTMObjectInit(time_measurement_t *tmp) {

  tmp->best       = (rtcnt_t)-1;
  tmp->worst      = (rtcnt_t)0;
 8002434:	9507      	str	r5, [sp, #28]
  tmp->last       = (rtcnt_t)0;
 8002436:	9508      	str	r5, [sp, #32]
  tmp->n          = (ucnt_t)0;
 8002438:	9509      	str	r5, [sp, #36]	; 0x24
  /* Time Measurement subsystem calibration, it does a null measurement
     and calculates the call overhead which is subtracted to real
     measurements.*/
  ch.tm.offset = (rtcnt_t)0;
  chTMObjectInit(&tm);
  chTMStartMeasurementX(&tm);
 800243a:	f7fe fbd9 	bl	8000bf0 <chTMStartMeasurementX>
  chTMStopMeasurementX(&tm);
 800243e:	4650      	mov	r0, sl
 8002440:	f7fe fbae 	bl	8000ba0 <chTMStopMeasurementX>
  ch.tm.offset = tm.last;
 8002444:	9b08      	ldr	r3, [sp, #32]
 8002446:	6763      	str	r3, [r4, #116]	; 0x74
#if CH_CFG_MEMCORE_SIZE == 0
  extern uint8_t __heap_base__[];
  extern uint8_t __heap_end__[];

  /*lint -save -e9033 [10.8] Required cast operations.*/
  nextmem = (uint8_t *)MEM_ALIGN_NEXT(__heap_base__);
 8002448:	4b40      	ldr	r3, [pc, #256]	; (800254c <main+0x35c>)
 800244a:	4941      	ldr	r1, [pc, #260]	; (8002550 <main+0x360>)
 *
 * @notapi
 */
void _heap_init(void) {

  default_heap.h_provider = chCoreAlloc;
 800244c:	f8df 811c 	ldr.w	r8, [pc, #284]	; 800256c <main+0x37c>

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
  tp->p_flags = CH_FLAG_MODE_STATIC;
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
 8002450:	9a05      	ldr	r2, [sp, #20]
 8002452:	f8c8 5018 	str.w	r5, [r8, #24]
 8002456:	f023 0307 	bic.w	r3, r3, #7
 800245a:	600b      	str	r3, [r1, #0]
  endmem = (uint8_t *)MEM_ALIGN_PREV(__heap_end__);
 800245c:	4b3d      	ldr	r3, [pc, #244]	; (8002554 <main+0x364>)
 800245e:	493e      	ldr	r1, [pc, #248]	; (8002558 <main+0x368>)
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
  tp->p_flags = CH_FLAG_MODE_STATIC;
 8002460:	f884 504d 	strb.w	r5, [r4, #77]	; 0x4d
 8002464:	f023 0307 	bic.w	r3, r3, #7
 8002468:	600b      	str	r3, [r1, #0]
 800246a:	4b3c      	ldr	r3, [pc, #240]	; (800255c <main+0x36c>)
 800246c:	f8c8 3000 	str.w	r3, [r8]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8002470:	f108 0310 	add.w	r3, r8, #16
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
 8002474:	6961      	ldr	r1, [r4, #20]
 8002476:	f8c8 3010 	str.w	r3, [r8, #16]
  tqp->p_prev = (thread_t *)tqp;
 800247a:	f8c8 3014 	str.w	r3, [r8, #20]
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
 800247e:	2340      	movs	r3, #64	; 0x40
 8002480:	63a3      	str	r3, [r4, #56]	; 0x38
  tp->p_flags = CH_FLAG_MODE_STATIC;
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->p_realprio = prio;
 8002482:	66e3      	str	r3, [r4, #108]	; 0x6c
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
 8002484:	f104 0330 	add.w	r3, r4, #48	; 0x30
 8002488:	6461      	str	r1, [r4, #68]	; 0x44

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
  tp->p_flags = CH_FLAG_MODE_STATIC;
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
 800248a:	f884 204f 	strb.w	r2, [r4, #79]	; 0x4f
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->p_realprio = prio;
  tp->p_mtxlist = NULL;
 800248e:	66a5      	str	r5, [r4, #104]	; 0x68
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->p_epending = (eventmask_t)0;
 8002490:	6665      	str	r5, [r4, #100]	; 0x64
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->p_time = (systime_t)0;
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
 8002492:	f884 204e 	strb.w	r2, [r4, #78]	; 0x4e
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
 8002496:	64a5      	str	r5, [r4, #72]	; 0x48
  REG_INSERT(tp);
 8002498:	6424      	str	r4, [r4, #64]	; 0x40
 800249a:	610b      	str	r3, [r1, #16]
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {

  tlp->p_next = (thread_t *)tlp;
 800249c:	f104 0154 	add.w	r1, r4, #84	; 0x54
 80024a0:	6561      	str	r1, [r4, #84]	; 0x54
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 80024a2:	f104 0158 	add.w	r1, r4, #88	; 0x58
  default_heap.h_free.h.u.next = NULL;
 80024a6:	f8c8 5008 	str.w	r5, [r8, #8]
  default_heap.h_free.h.size = 0;
 80024aa:	f8c8 500c 	str.w	r5, [r8, #12]
 80024ae:	6163      	str	r3, [r4, #20]
 80024b0:	65a1      	str	r1, [r4, #88]	; 0x58
  tqp->p_prev = (thread_t *)tqp;
 80024b2:	65e1      	str	r1, [r4, #92]	; 0x5c
  _dbg_trace_init();
#endif

#if CH_CFG_NO_IDLE_THREAD == FALSE
  /* Now this instructions flow becomes the main thread.*/
  setcurrp(_thread_init(&ch.mainthread, NORMALPRIO));
 80024b4:	61a3      	str	r3, [r4, #24]
#else
  /* Now this instructions flow becomes the idle thread.*/
  setcurrp(_thread_init(&ch.mainthread, IDLEPRIO));
#endif

  currp->p_state = CH_STATE_CURRENT;
 80024b6:	f884 204c 	strb.w	r2, [r4, #76]	; 0x4c
 80024ba:	f385 8811 	msr	BASEPRI, r5
 80024be:	e057      	b.n	8002570 <main+0x380>
 80024c0:	40021000 	.word	0x40021000
 80024c4:	40007000 	.word	0x40007000
 80024c8:	20000e80 	.word	0x20000e80
 80024cc:	08003d00 	.word	0x08003d00
 80024d0:	20000e20 	.word	0x20000e20
 80024d4:	40020000 	.word	0x40020000
 80024d8:	40010000 	.word	0x40010000
 80024dc:	080040a0 	.word	0x080040a0
 80024e0:	200019c0 	.word	0x200019c0
 80024e4:	48000400 	.word	0x48000400
 80024e8:	080040bc 	.word	0x080040bc
 80024ec:	48000800 	.word	0x48000800
 80024f0:	080040d8 	.word	0x080040d8
 80024f4:	48000c00 	.word	0x48000c00
 80024f8:	080040f4 	.word	0x080040f4
 80024fc:	48001000 	.word	0x48001000
 8002500:	08004110 	.word	0x08004110
 8002504:	48001400 	.word	0x48001400
 8002508:	0800412c 	.word	0x0800412c
 800250c:	50000300 	.word	0x50000300
 8002510:	20001218 	.word	0x20001218
 8002514:	200011e8 	.word	0x200011e8
 8002518:	200011f0 	.word	0x200011f0
 800251c:	20000f04 	.word	0x20000f04
 8002520:	20000e88 	.word	0x20000e88
 8002524:	40000400 	.word	0x40000400
 8002528:	08001481 	.word	0x08001481
 800252c:	40013800 	.word	0x40013800
 8002530:	08001471 	.word	0x08001471
 8002534:	40004400 	.word	0x40004400
 8002538:	e000e010 	.word	0xe000e010
 800253c:	20001a00 	.word	0x20001a00
 8002540:	05fa0300 	.word	0x05fa0300
 8002544:	e000edf0 	.word	0xe000edf0
 8002548:	e0001000 	.word	0xe0001000
 800254c:	20001c13 	.word	0x20001c13
 8002550:	20001258 	.word	0x20001258
 8002554:	2000a000 	.word	0x2000a000
 8002558:	20001264 	.word	0x20001264
 800255c:	08000671 	.word	0x08000671
 8002560:	e000e100 	.word	0xe000e100
 8002564:	016e3600 	.word	0x016e3600
 8002568:	50000700 	.word	0x50000700
 800256c:	200011c8 	.word	0x200011c8
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
 8002570:	b662      	cpsie	i
 8002572:	69a3      	ldr	r3, [r4, #24]
 8002574:	4996      	ldr	r1, [pc, #600]	; (80027d0 <main+0x5e0>)
 8002576:	6199      	str	r1, [r3, #24]
#if CH_CFG_NO_IDLE_THREAD == FALSE
  {
  /* This thread has the lowest priority in the system, its role is just to
     serve interrupts in its context while keeping the lowest energy saving
     mode compatible with the system status.*/
    thread_t *tp =  chThdCreateStatic(ch.idle_thread_wa,
 8002578:	f104 0078 	add.w	r0, r4, #120	; 0x78
 800257c:	f44f 71b0 	mov.w	r1, #352	; 0x160
 8002580:	4b94      	ldr	r3, [pc, #592]	; (80027d4 <main+0x5e4>)
 8002582:	f000 fff5 	bl	8003570 <chThdCreateStatic.constprop.49>
 * @xclass
 */
static inline void chRegSetThreadNameX(thread_t *tp, const char *name) {

#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = name;
 8002586:	4b94      	ldr	r3, [pc, #592]	; (80027d8 <main+0x5e8>)
 8002588:	6183      	str	r3, [r0, #24]

	/*
	 * Activates the serial driver 1 using the driver default configuration.
	 * PA9 and PA10 are routed to USART1.
	 */
	const SerialConfig SD1_config = { 
 800258a:	4b94      	ldr	r3, [pc, #592]	; (80027dc <main+0x5ec>)
 800258c:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 800258e:	e88a 000f 	stmia.w	sl, {r0, r1, r2, r3}
		115200,
		0,
		USART_CR2_STOP1_BITS | USART_CR2_LINEN,
		0 };
	sdStart(&SD1, &SD1_config);
 8002592:	4893      	ldr	r0, [pc, #588]	; (80027e0 <main+0x5f0>)
 8002594:	4651      	mov	r1, sl
 8002596:	f7fe f91b 	bl	80007d0 <sdStart>
 800259a:	f7ff fcc9 	bl	8001f30 <i2c_lld_init>

    \param [in]    basePri  Base Priority value to set
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __set_BASEPRI(uint32_t value)
{
  __ASM volatile ("MSR basepri, %0" : : "r" (value) : "memory");
 800259e:	f8dd c010 	ldr.w	ip, [sp, #16]
 80025a2:	f38c 8811 	msr	BASEPRI, ip
  osalDbgCheck((i2cp != NULL) && (config != NULL));
  osalDbgAssert((i2cp->state == I2C_STOP) || (i2cp->state == I2C_READY) ||
                (i2cp->state == I2C_LOCKED), "invalid state");

  osalSysLock();
  i2cp->config = config;
 80025a6:	4b8f      	ldr	r3, [pc, #572]	; (80027e4 <main+0x5f4>)
 80025a8:	4a8f      	ldr	r2, [pc, #572]	; (80027e8 <main+0x5f8>)
 80025aa:	605a      	str	r2, [r3, #4]
 * @param[in] i2cp      pointer to the @p I2CDriver object
 *
 * @notapi
 */
void i2c_lld_start(I2CDriver *i2cp) {
  I2C_TypeDef *dp = i2cp->i2c;
 80025ac:	f8d3 a030 	ldr.w	sl, [r3, #48]	; 0x30

  /* Make sure I2C peripheral is disabled */
  dp->CR1 &= ~I2C_CR1_PE;

  /* If in stopped state then enables the I2C and DMA clocks.*/
  if (i2cp->state == I2C_STOP) {
 80025b0:	f893 c000 	ldrb.w	ip, [r3]
 80025b4:	f8cd 8010 	str.w	r8, [sp, #16]
void i2c_lld_start(I2CDriver *i2cp) {
  I2C_TypeDef *dp = i2cp->i2c;

#if STM32_I2C_USE_DMA == TRUE
  /* Common DMA modes.*/
  i2cp->txdmamode = DMAMODE_COMMON | STM32_DMA_CR_DIR_M2P;
 80025b8:	229a      	movs	r2, #154	; 0x9a
 80025ba:	625a      	str	r2, [r3, #36]	; 0x24
  i2cp->rxdmamode = DMAMODE_COMMON | STM32_DMA_CR_DIR_P2M;
 80025bc:	228a      	movs	r2, #138	; 0x8a
 80025be:	621a      	str	r2, [r3, #32]
#endif

  /* Make sure I2C peripheral is disabled */
  dp->CR1 &= ~I2C_CR1_PE;
 80025c0:	f8da 2000 	ldr.w	r2, [sl]

  /* If in stopped state then enables the I2C and DMA clocks.*/
  if (i2cp->state == I2C_STOP) {
 80025c4:	f1bc 0f01 	cmp.w	ip, #1
  i2cp->txdmamode = DMAMODE_COMMON | STM32_DMA_CR_DIR_M2P;
  i2cp->rxdmamode = DMAMODE_COMMON | STM32_DMA_CR_DIR_P2M;
#endif

  /* Make sure I2C peripheral is disabled */
  dp->CR1 &= ~I2C_CR1_PE;
 80025c8:	f022 0201 	bic.w	r2, r2, #1
 80025cc:	f8ca 2000 	str.w	r2, [sl]
 80025d0:	4698      	mov	r8, r3

  /* If in stopped state then enables the I2C and DMA clocks.*/
  if (i2cp->state == I2C_STOP) {
 80025d2:	d13a      	bne.n	800264a <main+0x45a>

#if STM32_I2C_USE_I2C1
    if (&I2CD1 == i2cp) {

      rccResetI2C1();
 80025d4:	f8db 3010 	ldr.w	r3, [fp, #16]
 80025d8:	f8cd c014 	str.w	ip, [sp, #20]
 80025dc:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 80025e0:	f8cb 3010 	str.w	r3, [fp, #16]
 80025e4:	f8cb 5010 	str.w	r5, [fp, #16]
      rccEnableI2C1(FALSE);
 80025e8:	f8db 301c 	ldr.w	r3, [fp, #28]
#if STM32_I2C_USE_DMA == TRUE
      {
        bool b;

        b = dmaStreamAllocate(i2cp->dmarx,
 80025ec:	f8d8 0028 	ldr.w	r0, [r8, #40]	; 0x28

#if STM32_I2C_USE_I2C1
    if (&I2CD1 == i2cp) {

      rccResetI2C1();
      rccEnableI2C1(FALSE);
 80025f0:	f443 1300 	orr.w	r3, r3, #2097152	; 0x200000
 80025f4:	f8cb 301c 	str.w	r3, [fp, #28]
#if STM32_I2C_USE_DMA == TRUE
      {
        bool b;

        b = dmaStreamAllocate(i2cp->dmarx,
 80025f8:	210a      	movs	r1, #10
 80025fa:	462a      	mov	r2, r5
 80025fc:	4643      	mov	r3, r8
 80025fe:	f7fe f88f 	bl	8000720 <dmaStreamAllocate>
                              STM32_I2C_I2C1_IRQ_PRIORITY,
                              NULL,
                              (void *)i2cp);
        osalDbgAssert(!b, "stream already allocated");
        b = dmaStreamAllocate(i2cp->dmatx,
 8002602:	462a      	mov	r2, r5
 8002604:	4643      	mov	r3, r8
 8002606:	f8d8 002c 	ldr.w	r0, [r8, #44]	; 0x2c
 800260a:	210a      	movs	r1, #10
 800260c:	f7fe f888 	bl	8000720 <dmaStreamAllocate>
                              STM32_I2C_I2C1_IRQ_PRIORITY,
                              NULL,
                              (void *)i2cp);
        osalDbgAssert(!b, "stream already allocated");

        i2cp->rxdmamode |= STM32_DMA_CR_CHSEL(I2C1_RX_DMA_CHANNEL) |
 8002610:	f8d8 3020 	ldr.w	r3, [r8, #32]
 8002614:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 8002618:	f8c8 3020 	str.w	r3, [r8, #32]
                           STM32_DMA_CR_PL(STM32_I2C_I2C1_DMA_PRIORITY);
        i2cp->txdmamode |= STM32_DMA_CR_CHSEL(I2C1_TX_DMA_CHANNEL) |
 800261c:	f8d8 3024 	ldr.w	r3, [r8, #36]	; 0x24
 8002620:	f443 5380 	orr.w	r3, r3, #4096	; 0x1000
 8002624:	f8c8 3024 	str.w	r3, [r8, #36]	; 0x24
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8002628:	f04f 4200 	mov.w	r2, #2147483648	; 0x80000000

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 800262c:	23a0      	movs	r3, #160	; 0xa0
 800262e:	f889 331f 	strb.w	r3, [r9, #799]	; 0x31f
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 8002632:	f8c9 2180 	str.w	r2, [r9, #384]	; 0x180
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8002636:	f8c9 2000 	str.w	r2, [r9]

#if defined(__CORE_CM0_H_GENERIC)
  NVIC->IP[_IP_IDX(n)] = (NVIC->IP[_IP_IDX(n)] & ~(0xFFU << _BIT_SHIFT(n))) |
                         (NVIC_PRIORITY_MASK(prio) << _BIT_SHIFT(n));
#else
  NVIC->IP[n] = NVIC_PRIORITY_MASK(prio);
 800263a:	f889 3320 	strb.w	r3, [r9, #800]	; 0x320
#endif
  NVIC->ICPR[n >> 5U] = 1U << (n & 0x1FU);
 800263e:	f8dd c014 	ldr.w	ip, [sp, #20]
 8002642:	f8c9 c184 	str.w	ip, [r9, #388]	; 0x184
  NVIC->ISER[n >> 5U] = 1U << (n & 0x1FU);
 8002646:	f8c9 c004 	str.w	ip, [r9, #4]
#endif /* STM32_I2C_USE_I2C2 */
  }

#if STM32_I2C_USE_DMA == TRUE
  /* I2C registers pointed by the DMA.*/
  dmaStreamSetPeripheral(i2cp->dmarx, &dp->RXDR);
 800264a:	f8d8 3028 	ldr.w	r3, [r8, #40]	; 0x28
 800264e:	681b      	ldr	r3, [r3, #0]
 8002650:	f10a 0224 	add.w	r2, sl, #36	; 0x24
 8002654:	609a      	str	r2, [r3, #8]
  dmaStreamSetPeripheral(i2cp->dmatx, &dp->TXDR);
 8002656:	f8d8 302c 	ldr.w	r3, [r8, #44]	; 0x2c
 800265a:	681b      	ldr	r3, [r3, #0]
 800265c:	f10a 0228 	add.w	r2, sl, #40	; 0x28
 8002660:	609a      	str	r2, [r3, #8]
#endif

  /* Reset i2c peripheral, the TCIE bit will be handled separately.*/
  dp->CR1 = i2cp->config->cr1 |
 8002662:	f8d8 2004 	ldr.w	r2, [r8, #4]
#if STM32_I2C_USE_DMA == TRUE
            I2C_CR1_TXDMAEN | I2C_CR1_RXDMAEN | /* Enable only if using DMA */
#endif
            I2C_CR1_ERRIE | I2C_CR1_NACKIE;
 8002666:	6853      	ldr	r3, [r2, #4]
 8002668:	f443 4340 	orr.w	r3, r3, #49152	; 0xc000
 800266c:	f043 0390 	orr.w	r3, r3, #144	; 0x90
  dmaStreamSetPeripheral(i2cp->dmarx, &dp->RXDR);
  dmaStreamSetPeripheral(i2cp->dmatx, &dp->TXDR);
#endif

  /* Reset i2c peripheral, the TCIE bit will be handled separately.*/
  dp->CR1 = i2cp->config->cr1 |
 8002670:	f8ca 3000 	str.w	r3, [sl]
            I2C_CR1_TXDMAEN | I2C_CR1_RXDMAEN | /* Enable only if using DMA */
#endif
            I2C_CR1_ERRIE | I2C_CR1_NACKIE;

  /* Setup I2C parameters.*/
  dp->TIMINGR = i2cp->config->timingr;
 8002674:	6813      	ldr	r3, [r2, #0]
 8002676:	f8ca 3010 	str.w	r3, [sl, #16]

  /* Ready to go.*/
  dp->CR1 |= I2C_CR1_PE;
 800267a:	f8da 3000 	ldr.w	r3, [sl]
 800267e:	f043 0301 	orr.w	r3, r3, #1
 8002682:	f8ca 3000 	str.w	r3, [sl]
  i2c_lld_start(i2cp);
  i2cp->state = I2C_READY;
 8002686:	2302      	movs	r3, #2
 8002688:	f888 3000 	strb.w	r3, [r8]
 800268c:	f04f 0800 	mov.w	r8, #0
 8002690:	f388 8811 	msr	BASEPRI, r8
 8002694:	2320      	movs	r3, #32
 8002696:	f383 8811 	msr	BASEPRI, r3
 * @notapi
 */
void adc_lld_start(ADCDriver *adcp) {

  /* If in stopped state then enables the ADC and DMA clocks.*/
  if (adcp->state == ADC_STOP) {
 800269a:	7833      	ldrb	r3, [r6, #0]
  osalDbgCheck(adcp != NULL);

  osalSysLock();
  osalDbgAssert((adcp->state == ADC_STOP) || (adcp->state == ADC_READY),
                "invalid state");
  adcp->config = config;
 800269c:	4d53      	ldr	r5, [pc, #332]	; (80027ec <main+0x5fc>)
 800269e:	f8c6 8004 	str.w	r8, [r6, #4]
 80026a2:	2b01      	cmp	r3, #1
 80026a4:	d055      	beq.n	8002752 <main+0x562>
  adc_lld_start(adcp);
  adcp->state = ADC_READY;
 80026a6:	2302      	movs	r3, #2
 80026a8:	7033      	strb	r3, [r6, #0]
 80026aa:	2500      	movs	r5, #0
 80026ac:	f385 8811 	msr	BASEPRI, r5
 80026b0:	f04f 0820 	mov.w	r8, #32
 80026b4:	f388 8811 	msr	BASEPRI, r8
  osalDbgAssert((adcp->state == ADC_READY) ||
                (adcp->state == ADC_COMPLETE) ||
                (adcp->state == ADC_ERROR),
                "not ready");

  adcp->samples  = samples;
 80026b8:	4b4d      	ldr	r3, [pc, #308]	; (80027f0 <main+0x600>)
 80026ba:	60b3      	str	r3, [r6, #8]
  adcp->depth    = depth;
 80026bc:	2308      	movs	r3, #8
 80026be:	60f3      	str	r3, [r6, #12]
  adcp->grpp     = grpp;
  adcp->state    = ADC_ACTIVE;
 80026c0:	2703      	movs	r7, #3
                (adcp->state == ADC_ERROR),
                "not ready");

  adcp->samples  = samples;
  adcp->depth    = depth;
  adcp->grpp     = grpp;
 80026c2:	4b4c      	ldr	r3, [pc, #304]	; (80027f4 <main+0x604>)
 80026c4:	6133      	str	r3, [r6, #16]
  adcp->state    = ADC_ACTIVE;
 80026c6:	7037      	strb	r7, [r6, #0]
  adc_lld_start_conversion(adcp);
 80026c8:	f000 ffaa 	bl	8003620 <adc_lld_start_conversion.constprop.26>
 80026cc:	69a3      	ldr	r3, [r4, #24]
  thread_t *tp = chThdGetSelfX();

  chDbgAssert(*trp == NULL, "not NULL");

  *trp = tp;
  tp->p_u.wttrp = trp;
 80026ce:	4a4a      	ldr	r2, [pc, #296]	; (80027f8 <main+0x608>)
msg_t chThdSuspendS(thread_reference_t *trp) {
  thread_t *tp = chThdGetSelfX();

  chDbgAssert(*trp == NULL, "not NULL");

  *trp = tp;
 80026d0:	6173      	str	r3, [r6, #20]
  tp->p_u.wttrp = trp;
 80026d2:	621a      	str	r2, [r3, #32]
  chSchGoSleepS(CH_STATE_SUSPENDED);
 80026d4:	4638      	mov	r0, r7
 80026d6:	f7fe fa93 	bl	8000c00 <chSchGoSleepS>
 80026da:	f385 8811 	msr	BASEPRI, r5

  /*
   * Linear conversion.
   */
  adcConvert(&ADCD1, &adcgrpcfg1, samples1, ADC_GRP1_BUF_DEPTH);
  chThdSleepMilliseconds(1000);
 80026de:	f242 7010 	movw	r0, #10000	; 0x2710
 80026e2:	f7fe fbfd 	bl	8000ee0 <chThdSleep>
 80026e6:	f388 8811 	msr	BASEPRI, r8
                (adcp->state == ADC_COMPLETE) ||
                (adcp->state == ADC_ERROR),
                "not ready");

  adcp->samples  = samples;
  adcp->depth    = depth;
 80026ea:	2310      	movs	r3, #16
 80026ec:	60f3      	str	r3, [r6, #12]
  osalDbgAssert((adcp->state == ADC_READY) ||
                (adcp->state == ADC_COMPLETE) ||
                (adcp->state == ADC_ERROR),
                "not ready");

  adcp->samples  = samples;
 80026ee:	f8df 8144 	ldr.w	r8, [pc, #324]	; 8002834 <main+0x644>
  adcp->depth    = depth;
  adcp->grpp     = grpp;
 80026f2:	4b42      	ldr	r3, [pc, #264]	; (80027fc <main+0x60c>)
  osalDbgAssert((adcp->state == ADC_READY) ||
                (adcp->state == ADC_COMPLETE) ||
                (adcp->state == ADC_ERROR),
                "not ready");

  adcp->samples  = samples;
 80026f4:	f8c6 8008 	str.w	r8, [r6, #8]
  adcp->depth    = depth;
  adcp->grpp     = grpp;
 80026f8:	6133      	str	r3, [r6, #16]
  adcp->state    = ADC_ACTIVE;
 80026fa:	7037      	strb	r7, [r6, #0]
  adc_lld_start_conversion(adcp);
 80026fc:	f000 ff90 	bl	8003620 <adc_lld_start_conversion.constprop.26>
 8002700:	f385 8811 	msr	BASEPRI, r5
 *
 * @init
 */
static inline void chEvtObjectInit(event_source_t *esp) {

  esp->es_next = (event_listener_t *)esp;
 8002704:	4b3e      	ldr	r3, [pc, #248]	; (8002800 <main+0x610>)
   * Shell manager initialization.
   */
  shellInit();

	/* Creates RGB LED blinker thread */
	chThdCreateStatic(waThread1, sizeof(waThread1), NORMALPRIO, Thread1, NULL);
 8002706:	483f      	ldr	r0, [pc, #252]	; (8002804 <main+0x614>)
 8002708:	601b      	str	r3, [r3, #0]
 800270a:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 800270e:	2240      	movs	r2, #64	; 0x40
 8002710:	4b3d      	ldr	r3, [pc, #244]	; (8002808 <main+0x618>)
 8002712:	f000 ff2d 	bl	8003570 <chThdCreateStatic.constprop.49>

	/* Creates MH-Z14 CO2 NDIR sensor module readout thread */
	chThdCreateStatic(waThread2, sizeof(waThread2), NORMALPRIO, Thread2, NULL);
 8002716:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 800271a:	2240      	movs	r2, #64	; 0x40
 800271c:	4b3b      	ldr	r3, [pc, #236]	; (800280c <main+0x61c>)
 800271e:	483c      	ldr	r0, [pc, #240]	; (8002810 <main+0x620>)
 8002720:	f000 ff26 	bl	8003570 <chThdCreateStatic.constprop.49>

	/* Creates MPL3115A2 absolute pressure sensor readout thread */
	chThdCreateStatic(waThread3, sizeof(waThread3), NORMALPRIO, Thread3, NULL);
 8002724:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 8002728:	2240      	movs	r2, #64	; 0x40
 800272a:	4b3a      	ldr	r3, [pc, #232]	; (8002814 <main+0x624>)
 800272c:	483a      	ldr	r0, [pc, #232]	; (8002818 <main+0x628>)
 800272e:	f000 ff1f 	bl	8003570 <chThdCreateStatic.constprop.49>

	/* Creates Si7006 relative himidity sensor readout thread */
	chThdCreateStatic(waThread4, sizeof(waThread4), NORMALPRIO, Thread4, NULL);
 8002732:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 8002736:	2240      	movs	r2, #64	; 0x40
 8002738:	4b38      	ldr	r3, [pc, #224]	; (800281c <main+0x62c>)
 800273a:	4839      	ldr	r0, [pc, #228]	; (8002820 <main+0x630>)
 800273c:	f000 ff18 	bl	8003570 <chThdCreateStatic.constprop.49>

	/* Creates gas sensors test thread */
	chThdCreateStatic(waThread5, sizeof(waThread5), NORMALPRIO, Thread5, NULL);
 8002740:	4838      	ldr	r0, [pc, #224]	; (8002824 <main+0x634>)
 8002742:	4b39      	ldr	r3, [pc, #228]	; (8002828 <main+0x638>)
 8002744:	f44f 71e8 	mov.w	r1, #464	; 0x1d0
 8002748:	2240      	movs	r2, #64	; 0x40
 800274a:	f000 ff11 	bl	8003570 <chThdCreateStatic.constprop.49>
 800274e:	4646      	mov	r6, r8
 8002750:	e136      	b.n	80029c0 <main+0x7d0>
#if STM32_ADC_USE_ADC1
    if (&ADCD1 == adcp) {
      bool b;
      b = dmaStreamAllocate(adcp->dmastp,
 8002752:	462b      	mov	r3, r5
 8002754:	6b68      	ldr	r0, [r5, #52]	; 0x34
 8002756:	4a35      	ldr	r2, [pc, #212]	; (800282c <main+0x63c>)
 8002758:	2105      	movs	r1, #5
 800275a:	f7fd ffe1 	bl	8000720 <dmaStreamAllocate>
                            STM32_ADC_ADC12_DMA_IRQ_PRIORITY,
                            (stm32_dmaisr_t)adc_lld_serve_dma_interrupt,
                            (void *)adcp);
      osalDbgAssert(!b, "stream already allocated");
      rccEnableADC12(FALSE);
 800275e:	697b      	ldr	r3, [r7, #20]
 8002760:	f043 5380 	orr.w	r3, r3, #268435456	; 0x10000000
 8002764:	617b      	str	r3, [r7, #20]
    }
#endif /* STM32_ADC_USE_ADC3 */

    /* Setting DMA peripheral-side pointer.*/
#if STM32_ADC_DUAL_MODE
      dmaStreamSetPeripheral(adcp->dmastp, &adcp->adcc->CDR);
 8002766:	6b6b      	ldr	r3, [r5, #52]	; 0x34
 8002768:	681a      	ldr	r2, [r3, #0]
 800276a:	6aab      	ldr	r3, [r5, #40]	; 0x28
 800276c:	f103 010c 	add.w	r1, r3, #12
 8002770:	6091      	str	r1, [r2, #8]
#else
      dmaStreamSetPeripheral(adcp->dmastp, &adcp->adcm->DR);
#endif

    /* Clock source setting.*/
    adcp->adcc->CCR = STM32_ADC_ADC12_CLOCK_MODE | ADC_DMA_MDMA;
 8002772:	f44f 32c0 	mov.w	r2, #98304	; 0x18000
 8002776:	609a      	str	r2, [r3, #8]
 *
 * @param[in] adcp      pointer to the @p ADCDriver object
 */
static void adc_lld_vreg_on(ADCDriver *adcp) {

  adcp->adcm->CR = 0;   /* RM 12.4.3.*/
 8002778:	6aeb      	ldr	r3, [r5, #44]	; 0x2c
  adcp->adcm->CR = ADC_CR_ADVREGEN_0;
#if STM32_ADC_DUAL_MODE
  adcp->adcs->CR = ADC_CR_ADVREGEN_0;
 800277a:	6b2a      	ldr	r2, [r5, #48]	; 0x30
 *
 * @param[in] adcp      pointer to the @p ADCDriver object
 */
static void adc_lld_vreg_on(ADCDriver *adcp) {

  adcp->adcm->CR = 0;   /* RM 12.4.3.*/
 800277c:	f8c3 8008 	str.w	r8, [r3, #8]
  adcp->adcm->CR = ADC_CR_ADVREGEN_0;
 8002780:	f04f 5180 	mov.w	r1, #268435456	; 0x10000000
 8002784:	6099      	str	r1, [r3, #8]
#if STM32_ADC_DUAL_MODE
  adcp->adcs->CR = ADC_CR_ADVREGEN_0;
 8002786:	6091      	str	r1, [r2, #8]
 *
 * @return              The realtime counter value.
 */
static inline rtcnt_t port_rt_get_counter_value(void) {

  return DWT->CYCCNT;
 8002788:	4929      	ldr	r1, [pc, #164]	; (8002830 <main+0x640>)
 800278a:	684d      	ldr	r5, [r1, #4]
 800278c:	6848      	ldr	r0, [r1, #4]
 *
 * @xclass
 */
bool chSysIsCounterWithinX(rtcnt_t cnt, rtcnt_t start, rtcnt_t end) {

  return (bool)((cnt - start) < (end - start));
 800278e:	1b40      	subs	r0, r0, r5
 */
void chSysPolledDelayX(rtcnt_t cycles) {
  rtcnt_t start = chSysGetRealtimeCounterX();
  rtcnt_t end  = start + cycles;

  while (chSysIsCounterWithinX(chSysGetRealtimeCounterX(), start, end)) {
 8002790:	f5b0 7ff0 	cmp.w	r0, #480	; 0x1e0
 8002794:	d3fa      	bcc.n	800278c <main+0x59c>
 * @param[in] adcp      pointer to the @p ADCDriver object
 */
static void adc_lld_calibrate(ADCDriver *adcp) {

  osalDbgAssert(adcp->adcm->CR == ADC_CR_ADVREGEN_0, "invalid register state");
  adcp->adcm->CR |= ADC_CR_ADCAL;
 8002796:	6899      	ldr	r1, [r3, #8]
 8002798:	f041 4100 	orr.w	r1, r1, #2147483648	; 0x80000000
 800279c:	6099      	str	r1, [r3, #8]
  while ((adcp->adcm->CR & ADC_CR_ADCAL) != 0)
 800279e:	6899      	ldr	r1, [r3, #8]
 80027a0:	2900      	cmp	r1, #0
 80027a2:	dbfc      	blt.n	800279e <main+0x5ae>
    ;
#if STM32_ADC_DUAL_MODE
  osalDbgAssert(adcp->adcs->CR == ADC_CR_ADVREGEN_0, "invalid register state");
  adcp->adcs->CR |= ADC_CR_ADCAL;
 80027a4:	6891      	ldr	r1, [r2, #8]
 80027a6:	f041 4100 	orr.w	r1, r1, #2147483648	; 0x80000000
 80027aa:	6091      	str	r1, [r2, #8]
  while ((adcp->adcs->CR & ADC_CR_ADCAL) != 0)
 80027ac:	6891      	ldr	r1, [r2, #8]
 80027ae:	2900      	cmp	r1, #0
 80027b0:	dbfc      	blt.n	80027ac <main+0x5bc>
 *
 * @param[in] adcp      pointer to the @p ADCDriver object
 */
static void adc_lld_analog_on(ADCDriver *adcp) {

  adcp->adcm->CR |= ADC_CR_ADEN;
 80027b2:	6899      	ldr	r1, [r3, #8]
 80027b4:	f041 0101 	orr.w	r1, r1, #1
 80027b8:	6099      	str	r1, [r3, #8]
  while ((adcp->adcm->ISR & ADC_ISR_ADRD) == 0)
 80027ba:	6819      	ldr	r1, [r3, #0]
 80027bc:	07c9      	lsls	r1, r1, #31
 80027be:	d5fc      	bpl.n	80027ba <main+0x5ca>
    ;
#if STM32_ADC_DUAL_MODE
  adcp->adcs->CR |= ADC_CR_ADEN;
 80027c0:	6893      	ldr	r3, [r2, #8]
 80027c2:	f043 0301 	orr.w	r3, r3, #1
 80027c6:	6093      	str	r3, [r2, #8]
  while ((adcp->adcs->ISR & ADC_ISR_ADRD) == 0)
 80027c8:	6813      	ldr	r3, [r2, #0]
 80027ca:	07db      	lsls	r3, r3, #31
 80027cc:	d5fc      	bpl.n	80027c8 <main+0x5d8>
 80027ce:	e76a      	b.n	80026a6 <main+0x4b6>
 80027d0:	08004070 	.word	0x08004070
 80027d4:	080006d1 	.word	0x080006d1
 80027d8:	08003e95 	.word	0x08003e95
 80027dc:	08003c20 	.word	0x08003c20
 80027e0:	20000e88 	.word	0x20000e88
 80027e4:	20001bd8 	.word	0x20001bd8
 80027e8:	08004150 	.word	0x08004150
 80027ec:	200019c0 	.word	0x200019c0
 80027f0:	20001186 	.word	0x20001186
 80027f4:	08003c60 	.word	0x08003c60
 80027f8:	200019d4 	.word	0x200019d4
 80027fc:	08003cb0 	.word	0x08003cb0
 8002800:	20001254 	.word	0x20001254
 8002804:	20001438 	.word	0x20001438
 8002808:	08002b51 	.word	0x08002b51
 800280c:	08002ba1 	.word	0x08002ba1
 8002810:	20001608 	.word	0x20001608
 8002814:	08003441 	.word	0x08003441
 8002818:	200017d8 	.word	0x200017d8
 800281c:	08001fd1 	.word	0x08001fd1
 8002820:	20001268 	.word	0x20001268
 8002824:	20000c50 	.word	0x20000c50
 8002828:	08001fb1 	.word	0x08001fb1
 800282c:	08001281 	.word	0x08001281
 8002830:	e0001000 	.word	0xe0001000
 8002834:	20000f86 	.word	0x20000f86
  qp = &heapp->h_free;

  H_LOCK(heapp);
  while (qp->h.u.next != NULL) {
    hp = qp->h.u.next;
    if (hp->h.size >= size) {
 8002838:	4619      	mov	r1, r3

  size = MEM_ALIGN_NEXT(size);
  qp = &heapp->h_free;

  H_LOCK(heapp);
  while (qp->h.u.next != NULL) {
 800283a:	680b      	ldr	r3, [r1, #0]
 800283c:	2b00      	cmp	r3, #0
 800283e:	f040 80c6 	bne.w	80029ce <main+0x7de>
      return (void *)(hp + 1);
      /*lint -restore*/
    }
    qp = hp;
  }
  H_UNLOCK(heapp);
 8002842:	4f96      	ldr	r7, [pc, #600]	; (8002a9c <main+0x8ac>)
 8002844:	f107 0010 	add.w	r0, r7, #16
 8002848:	f7fe fb92 	bl	8000f70 <chMtxUnlock>

  /* More memory is required, tries to get it from the associated provider
     else fails.*/
  if (heapp->h_provider != NULL) {
 800284c:	9b04      	ldr	r3, [sp, #16]
 800284e:	681b      	ldr	r3, [r3, #0]
 8002850:	2b00      	cmp	r3, #0
 8002852:	f040 80dd 	bne.w	8002a10 <main+0x820>
			shelltp1 = shellCreate(&shell_cfg1, SHELL_WA_SIZE, NORMALPRIO);
		else if (chThdTerminatedX(shelltp1)) {
			chThdRelease(shelltp1);   /* Recovers memory of the previous shell.   */
			shelltp1 = NULL;          /* Triggers spawning of a new shell.        */
		}
		if ( log_active==1 ) {
 8002856:	4b92      	ldr	r3, [pc, #584]	; (8002aa0 <main+0x8b0>)
 8002858:	781b      	ldrb	r3, [r3, #0]
 800285a:	2b01      	cmp	r3, #1
 800285c:	f040 80b0 	bne.w	80029c0 <main+0x7d0>
			chprintf((BaseSequentialStream *)&SD1, "\n[%010d] CO2 concentration : %d ppm\r\n", chVTGetSystemTime(), co2_ppm);
 8002860:	f000 fdde 	bl	8003420 <chVTGetSystemTime.lto_priv.80>
 8002864:	4b8f      	ldr	r3, [pc, #572]	; (8002aa4 <main+0x8b4>)
 8002866:	4990      	ldr	r1, [pc, #576]	; (8002aa8 <main+0x8b8>)
 8002868:	881b      	ldrh	r3, [r3, #0]
			chprintf((BaseSequentialStream *)&SD1, "[%010d] absolute pressure : %6.2f Pa (%3.2f mmHg)\r\n", chVTGetSystemTime(), pressure, pressure*0.0075006375541921);
			chprintf((BaseSequentialStream *)&SD1, "[%010d] temperature 1     : %2.2f deg. C (%3.2f deg. F)\r\n", chVTGetSystemTime(), temperature1, (temperature1*1.8)+32.0);
 800286a:	eddf 8a90 	vldr	s17, [pc, #576]	; 8002aac <main+0x8bc>
		else if (chThdTerminatedX(shelltp1)) {
			chThdRelease(shelltp1);   /* Recovers memory of the previous shell.   */
			shelltp1 = NULL;          /* Triggers spawning of a new shell.        */
		}
		if ( log_active==1 ) {
			chprintf((BaseSequentialStream *)&SD1, "\n[%010d] CO2 concentration : %d ppm\r\n", chVTGetSystemTime(), co2_ppm);
 800286e:	4602      	mov	r2, r0
 8002870:	488f      	ldr	r0, [pc, #572]	; (8002ab0 <main+0x8c0>)
 8002872:	f000 fb65 	bl	8002f40 <chprintf.lto_priv.79>
			chprintf((BaseSequentialStream *)&SD1, "[%010d] absolute pressure : %6.2f Pa (%3.2f mmHg)\r\n", chVTGetSystemTime(), pressure, pressure*0.0075006375541921);
 8002876:	f000 fdd3 	bl	8003420 <chVTGetSystemTime.lto_priv.80>
 800287a:	4b8e      	ldr	r3, [pc, #568]	; (8002ab4 <main+0x8c4>)
 800287c:	ed93 8a00 	vldr	s16, [r3]
 8002880:	4607      	mov	r7, r0
 8002882:	ee18 0a10 	vmov	r0, s16
 8002886:	f7fd fe8f 	bl	80005a8 <__aeabi_f2d>
 800288a:	eddf 7a8b 	vldr	s15, [pc, #556]	; 8002ab8 <main+0x8c8>
 800288e:	ee68 7a27 	vmul.f32	s15, s16, s15
 8002892:	e9cd 0100 	strd	r0, r1, [sp]
 8002896:	ee17 0a90 	vmov	r0, s15
 800289a:	f7fd fe85 	bl	80005a8 <__aeabi_f2d>
 800289e:	463a      	mov	r2, r7
 80028a0:	e9cd 0102 	strd	r0, r1, [sp, #8]
 80028a4:	4985      	ldr	r1, [pc, #532]	; (8002abc <main+0x8cc>)
 80028a6:	4882      	ldr	r0, [pc, #520]	; (8002ab0 <main+0x8c0>)
			chprintf((BaseSequentialStream *)&SD1, "[%010d] temperature 1     : %2.2f deg. C (%3.2f deg. F)\r\n", chVTGetSystemTime(), temperature1, (temperature1*1.8)+32.0);
 80028a8:	ed9f 8a85 	vldr	s16, [pc, #532]	; 8002ac0 <main+0x8d0>
			chThdRelease(shelltp1);   /* Recovers memory of the previous shell.   */
			shelltp1 = NULL;          /* Triggers spawning of a new shell.        */
		}
		if ( log_active==1 ) {
			chprintf((BaseSequentialStream *)&SD1, "\n[%010d] CO2 concentration : %d ppm\r\n", chVTGetSystemTime(), co2_ppm);
			chprintf((BaseSequentialStream *)&SD1, "[%010d] absolute pressure : %6.2f Pa (%3.2f mmHg)\r\n", chVTGetSystemTime(), pressure, pressure*0.0075006375541921);
 80028ac:	f000 fb48 	bl	8002f40 <chprintf.lto_priv.79>
			chprintf((BaseSequentialStream *)&SD1, "[%010d] temperature 1     : %2.2f deg. C (%3.2f deg. F)\r\n", chVTGetSystemTime(), temperature1, (temperature1*1.8)+32.0);
 80028b0:	f000 fdb6 	bl	8003420 <chVTGetSystemTime.lto_priv.80>
 80028b4:	4b83      	ldr	r3, [pc, #524]	; (8002ac4 <main+0x8d4>)
 80028b6:	ed93 9a00 	vldr	s18, [r3]
 80028ba:	4607      	mov	r7, r0
 80028bc:	ee19 0a10 	vmov	r0, s18
 80028c0:	f7fd fe72 	bl	80005a8 <__aeabi_f2d>
 80028c4:	eef0 7a48 	vmov.f32	s15, s16
 80028c8:	eee9 7a28 	vfma.f32	s15, s18, s17
 80028cc:	e9cd 0100 	strd	r0, r1, [sp]
 80028d0:	ee17 0a90 	vmov	r0, s15
 80028d4:	f7fd fe68 	bl	80005a8 <__aeabi_f2d>
 80028d8:	463a      	mov	r2, r7
 80028da:	e9cd 0102 	strd	r0, r1, [sp, #8]
 80028de:	497a      	ldr	r1, [pc, #488]	; (8002ac8 <main+0x8d8>)
 80028e0:	4873      	ldr	r0, [pc, #460]	; (8002ab0 <main+0x8c0>)
 80028e2:	f000 fb2d 	bl	8002f40 <chprintf.lto_priv.79>
			chprintf((BaseSequentialStream *)&SD1, "[%010d] relative humidity : %2.2f percent\r\n", chVTGetSystemTime(), rhumidity);
 80028e6:	f000 fd9b 	bl	8003420 <chVTGetSystemTime.lto_priv.80>
 80028ea:	4b78      	ldr	r3, [pc, #480]	; (8002acc <main+0x8dc>)
 80028ec:	4607      	mov	r7, r0
 80028ee:	6818      	ldr	r0, [r3, #0]
 80028f0:	f7fd fe5a 	bl	80005a8 <__aeabi_f2d>
 80028f4:	463a      	mov	r2, r7
 80028f6:	e9cd 0100 	strd	r0, r1, [sp]
 80028fa:	4975      	ldr	r1, [pc, #468]	; (8002ad0 <main+0x8e0>)
 80028fc:	486c      	ldr	r0, [pc, #432]	; (8002ab0 <main+0x8c0>)
 80028fe:	f000 fb1f 	bl	8002f40 <chprintf.lto_priv.79>
			chprintf((BaseSequentialStream *)&SD1, "[%010d] temperature 2     : %2.2f deg. C (%3.2f deg. F)\r\n", chVTGetSystemTime(), temperature2, (temperature2*1.8)+32.0);
 8002902:	f000 fd8d 	bl	8003420 <chVTGetSystemTime.lto_priv.80>
 8002906:	4b73      	ldr	r3, [pc, #460]	; (8002ad4 <main+0x8e4>)
 8002908:	ed93 9a00 	vldr	s18, [r3]
 800290c:	4607      	mov	r7, r0
 800290e:	eea9 8a28 	vfma.f32	s16, s18, s17
 8002912:	ee19 0a10 	vmov	r0, s18
 8002916:	f7fd fe47 	bl	80005a8 <__aeabi_f2d>
 800291a:	e9cd 0100 	strd	r0, r1, [sp]
 800291e:	ee18 0a10 	vmov	r0, s16
 8002922:	f7fd fe41 	bl	80005a8 <__aeabi_f2d>
 8002926:	463a      	mov	r2, r7
 8002928:	e9cd 0102 	strd	r0, r1, [sp, #8]
 800292c:	496a      	ldr	r1, [pc, #424]	; (8002ad8 <main+0x8e8>)
 800292e:	4860      	ldr	r0, [pc, #384]	; (8002ab0 <main+0x8c0>)
			chprintf((BaseSequentialStream *)&SD1, "[%010d] GAS1 ADC raw      : 0x%03.3x\r\n", chVTGetSystemTime(), samples2[1]);
			chprintf((BaseSequentialStream *)&SD1, "[%010d] GAS2 ADC raw      : 0x%03.3x\r\n", chVTGetSystemTime(), samples2[3]);
			chprintf((BaseSequentialStream *)&SD1, "[%010d] GAS1 ADC volt     : %01.3f V\r\n", chVTGetSystemTime(), ((float_t)samples2[1]*3.29)/4096);
 8002930:	eddf 8a6a 	vldr	s17, [pc, #424]	; 8002adc <main+0x8ec>
 8002934:	ed9f 8a6a 	vldr	s16, [pc, #424]	; 8002ae0 <main+0x8f0>
		if ( log_active==1 ) {
			chprintf((BaseSequentialStream *)&SD1, "\n[%010d] CO2 concentration : %d ppm\r\n", chVTGetSystemTime(), co2_ppm);
			chprintf((BaseSequentialStream *)&SD1, "[%010d] absolute pressure : %6.2f Pa (%3.2f mmHg)\r\n", chVTGetSystemTime(), pressure, pressure*0.0075006375541921);
			chprintf((BaseSequentialStream *)&SD1, "[%010d] temperature 1     : %2.2f deg. C (%3.2f deg. F)\r\n", chVTGetSystemTime(), temperature1, (temperature1*1.8)+32.0);
			chprintf((BaseSequentialStream *)&SD1, "[%010d] relative humidity : %2.2f percent\r\n", chVTGetSystemTime(), rhumidity);
			chprintf((BaseSequentialStream *)&SD1, "[%010d] temperature 2     : %2.2f deg. C (%3.2f deg. F)\r\n", chVTGetSystemTime(), temperature2, (temperature2*1.8)+32.0);
 8002938:	f000 fb02 	bl	8002f40 <chprintf.lto_priv.79>
			chprintf((BaseSequentialStream *)&SD1, "[%010d] GAS1 ADC raw      : 0x%03.3x\r\n", chVTGetSystemTime(), samples2[1]);
 800293c:	f000 fd70 	bl	8003420 <chVTGetSystemTime.lto_priv.80>
 8002940:	4968      	ldr	r1, [pc, #416]	; (8002ae4 <main+0x8f4>)
 8002942:	8873      	ldrh	r3, [r6, #2]
 8002944:	4602      	mov	r2, r0
 8002946:	485a      	ldr	r0, [pc, #360]	; (8002ab0 <main+0x8c0>)
 8002948:	f000 fafa 	bl	8002f40 <chprintf.lto_priv.79>
			chprintf((BaseSequentialStream *)&SD1, "[%010d] GAS2 ADC raw      : 0x%03.3x\r\n", chVTGetSystemTime(), samples2[3]);
 800294c:	f000 fd68 	bl	8003420 <chVTGetSystemTime.lto_priv.80>
 8002950:	4965      	ldr	r1, [pc, #404]	; (8002ae8 <main+0x8f8>)
 8002952:	88f3      	ldrh	r3, [r6, #6]
 8002954:	4602      	mov	r2, r0
 8002956:	4856      	ldr	r0, [pc, #344]	; (8002ab0 <main+0x8c0>)
 8002958:	f000 faf2 	bl	8002f40 <chprintf.lto_priv.79>
			chprintf((BaseSequentialStream *)&SD1, "[%010d] GAS1 ADC volt     : %01.3f V\r\n", chVTGetSystemTime(), ((float_t)samples2[1]*3.29)/4096);
 800295c:	f000 fd60 	bl	8003420 <chVTGetSystemTime.lto_priv.80>
 8002960:	8873      	ldrh	r3, [r6, #2]
 8002962:	ee07 3a90 	vmov	s15, r3
 8002966:	eef8 7a67 	vcvt.f32.u32	s15, s15
 800296a:	4607      	mov	r7, r0
 800296c:	ee67 7aa8 	vmul.f32	s15, s15, s17
 8002970:	ee67 7a88 	vmul.f32	s15, s15, s16
 8002974:	ee17 0a90 	vmov	r0, s15
 8002978:	f7fd fe16 	bl	80005a8 <__aeabi_f2d>
 800297c:	463a      	mov	r2, r7
 800297e:	e9cd 0100 	strd	r0, r1, [sp]
 8002982:	495a      	ldr	r1, [pc, #360]	; (8002aec <main+0x8fc>)
 8002984:	484a      	ldr	r0, [pc, #296]	; (8002ab0 <main+0x8c0>)
 8002986:	f000 fadb 	bl	8002f40 <chprintf.lto_priv.79>
			chprintf((BaseSequentialStream *)&SD1, "[%010d] GAS2 ADC volt     : %01.3f V\r\n", chVTGetSystemTime(), ((float_t)samples2[3]*3.29)/4096);
 800298a:	f000 fd49 	bl	8003420 <chVTGetSystemTime.lto_priv.80>
 800298e:	88f3      	ldrh	r3, [r6, #6]
 8002990:	ee07 3a90 	vmov	s15, r3
 8002994:	eef8 7a67 	vcvt.f32.u32	s15, s15
 8002998:	4607      	mov	r7, r0
 800299a:	ee67 7aa8 	vmul.f32	s15, s15, s17
 800299e:	ee67 7a88 	vmul.f32	s15, s15, s16
 80029a2:	ee17 0a90 	vmov	r0, s15
 80029a6:	f7fd fdff 	bl	80005a8 <__aeabi_f2d>
 80029aa:	463a      	mov	r2, r7
 80029ac:	e9cd 0100 	strd	r0, r1, [sp]
 80029b0:	483f      	ldr	r0, [pc, #252]	; (8002ab0 <main+0x8c0>)
 80029b2:	494f      	ldr	r1, [pc, #316]	; (8002af0 <main+0x900>)
 80029b4:	f000 fac4 	bl	8002f40 <chprintf.lto_priv.79>

			chThdSleepMilliseconds(2000);
 80029b8:	f644 6020 	movw	r0, #20000	; 0x4e20
 80029bc:	f7fe fa90 	bl	8000ee0 <chThdSleep>
	 * sleeping in a loop and check the button state, when the button is
	 * pressed the test procedure is launched with output on the serial
	 * driver 1.
	 */
	while (true) {
		if (!shelltp1)
 80029c0:	2d00      	cmp	r5, #0
 80029c2:	d162      	bne.n	8002a8a <main+0x89a>
  }

  size = MEM_ALIGN_NEXT(size);
  qp = &heapp->h_free;

  H_LOCK(heapp);
 80029c4:	484b      	ldr	r0, [pc, #300]	; (8002af4 <main+0x904>)
 80029c6:	f7fe fb0b 	bl	8000fe0 <chMtxLock>
  if (heapp == NULL) {
    heapp = &default_heap;
  }

  size = MEM_ALIGN_NEXT(size);
  qp = &heapp->h_free;
 80029ca:	494b      	ldr	r1, [pc, #300]	; (8002af8 <main+0x908>)
 80029cc:	e735      	b.n	800283a <main+0x64a>

  H_LOCK(heapp);
  while (qp->h.u.next != NULL) {
    hp = qp->h.u.next;
    if (hp->h.size >= size) {
 80029ce:	685a      	ldr	r2, [r3, #4]
 80029d0:	f5b2 6f15 	cmp.w	r2, #2384	; 0x950
 80029d4:	f4ff af30 	bcc.w	8002838 <main+0x648>
      if (hp->h.size < (size + sizeof(union heap_header))) {
 80029d8:	f640 1057 	movw	r0, #2391	; 0x957
 80029dc:	4282      	cmp	r2, r0
 80029de:	681d      	ldr	r5, [r3, #0]
      else {
        /* Block bigger enough, must split it.*/
        /*lint -save -e9087 [11.3] Safe cast.*/
        fp = (void *)((uint8_t *)(hp) + sizeof(union heap_header) + size);
        /*lint -restore*/
        fp->h.u.next = hp->h.u.next;
 80029e0:	bf81      	itttt	hi
 80029e2:	f8c3 5958 	strhi.w	r5, [r3, #2392]	; 0x958
        fp->h.size = (hp->h.size - sizeof(union heap_header)) - size;
 80029e6:	f6a2 1258 	subwhi	r2, r2, #2392	; 0x958
 80029ea:	f8c3 295c 	strhi.w	r2, [r3, #2396]	; 0x95c
      else {
        /* Block bigger enough, must split it.*/
        /*lint -save -e9087 [11.3] Safe cast.*/
        fp = (void *)((uint8_t *)(hp) + sizeof(union heap_header) + size);
        /*lint -restore*/
        fp->h.u.next = hp->h.u.next;
 80029ee:	f603 1058 	addwhi	r0, r3, #2392	; 0x958
    if (hp->h.size >= size) {
      if (hp->h.size < (size + sizeof(union heap_header))) {
        /* Gets the whole block even if it is slightly bigger than the
           requested size because the fragment would be too small to be
           useful.*/
        qp->h.u.next = hp->h.u.next;
 80029f2:	bf94      	ite	ls
 80029f4:	600d      	strls	r5, [r1, #0]
        fp = (void *)((uint8_t *)(hp) + sizeof(union heap_header) + size);
        /*lint -restore*/
        fp->h.u.next = hp->h.u.next;
        fp->h.size = (hp->h.size - sizeof(union heap_header)) - size;
        qp->h.u.next = fp;
        hp->h.size = size;
 80029f6:	f44f 6215 	movhi.w	r2, #2384	; 0x950
      }
      hp->h.u.heap = heapp;
 80029fa:	461d      	mov	r5, r3
        /*lint -save -e9087 [11.3] Safe cast.*/
        fp = (void *)((uint8_t *)(hp) + sizeof(union heap_header) + size);
        /*lint -restore*/
        fp->h.u.next = hp->h.u.next;
        fp->h.size = (hp->h.size - sizeof(union heap_header)) - size;
        qp->h.u.next = fp;
 80029fc:	bf84      	itt	hi
 80029fe:	6008      	strhi	r0, [r1, #0]
        hp->h.size = size;
 8002a00:	605a      	strhi	r2, [r3, #4]
      }
      hp->h.u.heap = heapp;
 8002a02:	9b04      	ldr	r3, [sp, #16]
 8002a04:	f845 3b08 	str.w	r3, [r5], #8
      H_UNLOCK(heapp);
 8002a08:	483a      	ldr	r0, [pc, #232]	; (8002af4 <main+0x904>)
 8002a0a:	f7fe fab1 	bl	8000f70 <chMtxUnlock>
 8002a0e:	e00b      	b.n	8002a28 <main+0x838>
  H_UNLOCK(heapp);

  /* More memory is required, tries to get it from the associated provider
     else fails.*/
  if (heapp->h_provider != NULL) {
    hp = heapp->h_provider(size + sizeof(union heap_header));
 8002a10:	f640 1058 	movw	r0, #2392	; 0x958
 8002a14:	4798      	blx	r3
    if (hp != NULL) {
 8002a16:	2800      	cmp	r0, #0
 8002a18:	f43f af1d 	beq.w	8002856 <main+0x666>
      hp->h.u.heap = heapp;
      hp->h.size = size;
 8002a1c:	f44f 6315 	mov.w	r3, #2384	; 0x950
  /* More memory is required, tries to get it from the associated provider
     else fails.*/
  if (heapp->h_provider != NULL) {
    hp = heapp->h_provider(size + sizeof(union heap_header));
    if (hp != NULL) {
      hp->h.u.heap = heapp;
 8002a20:	6007      	str	r7, [r0, #0]
      hp->h.size = size;
 8002a22:	6043      	str	r3, [r0, #4]
      hp++;
 8002a24:	f100 0508 	add.w	r5, r0, #8
                              tprio_t prio, tfunc_t pf, void *arg) {
  void *wsp;
  thread_t *tp;

  wsp = chHeapAlloc(heapp, size);
  if (wsp == NULL) {
 8002a28:	2d00      	cmp	r5, #0
 8002a2a:	f43f af14 	beq.w	8002856 <main+0x666>
 8002a2e:	2320      	movs	r3, #32
 8002a30:	f383 8811 	msr	BASEPRI, r3

  chDbgCheckClassI();
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 8002a34:	f605 03ec 	addw	r3, r5, #2284	; 0x8ec
 8002a38:	60eb      	str	r3, [r5, #12]
 8002a3a:	4b30      	ldr	r3, [pc, #192]	; (8002afc <main+0x90c>)
 8002a3c:	f8c5 392c 	str.w	r3, [r5, #2348]	; 0x92c
 8002a40:	4b2f      	ldr	r3, [pc, #188]	; (8002b00 <main+0x910>)
 8002a42:	f8c5 3930 	str.w	r3, [r5, #2352]	; 0x930
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
 8002a46:	2240      	movs	r2, #64	; 0x40

  chDbgCheckClassI();
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 8002a48:	4b2e      	ldr	r3, [pc, #184]	; (8002b04 <main+0x914>)
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
 8002a4a:	60aa      	str	r2, [r5, #8]

  chDbgCheckClassI();
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 8002a4c:	f8c5 394c 	str.w	r3, [r5, #2380]	; 0x94c
  tp->p_flags = CH_FLAG_MODE_STATIC;
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->p_realprio = prio;
 8002a50:	63ea      	str	r2, [r5, #60]	; 0x3c
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
 8002a52:	2302      	movs	r3, #2
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
 8002a54:	6962      	ldr	r2, [r4, #20]
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
 8002a56:	772b      	strb	r3, [r5, #28]
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->p_realprio = prio;
  tp->p_mtxlist = NULL;
 8002a58:	2700      	movs	r7, #0

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
  tp->p_flags = CH_FLAG_MODE_STATIC;
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
 8002a5a:	2301      	movs	r3, #1
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
 8002a5c:	616a      	str	r2, [r5, #20]
 8002a5e:	612c      	str	r4, [r5, #16]

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
  tp->p_flags = CH_FLAG_MODE_STATIC;
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
 8002a60:	77eb      	strb	r3, [r5, #31]
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->p_realprio = prio;
  tp->p_mtxlist = NULL;
 8002a62:	63af      	str	r7, [r5, #56]	; 0x38
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->p_epending = (eventmask_t)0;
 8002a64:	636f      	str	r7, [r5, #52]	; 0x34
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->p_time = (systime_t)0;
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
 8002a66:	77ab      	strb	r3, [r5, #30]
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
 8002a68:	61af      	str	r7, [r5, #24]
  REG_INSERT(tp);
 8002a6a:	6115      	str	r5, [r2, #16]
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  list_init(&tp->p_waiting);
 8002a6c:	f105 0224 	add.w	r2, r5, #36	; 0x24
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {

  tlp->p_next = (thread_t *)tlp;
 8002a70:	626a      	str	r2, [r5, #36]	; 0x24
#endif
#if CH_CFG_USE_MESSAGES == TRUE
  queue_init(&tp->p_msgqueue);
 8002a72:	f105 0228 	add.w	r2, r5, #40	; 0x28
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8002a76:	62aa      	str	r2, [r5, #40]	; 0x28
  tqp->p_prev = (thread_t *)tqp;
 8002a78:	62ea      	str	r2, [r5, #44]	; 0x2c
                  CH_DBG_STACK_FILL_VALUE);
#endif
  
  chSysLock();
  tp = chThdCreateI(wsp, size, prio, pf, arg);
  tp->p_flags = CH_FLAG_MODE_HEAP;
 8002a7a:	776b      	strb	r3, [r5, #29]
  chSchWakeupS(tp, MSG_OK);
 8002a7c:	4628      	mov	r0, r5
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
 8002a7e:	6165      	str	r5, [r4, #20]
 8002a80:	f000 fd56 	bl	8003530 <chSchWakeupS.constprop.50>
 8002a84:	f387 8811 	msr	BASEPRI, r7
 8002a88:	e6e5      	b.n	8002856 <main+0x666>
			shelltp1 = shellCreate(&shell_cfg1, SHELL_WA_SIZE, NORMALPRIO);
		else if (chThdTerminatedX(shelltp1)) {
 8002a8a:	7f2b      	ldrb	r3, [r5, #28]
 8002a8c:	2b0f      	cmp	r3, #15
 8002a8e:	f47f aee2 	bne.w	8002856 <main+0x666>
			chThdRelease(shelltp1);   /* Recovers memory of the previous shell.   */
 8002a92:	4628      	mov	r0, r5
 8002a94:	f7fe faec 	bl	8001070 <chThdRelease>
			shelltp1 = NULL;          /* Triggers spawning of a new shell.        */
 8002a98:	2500      	movs	r5, #0
 8002a9a:	e6dc      	b.n	8002856 <main+0x666>
 8002a9c:	200011c8 	.word	0x200011c8
 8002aa0:	20000f84 	.word	0x20000f84
 8002aa4:	20001214 	.word	0x20001214
 8002aa8:	08003e9a 	.word	0x08003e9a
 8002aac:	3fe66666 	.word	0x3fe66666
 8002ab0:	20000e88 	.word	0x20000e88
 8002ab4:	20000e84 	.word	0x20000e84
 8002ab8:	3bf5c7e8 	.word	0x3bf5c7e8
 8002abc:	08003ec0 	.word	0x08003ec0
 8002ac0:	42000000 	.word	0x42000000
 8002ac4:	2000125c 	.word	0x2000125c
 8002ac8:	08003ef4 	.word	0x08003ef4
 8002acc:	20001210 	.word	0x20001210
 8002ad0:	08003f2e 	.word	0x08003f2e
 8002ad4:	20001260 	.word	0x20001260
 8002ad8:	08003f5a 	.word	0x08003f5a
 8002adc:	40528f5c 	.word	0x40528f5c
 8002ae0:	39800000 	.word	0x39800000
 8002ae4:	08003f94 	.word	0x08003f94
 8002ae8:	08003fbb 	.word	0x08003fbb
 8002aec:	08003fe2 	.word	0x08003fe2
 8002af0:	08004009 	.word	0x08004009
 8002af4:	200011d8 	.word	0x200011d8
 8002af8:	200011d0 	.word	0x200011d0
 8002afc:	08002d41 	.word	0x08002d41
 8002b00:	08004090 	.word	0x08004090
 8002b04:	080002c9 	.word	0x080002c9
	...

08002b10 <adcerrorcallback.lto_priv.68>:
  else {
    ny += n;
  }
}

static void adcerrorcallback(ADCDriver *adcp, adcerror_t err) {
 8002b10:	4770      	bx	lr
	...

08002b20 <adccallback.lto_priv.69>:
 */
size_t nx = 0, ny = 0;
static void adccallback(ADCDriver *adcp, adcsample_t *buffer, size_t n) {

  (void)adcp;
  if (samples2 == buffer) {
 8002b20:	4b06      	ldr	r3, [pc, #24]	; (8002b3c <adccallback.lto_priv.69+0x1c>)
 8002b22:	428b      	cmp	r3, r1
    nx += n;
 8002b24:	bf0b      	itete	eq
 8002b26:	4b06      	ldreq	r3, [pc, #24]	; (8002b40 <adccallback.lto_priv.69+0x20>)
  }
  else {
    ny += n;
 8002b28:	4906      	ldrne	r1, [pc, #24]	; (8002b44 <adccallback.lto_priv.69+0x24>)
size_t nx = 0, ny = 0;
static void adccallback(ADCDriver *adcp, adcsample_t *buffer, size_t n) {

  (void)adcp;
  if (samples2 == buffer) {
    nx += n;
 8002b2a:	6819      	ldreq	r1, [r3, #0]
  }
  else {
    ny += n;
 8002b2c:	680b      	ldrne	r3, [r1, #0]
size_t nx = 0, ny = 0;
static void adccallback(ADCDriver *adcp, adcsample_t *buffer, size_t n) {

  (void)adcp;
  if (samples2 == buffer) {
    nx += n;
 8002b2e:	bf0b      	itete	eq
 8002b30:	1889      	addeq	r1, r1, r2
  }
  else {
    ny += n;
 8002b32:	189b      	addne	r3, r3, r2
size_t nx = 0, ny = 0;
static void adccallback(ADCDriver *adcp, adcsample_t *buffer, size_t n) {

  (void)adcp;
  if (samples2 == buffer) {
    nx += n;
 8002b34:	6019      	streq	r1, [r3, #0]
  }
  else {
    ny += n;
 8002b36:	600b      	strne	r3, [r1, #0]
 8002b38:	4770      	bx	lr
 8002b3a:	bf00      	nop
 8002b3c:	20000f86 	.word	0x20000f86
 8002b40:	200019b0 	.word	0x200019b0
 8002b44:	200019b4 	.word	0x200019b4
	...

08002b50 <Thread1.lto_priv.60>:
/*
 * RGB LED blinker thread, times are in milliseconds.
 */
static THD_WORKING_AREA(waThread1, 128);
static THD_FUNCTION(Thread1, arg)
{
 8002b50:	b508      	push	{r3, lr}
 * @api
 */
static inline void chRegSetThreadName(const char *name) {

#if CH_CFG_USE_REGISTRY == TRUE
  ch.rlist.r_current->p_name = name;
 8002b52:	4b10      	ldr	r3, [pc, #64]	; (8002b94 <Thread1.lto_priv.60+0x44>)
 8002b54:	4a10      	ldr	r2, [pc, #64]	; (8002b98 <Thread1.lto_priv.60+0x48>)
 8002b56:	699b      	ldr	r3, [r3, #24]
 8002b58:	619a      	str	r2, [r3, #24]
	//palSetPadMode(GPIOB, GPIOB_LED_GREEN, PAL_MODE_ALTERNATE(2)); /* Green */

	/* just to check dust sensor outputs */
	while (1)
	{
		palClearPad(GPIOB, GPIOB_LED_GREEN);
 8002b5a:	4b10      	ldr	r3, [pc, #64]	; (8002b9c <Thread1.lto_priv.60+0x4c>)
 8002b5c:	2201      	movs	r2, #1
 8002b5e:	835a      	strh	r2, [r3, #26]
		
		if (palReadPad(GPIOA, GPIOA_PIN0))
 8002b60:	f04f 4390 	mov.w	r3, #1207959552	; 0x48000000
		{	
			palSetPad(GPIOA, GPIOA_LED_BLUE);
			palClearPad(GPIOA, GPIOA_LED_RED);
		}

		chThdSleepMilliseconds(2);
 8002b64:	2014      	movs	r0, #20
	/* just to check dust sensor outputs */
	while (1)
	{
		palClearPad(GPIOB, GPIOB_LED_GREEN);
		
		if (palReadPad(GPIOA, GPIOA_PIN0))
 8002b66:	691a      	ldr	r2, [r3, #16]
 8002b68:	f012 0f01 	tst.w	r2, #1
 8002b6c:	f04f 0280 	mov.w	r2, #128	; 0x80
			palClearPad(GPIOA, GPIOA_LED_RED);
		else	
			palSetPad(GPIOA, GPIOA_LED_RED);
 8002b70:	bf0c      	ite	eq
 8002b72:	831a      	strheq	r2, [r3, #24]
	while (1)
	{
		palClearPad(GPIOB, GPIOB_LED_GREEN);
		
		if (palReadPad(GPIOA, GPIOA_PIN0))
			palClearPad(GPIOA, GPIOA_LED_RED);
 8002b74:	835a      	strhne	r2, [r3, #26]
		else	
			palSetPad(GPIOA, GPIOA_LED_RED);

		if (palReadPad(GPIOA, GPIOA_PIN1))
 8002b76:	691b      	ldr	r3, [r3, #16]
 8002b78:	f04f 4290 	mov.w	r2, #1207959552	; 0x48000000
 8002b7c:	f013 0f02 	tst.w	r3, #2
 8002b80:	f04f 0340 	mov.w	r3, #64	; 0x40
			palClearPad(GPIOA, GPIOA_LED_BLUE);
		else
		{	
			palSetPad(GPIOA, GPIOA_LED_BLUE);
 8002b84:	bf04      	itt	eq
 8002b86:	8313      	strheq	r3, [r2, #24]
			palClearPad(GPIOA, GPIOA_LED_RED);
 8002b88:	2380      	moveq	r3, #128	; 0x80
 8002b8a:	8353      	strh	r3, [r2, #26]
		}

		chThdSleepMilliseconds(2);
 8002b8c:	f7fe f9a8 	bl	8000ee0 <chThdSleep>
 8002b90:	e7e3      	b.n	8002b5a <Thread1.lto_priv.60+0xa>
 8002b92:	bf00      	nop
 8002b94:	20001a00 	.word	0x20001a00
 8002b98:	080041a0 	.word	0x080041a0
 8002b9c:	48000400 	.word	0x48000400

08002ba0 <Thread2.lto_priv.61>:
/*
 * MH-Z14 CO2 NDIR sensor module readout
 */
static THD_WORKING_AREA(waThread2, 128);
static THD_FUNCTION(Thread2, arg)
{
 8002ba0:	b500      	push	{lr}
 8002ba2:	4b22      	ldr	r3, [pc, #136]	; (8002c2c <Thread2.lto_priv.61+0x8c>)
 8002ba4:	4a22      	ldr	r2, [pc, #136]	; (8002c30 <Thread2.lto_priv.61+0x90>)
 8002ba6:	699b      	ldr	r3, [r3, #24]
 8002ba8:	b08b      	sub	sp, #44	; 0x2c
 8002baa:	619a      	str	r2, [r3, #24]
	(void)arg;
	chRegSetThreadName("co2_read");
	
	uint8_t to_mhz14[9]={ 0xFF, 0x01, 0x86, 0x00, 0x00, 0x00, 0x00, 0x79 };
 8002bac:	2100      	movs	r1, #0
 8002bae:	2209      	movs	r2, #9
 8002bb0:	4668      	mov	r0, sp
 8002bb2:	f000 ff45 	bl	8003a40 <memset>
 8002bb6:	23ff      	movs	r3, #255	; 0xff
 8002bb8:	f88d 3000 	strb.w	r3, [sp]
 8002bbc:	2301      	movs	r3, #1
 8002bbe:	f88d 3001 	strb.w	r3, [sp, #1]
 8002bc2:	2386      	movs	r3, #134	; 0x86
 8002bc4:	f88d 3002 	strb.w	r3, [sp, #2]
 8002bc8:	2379      	movs	r3, #121	; 0x79
 8002bca:	f88d 3007 	strb.w	r3, [sp, #7]
	/*
	 * Activates the serial driver 2 using the driver default configuration.
	 * PA2 and PA3 are routed to USART2 and MH-Z14 CO2 NDIR sensor module.
	 * 9600, 8, N , 1 settings.
	 */
	const SerialConfig SD2_config = { 
 8002bce:	4b19      	ldr	r3, [pc, #100]	; (8002c34 <Thread2.lto_priv.61+0x94>)
 8002bd0:	cb0f      	ldmia	r3, {r0, r1, r2, r3}
 8002bd2:	ac06      	add	r4, sp, #24
 8002bd4:	e884 000f 	stmia.w	r4, {r0, r1, r2, r3}
		9600,
		0,
		USART_CR2_STOP1_BITS | USART_CR2_LINEN,
		0 };
	sdStart(&SD2, &SD2_config);
 8002bd8:	4817      	ldr	r0, [pc, #92]	; (8002c38 <Thread2.lto_priv.61+0x98>)
 8002bda:	4621      	mov	r1, r4
 8002bdc:	f7fd fdf8 	bl	80007d0 <sdStart>
	palSetPadMode(GPIOA, 2, PAL_MODE_ALTERNATE(7));	/* USART2 TX. */
 8002be0:	2004      	movs	r0, #4
 8002be2:	f000 fe15 	bl	8003810 <_pal_lld_setgroupmode.constprop.9>
	palSetPadMode(GPIOA, 3, PAL_MODE_ALTERNATE(7));	/* USART3 RX. */
 8002be6:	2008      	movs	r0, #8
 8002be8:	f000 fe12 	bl	8003810 <_pal_lld_setgroupmode.constprop.9>

	while (true) {
		sdWrite(&SD2, to_mhz14, 9);
 8002bec:	4669      	mov	r1, sp
 8002bee:	2209      	movs	r2, #9
 8002bf0:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8002bf4:	4811      	ldr	r0, [pc, #68]	; (8002c3c <Thread2.lto_priv.61+0x9c>)
 8002bf6:	f7fe f86b 	bl	8000cd0 <chOQWriteTimeout>
		chThdSleepMilliseconds(800);
 8002bfa:	f44f 50fa 	mov.w	r0, #8000	; 0x1f40
 8002bfe:	f7fe f96f 	bl	8000ee0 <chThdSleep>
		sdRead(&SD2, from_mhz14, 9);
 8002c02:	a903      	add	r1, sp, #12
 8002c04:	2209      	movs	r2, #9
 8002c06:	f04f 33ff 	mov.w	r3, #4294967295	; 0xffffffff
 8002c0a:	480d      	ldr	r0, [pc, #52]	; (8002c40 <Thread2.lto_priv.61+0xa0>)
 8002c0c:	f7fe f8e8 	bl	8000de0 <chIQReadTimeout>
		co2_ppm = (uint16_t)(from_mhz14[2]<<8) | (uint16_t)from_mhz14[3];
 8002c10:	f89d 200e 	ldrb.w	r2, [sp, #14]
 8002c14:	f89d 300f 	ldrb.w	r3, [sp, #15]
 8002c18:	ea43 2302 	orr.w	r3, r3, r2, lsl #8
 8002c1c:	4a09      	ldr	r2, [pc, #36]	; (8002c44 <Thread2.lto_priv.61+0xa4>)
		chThdSleepMilliseconds(500);
 8002c1e:	f241 3088 	movw	r0, #5000	; 0x1388

	while (true) {
		sdWrite(&SD2, to_mhz14, 9);
		chThdSleepMilliseconds(800);
		sdRead(&SD2, from_mhz14, 9);
		co2_ppm = (uint16_t)(from_mhz14[2]<<8) | (uint16_t)from_mhz14[3];
 8002c22:	8013      	strh	r3, [r2, #0]
		chThdSleepMilliseconds(500);
 8002c24:	f7fe f95c 	bl	8000ee0 <chThdSleep>
 8002c28:	e7e0      	b.n	8002bec <Thread2.lto_priv.61+0x4c>
 8002c2a:	bf00      	nop
 8002c2c:	20001a00 	.word	0x20001a00
 8002c30:	080041a9 	.word	0x080041a9
 8002c34:	08003c30 	.word	0x08003c30
 8002c38:	20000f04 	.word	0x20000f04
 8002c3c:	20000f34 	.word	0x20000f34
 8002c40:	20000f10 	.word	0x20000f10
 8002c44:	20001214 	.word	0x20001214
	...

08002c50 <cmd_systime>:
}

static void cmd_systime(BaseSequentialStream *chp, int argc, char *argv[]) {

  (void)argv;
  if (argc > 0) {
 8002c50:	2900      	cmp	r1, #0
 8002c52:	dd02      	ble.n	8002c5a <cmd_systime+0xa>
  return *token ? token : NULL;
}

static void usage(BaseSequentialStream *chp, char *p) {

  chprintf(chp, "Usage: %s\r\n", p);
 8002c54:	4906      	ldr	r1, [pc, #24]	; (8002c70 <cmd_systime+0x20>)
 8002c56:	4a07      	ldr	r2, [pc, #28]	; (8002c74 <cmd_systime+0x24>)
 8002c58:	e008      	b.n	8002c6c <cmd_systime+0x1c>
 8002c5a:	2320      	movs	r3, #32
 8002c5c:	f383 8811 	msr	BASEPRI, r3
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {

#if CH_CFG_ST_TIMEDELTA == 0
  return ch.vtlist.vt_systime;
 8002c60:	4b05      	ldr	r3, [pc, #20]	; (8002c78 <cmd_systime+0x28>)
 8002c62:	6a9a      	ldr	r2, [r3, #40]	; 0x28
 8002c64:	2300      	movs	r3, #0
 8002c66:	f383 8811 	msr	BASEPRI, r3
  (void)argv;
  if (argc > 0) {
    usage(chp, "systime");
    return;
  }
  chprintf(chp, "%lu\r\n", (unsigned long)chVTGetSystemTime());
 8002c6a:	4904      	ldr	r1, [pc, #16]	; (8002c7c <cmd_systime+0x2c>)
 8002c6c:	f7ff b900 	b.w	8001e70 <chprintf.lto_priv.86>
 8002c70:	080041b2 	.word	0x080041b2
 8002c74:	080041be 	.word	0x080041be
 8002c78:	20001a00 	.word	0x20001a00
 8002c7c:	0800452e 	.word	0x0800452e

08002c80 <cmd_info>:
}

static void cmd_info(BaseSequentialStream *chp, int argc, char *argv[]) {

  (void)argv;
  if (argc > 0) {
 8002c80:	2900      	cmp	r1, #0
    chprintf(chp, "%s ", scp->sc_name);
    scp++;
  }
}

static void cmd_info(BaseSequentialStream *chp, int argc, char *argv[]) {
 8002c82:	b513      	push	{r0, r1, r4, lr}
 8002c84:	4604      	mov	r4, r0

  (void)argv;
  if (argc > 0) {
 8002c86:	dd06      	ble.n	8002c96 <cmd_info+0x16>
  return *token ? token : NULL;
}

static void usage(BaseSequentialStream *chp, char *p) {

  chprintf(chp, "Usage: %s\r\n", p);
 8002c88:	4919      	ldr	r1, [pc, #100]	; (8002cf0 <cmd_info+0x70>)
 8002c8a:	4a1a      	ldr	r2, [pc, #104]	; (8002cf4 <cmd_info+0x74>)
#ifdef __DATE__
#ifdef __TIME__
  chprintf(chp, "Build time:   %s%s%s\r\n", __DATE__, " - ", __TIME__);
#endif
#endif
}
 8002c8c:	b002      	add	sp, #8
 8002c8e:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  return *token ? token : NULL;
}

static void usage(BaseSequentialStream *chp, char *p) {

  chprintf(chp, "Usage: %s\r\n", p);
 8002c92:	f7ff b8ed 	b.w	8001e70 <chprintf.lto_priv.86>
  if (argc > 0) {
    usage(chp, "info");
    return;
  }

  chprintf(chp, "Kernel:       %s\r\n", CH_KERNEL_VERSION);
 8002c96:	4918      	ldr	r1, [pc, #96]	; (8002cf8 <cmd_info+0x78>)
 8002c98:	4a18      	ldr	r2, [pc, #96]	; (8002cfc <cmd_info+0x7c>)
 8002c9a:	f7ff f8e9 	bl	8001e70 <chprintf.lto_priv.86>
#ifdef PORT_COMPILER_NAME
  chprintf(chp, "Compiler:     %s\r\n", PORT_COMPILER_NAME);
 8002c9e:	4620      	mov	r0, r4
 8002ca0:	4917      	ldr	r1, [pc, #92]	; (8002d00 <cmd_info+0x80>)
 8002ca2:	4a18      	ldr	r2, [pc, #96]	; (8002d04 <cmd_info+0x84>)
 8002ca4:	f7ff f8e4 	bl	8001e70 <chprintf.lto_priv.86>
#endif
  chprintf(chp, "Architecture: %s\r\n", PORT_ARCHITECTURE_NAME);
 8002ca8:	4620      	mov	r0, r4
 8002caa:	4917      	ldr	r1, [pc, #92]	; (8002d08 <cmd_info+0x88>)
 8002cac:	4a17      	ldr	r2, [pc, #92]	; (8002d0c <cmd_info+0x8c>)
 8002cae:	f7ff f8df 	bl	8001e70 <chprintf.lto_priv.86>
#ifdef PORT_CORE_VARIANT_NAME
  chprintf(chp, "Core Variant: %s\r\n", PORT_CORE_VARIANT_NAME);
 8002cb2:	4620      	mov	r0, r4
 8002cb4:	4916      	ldr	r1, [pc, #88]	; (8002d10 <cmd_info+0x90>)
 8002cb6:	4a17      	ldr	r2, [pc, #92]	; (8002d14 <cmd_info+0x94>)
 8002cb8:	f7ff f8da 	bl	8001e70 <chprintf.lto_priv.86>
#endif
#ifdef PORT_INFO
  chprintf(chp, "Port Info:    %s\r\n", PORT_INFO);
 8002cbc:	4620      	mov	r0, r4
 8002cbe:	4916      	ldr	r1, [pc, #88]	; (8002d18 <cmd_info+0x98>)
 8002cc0:	4a16      	ldr	r2, [pc, #88]	; (8002d1c <cmd_info+0x9c>)
 8002cc2:	f7ff f8d5 	bl	8001e70 <chprintf.lto_priv.86>
#endif
#ifdef PLATFORM_NAME
  chprintf(chp, "Platform:     %s\r\n", PLATFORM_NAME);
 8002cc6:	4620      	mov	r0, r4
 8002cc8:	4915      	ldr	r1, [pc, #84]	; (8002d20 <cmd_info+0xa0>)
 8002cca:	4a16      	ldr	r2, [pc, #88]	; (8002d24 <cmd_info+0xa4>)
 8002ccc:	f7ff f8d0 	bl	8001e70 <chprintf.lto_priv.86>
#endif
#ifdef BOARD_NAME
  chprintf(chp, "Board:        %s\r\n", BOARD_NAME);
 8002cd0:	4620      	mov	r0, r4
 8002cd2:	4915      	ldr	r1, [pc, #84]	; (8002d28 <cmd_info+0xa8>)
 8002cd4:	4a15      	ldr	r2, [pc, #84]	; (8002d2c <cmd_info+0xac>)
 8002cd6:	f7ff f8cb 	bl	8001e70 <chprintf.lto_priv.86>
#endif
#ifdef __DATE__
#ifdef __TIME__
  chprintf(chp, "Build time:   %s%s%s\r\n", __DATE__, " - ", __TIME__);
 8002cda:	4b15      	ldr	r3, [pc, #84]	; (8002d30 <cmd_info+0xb0>)
 8002cdc:	9300      	str	r3, [sp, #0]
 8002cde:	4620      	mov	r0, r4
 8002ce0:	4914      	ldr	r1, [pc, #80]	; (8002d34 <cmd_info+0xb4>)
 8002ce2:	4a15      	ldr	r2, [pc, #84]	; (8002d38 <cmd_info+0xb8>)
 8002ce4:	4b15      	ldr	r3, [pc, #84]	; (8002d3c <cmd_info+0xbc>)
 8002ce6:	f7ff f8c3 	bl	8001e70 <chprintf.lto_priv.86>
#endif
#endif
}
 8002cea:	b002      	add	sp, #8
 8002cec:	bd10      	pop	{r4, pc}
 8002cee:	bf00      	nop
 8002cf0:	080041b2 	.word	0x080041b2
 8002cf4:	080041c6 	.word	0x080041c6
 8002cf8:	080041cb 	.word	0x080041cb
 8002cfc:	080041de 	.word	0x080041de
 8002d00:	080041e4 	.word	0x080041e4
 8002d04:	080041f7 	.word	0x080041f7
 8002d08:	08004217 	.word	0x08004217
 8002d0c:	0800422a 	.word	0x0800422a
 8002d10:	08004233 	.word	0x08004233
 8002d14:	08004246 	.word	0x08004246
 8002d18:	08004251 	.word	0x08004251
 8002d1c:	08004264 	.word	0x08004264
 8002d20:	08004279 	.word	0x08004279
 8002d24:	0800428c 	.word	0x0800428c
 8002d28:	080042a5 	.word	0x080042a5
 8002d2c:	080042b8 	.word	0x080042b8
 8002d30:	080042f0 	.word	0x080042f0
 8002d34:	080042c9 	.word	0x080042c9
 8002d38:	080042e0 	.word	0x080042e0
 8002d3c:	080042ec 	.word	0x080042ec

08002d40 <shell_thread.lto_priv.63>:
/**
 * @brief   Shell thread function.
 *
 * @param[in] p         pointer to a @p BaseSequentialStream object
 */
static THD_FUNCTION(shell_thread, p) {
 8002d40:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 8002d44:	4b6d      	ldr	r3, [pc, #436]	; (8002efc <shell_thread.lto_priv.63+0x1bc>)
 8002d46:	4a6e      	ldr	r2, [pc, #440]	; (8002f00 <shell_thread.lto_priv.63+0x1c0>)
 8002d48:	699b      	ldr	r3, [r3, #24]
  const ShellCommand *scp = ((ShellConfig *)p)->sc_commands;
  char *lp, *cmd, *tokp, line[SHELL_MAX_LINE_LENGTH];
  char *args[SHELL_MAX_ARGUMENTS + 1];

  chRegSetThreadName("shell");
  chprintf(chp, "\r\nChibiOS/RT Shell\r\n");
 8002d4a:	496e      	ldr	r1, [pc, #440]	; (8002f04 <shell_thread.lto_priv.63+0x1c4>)
 * @param[in] p         pointer to a @p BaseSequentialStream object
 */
static THD_FUNCTION(shell_thread, p) {
  int n;
  BaseSequentialStream *chp = ((ShellConfig *)p)->sc_channel;
  const ShellCommand *scp = ((ShellConfig *)p)->sc_commands;
 8002d4c:	e890 0090 	ldmia.w	r0, {r4, r7}
/**
 * @brief   Shell thread function.
 *
 * @param[in] p         pointer to a @p BaseSequentialStream object
 */
static THD_FUNCTION(shell_thread, p) {
 8002d50:	b098      	sub	sp, #96	; 0x60
 8002d52:	619a      	str	r2, [r3, #24]
  const ShellCommand *scp = ((ShellConfig *)p)->sc_commands;
  char *lp, *cmd, *tokp, line[SHELL_MAX_LINE_LENGTH];
  char *args[SHELL_MAX_ARGUMENTS + 1];

  chRegSetThreadName("shell");
  chprintf(chp, "\r\nChibiOS/RT Shell\r\n");
 8002d54:	4620      	mov	r0, r4
 8002d56:	f7ff f88b 	bl	8001e70 <chprintf.lto_priv.86>
  while (true) {
    chprintf(chp, "owl> ");
 8002d5a:	4620      	mov	r0, r4
 8002d5c:	496a      	ldr	r1, [pc, #424]	; (8002f08 <shell_thread.lto_priv.63+0x1c8>)
 8002d5e:	f7ff f887 	bl	8001e70 <chprintf.lto_priv.86>
 * @retval false        operation successful.
 *
 * @api
 */
bool shellGetLine(BaseSequentialStream *chp, char *line, unsigned size) {
  char *p = line;
 8002d62:	ae08      	add	r6, sp, #32
 8002d64:	46b0      	mov	r8, r6

  while (true) {
    char c;

    if (chSequentialStreamRead(chp, (uint8_t *)&c, 1) == 0)
 8002d66:	6823      	ldr	r3, [r4, #0]
 8002d68:	4620      	mov	r0, r4
 8002d6a:	685b      	ldr	r3, [r3, #4]
 8002d6c:	f10d 0107 	add.w	r1, sp, #7
 8002d70:	2201      	movs	r2, #1
 8002d72:	4798      	blx	r3
 8002d74:	2800      	cmp	r0, #0
 8002d76:	d03c      	beq.n	8002df2 <shell_thread.lto_priv.63+0xb2>
      return true;
    if (c == 4) {
 8002d78:	f89d 1007 	ldrb.w	r1, [sp, #7]
 8002d7c:	2904      	cmp	r1, #4
 8002d7e:	d104      	bne.n	8002d8a <shell_thread.lto_priv.63+0x4a>
      chprintf(chp, "^D");
 8002d80:	4620      	mov	r0, r4
 8002d82:	4962      	ldr	r1, [pc, #392]	; (8002f0c <shell_thread.lto_priv.63+0x1cc>)
 8002d84:	f7ff f874 	bl	8001e70 <chprintf.lto_priv.86>
 8002d88:	e033      	b.n	8002df2 <shell_thread.lto_priv.63+0xb2>
      return true;
    }
    if ((c == 8) || (c == 127)) {
 8002d8a:	2908      	cmp	r1, #8
 8002d8c:	d001      	beq.n	8002d92 <shell_thread.lto_priv.63+0x52>
 8002d8e:	297f      	cmp	r1, #127	; 0x7f
 8002d90:	d112      	bne.n	8002db8 <shell_thread.lto_priv.63+0x78>
      if (p != line) {
 8002d92:	4546      	cmp	r6, r8
 8002d94:	d0e7      	beq.n	8002d66 <shell_thread.lto_priv.63+0x26>
        chSequentialStreamPut(chp, c);
 8002d96:	6823      	ldr	r3, [r4, #0]
 8002d98:	4620      	mov	r0, r4
 8002d9a:	689b      	ldr	r3, [r3, #8]
 8002d9c:	4798      	blx	r3
        chSequentialStreamPut(chp, 0x20);
 8002d9e:	6823      	ldr	r3, [r4, #0]
 8002da0:	2120      	movs	r1, #32
 8002da2:	689b      	ldr	r3, [r3, #8]
 8002da4:	4620      	mov	r0, r4
 8002da6:	4798      	blx	r3
        chSequentialStreamPut(chp, c);
 8002da8:	6823      	ldr	r3, [r4, #0]
 8002daa:	f89d 1007 	ldrb.w	r1, [sp, #7]
 8002dae:	689b      	ldr	r3, [r3, #8]
 8002db0:	4620      	mov	r0, r4
 8002db2:	4798      	blx	r3
        p--;
 8002db4:	3e01      	subs	r6, #1
 8002db6:	e7d6      	b.n	8002d66 <shell_thread.lto_priv.63+0x26>
      }
      continue;
    }
    if (c == '\r') {
 8002db8:	290d      	cmp	r1, #13
 8002dba:	d10b      	bne.n	8002dd4 <shell_thread.lto_priv.63+0x94>
      chprintf(chp, "\r\n");
 8002dbc:	4954      	ldr	r1, [pc, #336]	; (8002f10 <shell_thread.lto_priv.63+0x1d0>)
 8002dbe:	4620      	mov	r0, r4
      *p = 0;
 8002dc0:	2500      	movs	r5, #0
        p--;
      }
      continue;
    }
    if (c == '\r') {
      chprintf(chp, "\r\n");
 8002dc2:	f7ff f855 	bl	8001e70 <chprintf.lto_priv.86>
    chprintf(chp, "owl> ");
    if (shellGetLine(chp, line, sizeof(line))) {
      chprintf(chp, "\r\nlogout");
      break;
    }
    lp = _strtok(line, " \t", &tokp);
 8002dc6:	4640      	mov	r0, r8
      }
      continue;
    }
    if (c == '\r') {
      chprintf(chp, "\r\n");
      *p = 0;
 8002dc8:	7035      	strb	r5, [r6, #0]
    chprintf(chp, "owl> ");
    if (shellGetLine(chp, line, sizeof(line))) {
      chprintf(chp, "\r\nlogout");
      break;
    }
    lp = _strtok(line, " \t", &tokp);
 8002dca:	a902      	add	r1, sp, #8
 8002dcc:	f000 fd78 	bl	80038c0 <_strtok.constprop.3>
 8002dd0:	4680      	mov	r8, r0
 8002dd2:	e017      	b.n	8002e04 <shell_thread.lto_priv.63+0xc4>
    if (c == '\r') {
      chprintf(chp, "\r\n");
      *p = 0;
      return false;
    }
    if (c < 0x20)
 8002dd4:	291f      	cmp	r1, #31
 8002dd6:	d9c6      	bls.n	8002d66 <shell_thread.lto_priv.63+0x26>
      continue;
    if (p < line + size - 1) {
 8002dd8:	f10d 035f 	add.w	r3, sp, #95	; 0x5f
 8002ddc:	429e      	cmp	r6, r3
 8002dde:	d2c2      	bcs.n	8002d66 <shell_thread.lto_priv.63+0x26>
      chSequentialStreamPut(chp, c);
 8002de0:	6823      	ldr	r3, [r4, #0]
 8002de2:	4620      	mov	r0, r4
 8002de4:	689b      	ldr	r3, [r3, #8]
 8002de6:	4798      	blx	r3
      *p++ = (char)c;
 8002de8:	f89d 3007 	ldrb.w	r3, [sp, #7]
 8002dec:	7033      	strb	r3, [r6, #0]
 8002dee:	3601      	adds	r6, #1
 8002df0:	e7b9      	b.n	8002d66 <shell_thread.lto_priv.63+0x26>
  chRegSetThreadName("shell");
  chprintf(chp, "\r\nChibiOS/RT Shell\r\n");
  while (true) {
    chprintf(chp, "owl> ");
    if (shellGetLine(chp, line, sizeof(line))) {
      chprintf(chp, "\r\nlogout");
 8002df2:	4620      	mov	r0, r4
 8002df4:	4947      	ldr	r1, [pc, #284]	; (8002f14 <shell_thread.lto_priv.63+0x1d4>)
 8002df6:	f7ff f83b 	bl	8001e70 <chprintf.lto_priv.86>
 8002dfa:	e05e      	b.n	8002eba <shell_thread.lto_priv.63+0x17a>
      if (n >= SHELL_MAX_ARGUMENTS) {
        chprintf(chp, "too many arguments\r\n");
        cmd = NULL;
        break;
      }
      args[n++] = lp;
 8002dfc:	ab03      	add	r3, sp, #12
 8002dfe:	f843 0025 	str.w	r0, [r3, r5, lsl #2]
 8002e02:	3501      	adds	r5, #1
      break;
    }
    lp = _strtok(line, " \t", &tokp);
    cmd = lp;
    n = 0;
    while ((lp = _strtok(NULL, " \t", &tokp)) != NULL) {
 8002e04:	2000      	movs	r0, #0
 8002e06:	a902      	add	r1, sp, #8
 8002e08:	f000 fd5a 	bl	80038c0 <_strtok.constprop.3>
 8002e0c:	b138      	cbz	r0, 8002e1e <shell_thread.lto_priv.63+0xde>
      if (n >= SHELL_MAX_ARGUMENTS) {
 8002e0e:	2d04      	cmp	r5, #4
 8002e10:	d1f4      	bne.n	8002dfc <shell_thread.lto_priv.63+0xbc>
        chprintf(chp, "too many arguments\r\n");
 8002e12:	4620      	mov	r0, r4
 8002e14:	4940      	ldr	r1, [pc, #256]	; (8002f18 <shell_thread.lto_priv.63+0x1d8>)
 8002e16:	f7ff f82b 	bl	8001e70 <chprintf.lto_priv.86>
        cmd = NULL;
 8002e1a:	f04f 0800 	mov.w	r8, #0
        break;
      }
      args[n++] = lp;
    }
    args[n] = NULL;
 8002e1e:	ab18      	add	r3, sp, #96	; 0x60
 8002e20:	eb03 0385 	add.w	r3, r3, r5, lsl #2
 8002e24:	2200      	movs	r2, #0
 8002e26:	f843 2c54 	str.w	r2, [r3, #-84]
    if (cmd != NULL) {
 8002e2a:	f1b8 0f00 	cmp.w	r8, #0
 8002e2e:	d094      	beq.n	8002d5a <shell_thread.lto_priv.63+0x1a>
      if (strcasecmp(cmd, "exit") == 0) {
 8002e30:	4640      	mov	r0, r8
 8002e32:	493a      	ldr	r1, [pc, #232]	; (8002f1c <shell_thread.lto_priv.63+0x1dc>)
 8002e34:	f000 fe54 	bl	8003ae0 <strcasecmp>
 8002e38:	b928      	cbnz	r0, 8002e46 <shell_thread.lto_priv.63+0x106>
        if (n > 0) {
 8002e3a:	2d00      	cmp	r5, #0
 8002e3c:	d03d      	beq.n	8002eba <shell_thread.lto_priv.63+0x17a>
  return *token ? token : NULL;
}

static void usage(BaseSequentialStream *chp, char *p) {

  chprintf(chp, "Usage: %s\r\n", p);
 8002e3e:	4620      	mov	r0, r4
 8002e40:	4937      	ldr	r1, [pc, #220]	; (8002f20 <shell_thread.lto_priv.63+0x1e0>)
 8002e42:	4a36      	ldr	r2, [pc, #216]	; (8002f1c <shell_thread.lto_priv.63+0x1dc>)
 8002e44:	e008      	b.n	8002e58 <shell_thread.lto_priv.63+0x118>
          usage(chp, "exit");
          continue;
        }
        break;
      }
      else if (strcasecmp(cmd, "help") == 0) {
 8002e46:	4640      	mov	r0, r8
 8002e48:	4936      	ldr	r1, [pc, #216]	; (8002f24 <shell_thread.lto_priv.63+0x1e4>)
 8002e4a:	f000 fe49 	bl	8003ae0 <strcasecmp>
 8002e4e:	bb28      	cbnz	r0, 8002e9c <shell_thread.lto_priv.63+0x15c>
  return *token ? token : NULL;
}

static void usage(BaseSequentialStream *chp, char *p) {

  chprintf(chp, "Usage: %s\r\n", p);
 8002e50:	4620      	mov	r0, r4
          continue;
        }
        break;
      }
      else if (strcasecmp(cmd, "help") == 0) {
        if (n > 0) {
 8002e52:	b125      	cbz	r5, 8002e5e <shell_thread.lto_priv.63+0x11e>
  return *token ? token : NULL;
}

static void usage(BaseSequentialStream *chp, char *p) {

  chprintf(chp, "Usage: %s\r\n", p);
 8002e54:	4932      	ldr	r1, [pc, #200]	; (8002f20 <shell_thread.lto_priv.63+0x1e0>)
 8002e56:	4a33      	ldr	r2, [pc, #204]	; (8002f24 <shell_thread.lto_priv.63+0x1e4>)
 8002e58:	f7ff f80a 	bl	8001e70 <chprintf.lto_priv.86>
 8002e5c:	e77d      	b.n	8002d5a <shell_thread.lto_priv.63+0x1a>
      else if (strcasecmp(cmd, "help") == 0) {
        if (n > 0) {
          usage(chp, "help");
          continue;
        }
        chprintf(chp, "Commands: help exit ");
 8002e5e:	4932      	ldr	r1, [pc, #200]	; (8002f28 <shell_thread.lto_priv.63+0x1e8>)
 8002e60:	f7ff f806 	bl	8001e70 <chprintf.lto_priv.86>
 8002e64:	4b31      	ldr	r3, [pc, #196]	; (8002f2c <shell_thread.lto_priv.63+0x1ec>)
 8002e66:	3501      	adds	r5, #1
 8002e68:	eb03 03c5 	add.w	r3, r3, r5, lsl #3
  chprintf(chp, "Usage: %s\r\n", p);
}

static void list_commands(BaseSequentialStream *chp, const ShellCommand *scp) {

  while (scp->sc_name != NULL) {
 8002e6c:	f853 2c08 	ldr.w	r2, [r3, #-8]
 8002e70:	b122      	cbz	r2, 8002e7c <shell_thread.lto_priv.63+0x13c>
    chprintf(chp, "%s ", scp->sc_name);
 8002e72:	4620      	mov	r0, r4
 8002e74:	492e      	ldr	r1, [pc, #184]	; (8002f30 <shell_thread.lto_priv.63+0x1f0>)
 8002e76:	f7fe fffb 	bl	8001e70 <chprintf.lto_priv.86>
 8002e7a:	e7f3      	b.n	8002e64 <shell_thread.lto_priv.63+0x124>
          usage(chp, "help");
          continue;
        }
        chprintf(chp, "Commands: help exit ");
        list_commands(chp, local_commands);
        if (scp != NULL)
 8002e7c:	b917      	cbnz	r7, 8002e84 <shell_thread.lto_priv.63+0x144>
          list_commands(chp, scp);
        chprintf(chp, "\r\n");
 8002e7e:	4620      	mov	r0, r4
 8002e80:	4923      	ldr	r1, [pc, #140]	; (8002f10 <shell_thread.lto_priv.63+0x1d0>)
 8002e82:	e768      	b.n	8002d56 <shell_thread.lto_priv.63+0x16>
 8002e84:	f107 0508 	add.w	r5, r7, #8
 8002e88:	3508      	adds	r5, #8
  chprintf(chp, "Usage: %s\r\n", p);
}

static void list_commands(BaseSequentialStream *chp, const ShellCommand *scp) {

  while (scp->sc_name != NULL) {
 8002e8a:	f855 2c10 	ldr.w	r2, [r5, #-16]
 8002e8e:	2a00      	cmp	r2, #0
 8002e90:	d0f5      	beq.n	8002e7e <shell_thread.lto_priv.63+0x13e>
    chprintf(chp, "%s ", scp->sc_name);
 8002e92:	4620      	mov	r0, r4
 8002e94:	4926      	ldr	r1, [pc, #152]	; (8002f30 <shell_thread.lto_priv.63+0x1f0>)
 8002e96:	f7fe ffeb 	bl	8001e70 <chprintf.lto_priv.86>
 8002e9a:	e7f5      	b.n	8002e88 <shell_thread.lto_priv.63+0x148>
          usage(chp, "exit");
          continue;
        }
        break;
      }
      else if (strcasecmp(cmd, "help") == 0) {
 8002e9c:	4e23      	ldr	r6, [pc, #140]	; (8002f2c <shell_thread.lto_priv.63+0x1ec>)
};

static bool cmdexec(const ShellCommand *scp, BaseSequentialStream *chp,
                      char *name, int argc, char *argv[]) {

  while (scp->sc_name != NULL) {
 8002e9e:	6830      	ldr	r0, [r6, #0]
 8002ea0:	b1c0      	cbz	r0, 8002ed4 <shell_thread.lto_priv.63+0x194>
    if (strcasecmp(scp->sc_name, name) == 0) {
 8002ea2:	4641      	mov	r1, r8
 8002ea4:	f000 fe1c 	bl	8003ae0 <strcasecmp>
 8002ea8:	b108      	cbz	r0, 8002eae <shell_thread.lto_priv.63+0x16e>
      scp->sc_function(chp, argc, argv);
      return false;
    }
    scp++;
 8002eaa:	3608      	adds	r6, #8
 8002eac:	e7f7      	b.n	8002e9e <shell_thread.lto_priv.63+0x15e>
static bool cmdexec(const ShellCommand *scp, BaseSequentialStream *chp,
                      char *name, int argc, char *argv[]) {

  while (scp->sc_name != NULL) {
    if (strcasecmp(scp->sc_name, name) == 0) {
      scp->sc_function(chp, argc, argv);
 8002eae:	6873      	ldr	r3, [r6, #4]
 8002eb0:	4620      	mov	r0, r4
 8002eb2:	4629      	mov	r1, r5
 8002eb4:	aa03      	add	r2, sp, #12
 8002eb6:	4798      	blx	r3
 8002eb8:	e74f      	b.n	8002d5a <shell_thread.lto_priv.63+0x1a>
 8002eba:	2320      	movs	r3, #32
 8002ebc:	f383 8811 	msr	BASEPRI, r3
 *
 * @iclass
 */
static inline void chEvtBroadcastI(event_source_t *esp) {

  chEvtBroadcastFlagsI(esp, (eventflags_t)0);
 8002ec0:	2100      	movs	r1, #0
 8002ec2:	481c      	ldr	r0, [pc, #112]	; (8002f34 <shell_thread.lto_priv.63+0x1f4>)
 8002ec4:	f7fe f82c 	bl	8000f20 <chEvtBroadcastFlagsI>

  /* Atomically broadcasting the event source and terminating the thread,
     there is not a chSysUnlock() because the thread terminates upon return.*/
  chSysLock();
  chEvtBroadcastI(&shell_terminated);
  chThdExitS(msg);
 8002ec8:	2000      	movs	r0, #0
 8002eca:	f7fe fa41 	bl	8001350 <chThdExitS>
        chprintf(chp, " ?\r\n");
      }
    }
  }
  shellExit(MSG_OK);
}
 8002ece:	b018      	add	sp, #96	; 0x60
 8002ed0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
        list_commands(chp, local_commands);
        if (scp != NULL)
          list_commands(chp, scp);
        chprintf(chp, "\r\n");
      }
      else if (cmdexec(local_commands, chp, cmd, n, args) &&
 8002ed4:	b93f      	cbnz	r7, 8002ee6 <shell_thread.lto_priv.63+0x1a6>
          ((scp == NULL) || cmdexec(scp, chp, cmd, n, args))) {
        chprintf(chp, "%s", cmd);
 8002ed6:	4918      	ldr	r1, [pc, #96]	; (8002f38 <shell_thread.lto_priv.63+0x1f8>)
 8002ed8:	4620      	mov	r0, r4
 8002eda:	4642      	mov	r2, r8
 8002edc:	f7fe ffc8 	bl	8001e70 <chprintf.lto_priv.86>
        chprintf(chp, " ?\r\n");
 8002ee0:	4620      	mov	r0, r4
 8002ee2:	4916      	ldr	r1, [pc, #88]	; (8002f3c <shell_thread.lto_priv.63+0x1fc>)
 8002ee4:	e737      	b.n	8002d56 <shell_thread.lto_priv.63+0x16>
        list_commands(chp, local_commands);
        if (scp != NULL)
          list_commands(chp, scp);
        chprintf(chp, "\r\n");
      }
      else if (cmdexec(local_commands, chp, cmd, n, args) &&
 8002ee6:	463e      	mov	r6, r7
};

static bool cmdexec(const ShellCommand *scp, BaseSequentialStream *chp,
                      char *name, int argc, char *argv[]) {

  while (scp->sc_name != NULL) {
 8002ee8:	6830      	ldr	r0, [r6, #0]
 8002eea:	2800      	cmp	r0, #0
 8002eec:	d0f3      	beq.n	8002ed6 <shell_thread.lto_priv.63+0x196>
    if (strcasecmp(scp->sc_name, name) == 0) {
 8002eee:	4641      	mov	r1, r8
 8002ef0:	f000 fdf6 	bl	8003ae0 <strcasecmp>
 8002ef4:	2800      	cmp	r0, #0
 8002ef6:	d0da      	beq.n	8002eae <shell_thread.lto_priv.63+0x16e>
      scp->sc_function(chp, argc, argv);
      return false;
    }
    scp++;
 8002ef8:	3608      	adds	r6, #8
 8002efa:	e7f5      	b.n	8002ee8 <shell_thread.lto_priv.63+0x1a8>
 8002efc:	20001a00 	.word	0x20001a00
 8002f00:	080042f9 	.word	0x080042f9
 8002f04:	080042ff 	.word	0x080042ff
 8002f08:	08004314 	.word	0x08004314
 8002f0c:	0800431a 	.word	0x0800431a
 8002f10:	08003f2b 	.word	0x08003f2b
 8002f14:	0800431d 	.word	0x0800431d
 8002f18:	08004326 	.word	0x08004326
 8002f1c:	0800433b 	.word	0x0800433b
 8002f20:	080041b2 	.word	0x080041b2
 8002f24:	08004340 	.word	0x08004340
 8002f28:	08004345 	.word	0x08004345
 8002f2c:	20000804 	.word	0x20000804
 8002f30:	0800435a 	.word	0x0800435a
 8002f34:	20001254 	.word	0x20001254
 8002f38:	0800435e 	.word	0x0800435e
 8002f3c:	08004361 	.word	0x08004361

08002f40 <chprintf.lto_priv.79>:
 * @param[in] chp       pointer to a @p BaseSequentialStream implementing object
 * @param[in] fmt       formatting string
 *
 * @api
 */
static inline int chprintf(BaseSequentialStream *chp, const char *fmt, ...) {
 8002f40:	b40e      	push	{r1, r2, r3}
 8002f42:	b503      	push	{r0, r1, lr}
 8002f44:	aa03      	add	r2, sp, #12
 8002f46:	f852 1b04 	ldr.w	r1, [r2], #4
  va_list ap;
  int formatted_bytes;

  va_start(ap, fmt);
 8002f4a:	9201      	str	r2, [sp, #4]
  formatted_bytes = chvprintf(chp, fmt, ap);
 8002f4c:	f7fe fe90 	bl	8001c70 <chvprintf>
  va_end(ap);

  return formatted_bytes;
}
 8002f50:	b002      	add	sp, #8
 8002f52:	f85d eb04 	ldr.w	lr, [sp], #4
 8002f56:	b003      	add	sp, #12
 8002f58:	4770      	bx	lr
 8002f5a:	0000      	movs	r0, r0
 8002f5c:	0000      	movs	r0, r0
	...

08002f60 <cmd_reboot.lto_priv.78>:
}

static void cmd_reboot(BaseSequentialStream *chp, int argc, char *argv[]) {
	(void)argv;

	if (argc > 0)
 8002f60:	2900      	cmp	r1, #0
			}
		}
	}
}

static void cmd_reboot(BaseSequentialStream *chp, int argc, char *argv[]) {
 8002f62:	b508      	push	{r3, lr}
	(void)argv;

	if (argc > 0)
 8002f64:	dd04      	ble.n	8002f70 <cmd_reboot.lto_priv.78+0x10>
	{
		chprintf(chp, "Usage: reboot\r\n");
 8002f66:	490a      	ldr	r1, [pc, #40]	; (8002f90 <cmd_reboot.lto_priv.78+0x30>)
	else
	{
		chprintf(chp, "Rebooting...\r\n");
		NVIC_SystemReset();
	}
}
 8002f68:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
static void cmd_reboot(BaseSequentialStream *chp, int argc, char *argv[]) {
	(void)argv;

	if (argc > 0)
	{
		chprintf(chp, "Usage: reboot\r\n");
 8002f6c:	f7ff bfe8 	b.w	8002f40 <chprintf.lto_priv.79>
		return;
	}
	else
	{
		chprintf(chp, "Rebooting...\r\n");
 8002f70:	4908      	ldr	r1, [pc, #32]	; (8002f94 <cmd_reboot.lto_priv.78+0x34>)
 8002f72:	f7ff ffe5 	bl	8002f40 <chprintf.lto_priv.79>
    This function acts as a special kind of Data Memory Barrier.
    It completes when all explicit memory accesses before this instruction complete.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __DSB(void)
{
  __ASM volatile ("dsb");
 8002f76:	f3bf 8f4f 	dsb	sy
__STATIC_INLINE void NVIC_SystemReset(void)
{
  __DSB();                                                     /* Ensure all outstanding memory accesses included
                                                                  buffered write are completed before reset */
  SCB->AIRCR  = ((0x5FA << SCB_AIRCR_VECTKEY_Pos)      |
                 (SCB->AIRCR & SCB_AIRCR_PRIGROUP_Msk) |
 8002f7a:	4907      	ldr	r1, [pc, #28]	; (8002f98 <cmd_reboot.lto_priv.78+0x38>)
 8002f7c:	4b07      	ldr	r3, [pc, #28]	; (8002f9c <cmd_reboot.lto_priv.78+0x3c>)
 8002f7e:	68ca      	ldr	r2, [r1, #12]
 8002f80:	f402 62e0 	and.w	r2, r2, #1792	; 0x700
 8002f84:	4313      	orrs	r3, r2
 */
__STATIC_INLINE void NVIC_SystemReset(void)
{
  __DSB();                                                     /* Ensure all outstanding memory accesses included
                                                                  buffered write are completed before reset */
  SCB->AIRCR  = ((0x5FA << SCB_AIRCR_VECTKEY_Pos)      |
 8002f86:	60cb      	str	r3, [r1, #12]
 8002f88:	f3bf 8f4f 	dsb	sy
 8002f8c:	e7fe      	b.n	8002f8c <cmd_reboot.lto_priv.78+0x2c>
 8002f8e:	bf00      	nop
 8002f90:	08004366 	.word	0x08004366
 8002f94:	08004376 	.word	0x08004376
 8002f98:	e000ed00 	.word	0xe000ed00
 8002f9c:	05fa0004 	.word	0x05fa0004

08002fa0 <cmd_gas.lto_priv.77>:


static void cmd_gas(BaseSequentialStream *chp, int argc, char *argv[]) {
	(void)argv;

	if (argc != 2)
 8002fa0:	2902      	cmp	r1, #2
 8002fa2:	d001      	beq.n	8002fa8 <cmd_gas.lto_priv.77+0x8>
	{
		chprintf(chp, "Usage: gas <sensor_nb> [1|0|r]\r\n");
 8002fa4:	491e      	ldr	r1, [pc, #120]	; (8003020 <cmd_gas.lto_priv.77+0x80>)
 8002fa6:	e038      	b.n	800301a <cmd_gas.lto_priv.77+0x7a>
		return;
	}
	else
	{
		if (*argv[0]=='1')
 8002fa8:	6813      	ldr	r3, [r2, #0]
 8002faa:	781b      	ldrb	r3, [r3, #0]
 8002fac:	2b31      	cmp	r3, #49	; 0x31
 8002fae:	d117      	bne.n	8002fe0 <cmd_gas.lto_priv.77+0x40>
		{
			if (*argv[1]=='1')
 8002fb0:	6853      	ldr	r3, [r2, #4]
 8002fb2:	781b      	ldrb	r3, [r3, #0]
 8002fb4:	2b31      	cmp	r3, #49	; 0x31
 8002fb6:	d108      	bne.n	8002fca <cmd_gas.lto_priv.77+0x2a>
			{
				palSetPad(GPIOC, GPIOC_GS1_HON);
 8002fb8:	4b1a      	ldr	r3, [pc, #104]	; (8003024 <cmd_gas.lto_priv.77+0x84>)
				palSetPad(GPIOC, GPIOC_GS1_SON);
				chprintf(chp, "Power ON GS1\r\n");
 8002fba:	491b      	ldr	r1, [pc, #108]	; (8003028 <cmd_gas.lto_priv.77+0x88>)
	{
		if (*argv[0]=='1')
		{
			if (*argv[1]=='1')
			{
				palSetPad(GPIOC, GPIOC_GS1_HON);
 8002fbc:	f44f 4200 	mov.w	r2, #32768	; 0x8000
 8002fc0:	831a      	strh	r2, [r3, #24]
				palSetPad(GPIOC, GPIOC_GS1_SON);
 8002fc2:	f44f 4280 	mov.w	r2, #16384	; 0x4000
 8002fc6:	831a      	strh	r2, [r3, #24]
 8002fc8:	e027      	b.n	800301a <cmd_gas.lto_priv.77+0x7a>
				chprintf(chp, "Power ON GS1\r\n");
			}
			else if (*argv[1]=='0')
 8002fca:	2b30      	cmp	r3, #48	; 0x30
 8002fcc:	d127      	bne.n	800301e <cmd_gas.lto_priv.77+0x7e>
			{
				palClearPad(GPIOC, GPIOC_GS1_HON);
 8002fce:	4b15      	ldr	r3, [pc, #84]	; (8003024 <cmd_gas.lto_priv.77+0x84>)
				palClearPad(GPIOC, GPIOC_GS1_SON);
				chprintf(chp, "Power OFF GS1\r\n");
 8002fd0:	4916      	ldr	r1, [pc, #88]	; (800302c <cmd_gas.lto_priv.77+0x8c>)
				palSetPad(GPIOC, GPIOC_GS1_SON);
				chprintf(chp, "Power ON GS1\r\n");
			}
			else if (*argv[1]=='0')
			{
				palClearPad(GPIOC, GPIOC_GS1_HON);
 8002fd2:	f44f 4200 	mov.w	r2, #32768	; 0x8000
 8002fd6:	835a      	strh	r2, [r3, #26]
				palClearPad(GPIOC, GPIOC_GS1_SON);
 8002fd8:	f44f 4280 	mov.w	r2, #16384	; 0x4000
 8002fdc:	835a      	strh	r2, [r3, #26]
 8002fde:	e01c      	b.n	800301a <cmd_gas.lto_priv.77+0x7a>
				chprintf(chp, "Power OFF GS1\r\n");
			}
		}
		else if (*argv[0]=='2')
 8002fe0:	2b32      	cmp	r3, #50	; 0x32
 8002fe2:	d11c      	bne.n	800301e <cmd_gas.lto_priv.77+0x7e>
		{
			if (*argv[1]=='1')
 8002fe4:	6853      	ldr	r3, [r2, #4]
 8002fe6:	781b      	ldrb	r3, [r3, #0]
 8002fe8:	2b31      	cmp	r3, #49	; 0x31
 8002fea:	d10a      	bne.n	8003002 <cmd_gas.lto_priv.77+0x62>
			{
				palSetPad(GPIOB, GPIOB_GS2_HON);
 8002fec:	4b10      	ldr	r3, [pc, #64]	; (8003030 <cmd_gas.lto_priv.77+0x90>)
				palSetPad(GPIOC, GPIOC_GS2_SON);
				chprintf(chp, "Power ON GS2\r\n");
 8002fee:	4911      	ldr	r1, [pc, #68]	; (8003034 <cmd_gas.lto_priv.77+0x94>)
		}
		else if (*argv[0]=='2')
		{
			if (*argv[1]=='1')
			{
				palSetPad(GPIOB, GPIOB_GS2_HON);
 8002ff0:	f44f 7280 	mov.w	r2, #256	; 0x100
 8002ff4:	831a      	strh	r2, [r3, #24]
				palSetPad(GPIOC, GPIOC_GS2_SON);
 8002ff6:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8002ffa:	f44f 5200 	mov.w	r2, #8192	; 0x2000
 8002ffe:	831a      	strh	r2, [r3, #24]
 8003000:	e00b      	b.n	800301a <cmd_gas.lto_priv.77+0x7a>
				chprintf(chp, "Power ON GS2\r\n");
			}
			else if (*argv[1]=='0')
 8003002:	2b30      	cmp	r3, #48	; 0x30
 8003004:	d10b      	bne.n	800301e <cmd_gas.lto_priv.77+0x7e>
			{
				palClearPad(GPIOB, GPIOB_GS2_HON);
 8003006:	4b0a      	ldr	r3, [pc, #40]	; (8003030 <cmd_gas.lto_priv.77+0x90>)
				palClearPad(GPIOC, GPIOC_GS2_SON);
				chprintf(chp, "Power OFF GS2\r\n");
 8003008:	490b      	ldr	r1, [pc, #44]	; (8003038 <cmd_gas.lto_priv.77+0x98>)
				palSetPad(GPIOC, GPIOC_GS2_SON);
				chprintf(chp, "Power ON GS2\r\n");
			}
			else if (*argv[1]=='0')
			{
				palClearPad(GPIOB, GPIOB_GS2_HON);
 800300a:	f44f 7280 	mov.w	r2, #256	; 0x100
 800300e:	835a      	strh	r2, [r3, #26]
				palClearPad(GPIOC, GPIOC_GS2_SON);
 8003010:	f503 6380 	add.w	r3, r3, #1024	; 0x400
 8003014:	f44f 5200 	mov.w	r2, #8192	; 0x2000
 8003018:	835a      	strh	r2, [r3, #26]
				chprintf(chp, "Power OFF GS2\r\n");
 800301a:	f7ff bf91 	b.w	8002f40 <chprintf.lto_priv.79>
 800301e:	4770      	bx	lr
 8003020:	08004385 	.word	0x08004385
 8003024:	48000800 	.word	0x48000800
 8003028:	080043a6 	.word	0x080043a6
 800302c:	080043b5 	.word	0x080043b5
 8003030:	48000400 	.word	0x48000400
 8003034:	080043c5 	.word	0x080043c5
 8003038:	080043d4 	.word	0x080043d4
 800303c:	00000000 	.word	0x00000000

08003040 <cmd_nadpkey.lto_priv.76>:
		pwmEnableChannel(&PWMD3, 0, (pwmcnt_t)((rgb_value)&0xFF));
	}
}


static void cmd_nadpkey(BaseSequentialStream *chp, int argc, char *argv[]) {
 8003040:	b538      	push	{r3, r4, r5, lr}
	(void)argv;

	if (argc != 0)
 8003042:	b121      	cbz	r1, 800304e <cmd_nadpkey.lto_priv.76+0xe>
	{
		chprintf(chp, "Usage: nadpkey\r\n");
 8003044:	4907      	ldr	r1, [pc, #28]	; (8003064 <cmd_nadpkey.lto_priv.76+0x24>)
	{
		palClearPad(GPIOA, GPIOA_NAD_PKEY);
		chThdSleepMilliseconds(1200);
		palSetPad(GPIOA, GPIOA_NAD_PKEY);
	}
}
 8003046:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
static void cmd_nadpkey(BaseSequentialStream *chp, int argc, char *argv[]) {
	(void)argv;

	if (argc != 0)
	{
		chprintf(chp, "Usage: nadpkey\r\n");
 800304a:	f7ff bf79 	b.w	8002f40 <chprintf.lto_priv.79>
		return;
	}
	else
	{
		palClearPad(GPIOA, GPIOA_NAD_PKEY);
 800304e:	f04f 4490 	mov.w	r4, #1207959552	; 0x48000000
 8003052:	f44f 7580 	mov.w	r5, #256	; 0x100
 8003056:	8365      	strh	r5, [r4, #26]
		chThdSleepMilliseconds(1200);
 8003058:	f642 60e0 	movw	r0, #12000	; 0x2ee0
 800305c:	f7fd ff40 	bl	8000ee0 <chThdSleep>
		palSetPad(GPIOA, GPIOA_NAD_PKEY);
 8003060:	8325      	strh	r5, [r4, #24]
 8003062:	bd38      	pop	{r3, r4, r5, pc}
 8003064:	080043e4 	.word	0x080043e4
	...

08003070 <cmd_rgb.lto_priv.75>:

static void cmd_rgb(BaseSequentialStream *chp, int argc, char *argv[]) {
	(void)argv;
	uint32_t rgb_value;
	
	if (	argc != 1 || strlen(argv[0]) != 6 || \
 8003070:	2901      	cmp	r1, #1
		else
			log_active=0;
	}
}

static void cmd_rgb(BaseSequentialStream *chp, int argc, char *argv[]) {
 8003072:	b538      	push	{r3, r4, r5, lr}
 8003074:	4605      	mov	r5, r0
	(void)argv;
	uint32_t rgb_value;
	
	if (	argc != 1 || strlen(argv[0]) != 6 || \
 8003076:	d12b      	bne.n	80030d0 <cmd_rgb.lto_priv.75+0x60>
 8003078:	6814      	ldr	r4, [r2, #0]
 800307a:	4620      	mov	r0, r4
 800307c:	f000 fd58 	bl	8003b30 <strlen>
 8003080:	2806      	cmp	r0, #6
 8003082:	d125      	bne.n	80030d0 <cmd_rgb.lto_priv.75+0x60>
			!isxdigit((int)argv[0][0]) || !isxdigit((int)argv[0][1]) ||\
 8003084:	4b2c      	ldr	r3, [pc, #176]	; (8003138 <cmd_rgb.lto_priv.75+0xc8>)
 8003086:	7822      	ldrb	r2, [r4, #0]
 8003088:	681b      	ldr	r3, [r3, #0]
 800308a:	441a      	add	r2, r3
 800308c:	7852      	ldrb	r2, [r2, #1]

static void cmd_rgb(BaseSequentialStream *chp, int argc, char *argv[]) {
	(void)argv;
	uint32_t rgb_value;
	
	if (	argc != 1 || strlen(argv[0]) != 6 || \
 800308e:	f012 0f44 	tst.w	r2, #68	; 0x44
 8003092:	d01d      	beq.n	80030d0 <cmd_rgb.lto_priv.75+0x60>
			!isxdigit((int)argv[0][0]) || !isxdigit((int)argv[0][1]) ||\
 8003094:	7862      	ldrb	r2, [r4, #1]
 8003096:	441a      	add	r2, r3
 8003098:	7852      	ldrb	r2, [r2, #1]
 800309a:	f012 0f44 	tst.w	r2, #68	; 0x44
 800309e:	d017      	beq.n	80030d0 <cmd_rgb.lto_priv.75+0x60>
			!isxdigit((int)argv[0][2]) || !isxdigit((int)argv[0][3]) ||\
 80030a0:	78a2      	ldrb	r2, [r4, #2]
 80030a2:	441a      	add	r2, r3
 80030a4:	7852      	ldrb	r2, [r2, #1]
static void cmd_rgb(BaseSequentialStream *chp, int argc, char *argv[]) {
	(void)argv;
	uint32_t rgb_value;
	
	if (	argc != 1 || strlen(argv[0]) != 6 || \
			!isxdigit((int)argv[0][0]) || !isxdigit((int)argv[0][1]) ||\
 80030a6:	f012 0f44 	tst.w	r2, #68	; 0x44
 80030aa:	d011      	beq.n	80030d0 <cmd_rgb.lto_priv.75+0x60>
			!isxdigit((int)argv[0][2]) || !isxdigit((int)argv[0][3]) ||\
 80030ac:	78e2      	ldrb	r2, [r4, #3]
 80030ae:	441a      	add	r2, r3
 80030b0:	7852      	ldrb	r2, [r2, #1]
 80030b2:	f012 0f44 	tst.w	r2, #68	; 0x44
 80030b6:	d00b      	beq.n	80030d0 <cmd_rgb.lto_priv.75+0x60>
			!isxdigit((int)argv[0][4]) || !isxdigit((int)argv[0][5]) )
 80030b8:	7922      	ldrb	r2, [r4, #4]
 80030ba:	441a      	add	r2, r3
 80030bc:	7852      	ldrb	r2, [r2, #1]
	(void)argv;
	uint32_t rgb_value;
	
	if (	argc != 1 || strlen(argv[0]) != 6 || \
			!isxdigit((int)argv[0][0]) || !isxdigit((int)argv[0][1]) ||\
			!isxdigit((int)argv[0][2]) || !isxdigit((int)argv[0][3]) ||\
 80030be:	f012 0f44 	tst.w	r2, #68	; 0x44
 80030c2:	d005      	beq.n	80030d0 <cmd_rgb.lto_priv.75+0x60>
			!isxdigit((int)argv[0][4]) || !isxdigit((int)argv[0][5]) )
 80030c4:	7962      	ldrb	r2, [r4, #5]
 80030c6:	4413      	add	r3, r2
 80030c8:	785b      	ldrb	r3, [r3, #1]
 80030ca:	f013 0f44 	tst.w	r3, #68	; 0x44
 80030ce:	d105      	bne.n	80030dc <cmd_rgb.lto_priv.75+0x6c>
			
	{
		chprintf(chp, "Usage: rgb <24bits_hex_value>\r\n");
 80030d0:	4628      	mov	r0, r5
 80030d2:	491a      	ldr	r1, [pc, #104]	; (800313c <cmd_rgb.lto_priv.75+0xcc>)
		/* LED_GREEN: TIM3 CH3 PB0 */
		pwmEnableChannel(&PWMD3, 2, (pwmcnt_t)((rgb_value>>8)&0xFF));
		/* LED_BLUE : TIM3 CH1 PA6 */
		pwmEnableChannel(&PWMD3, 0, (pwmcnt_t)((rgb_value)&0xFF));
	}
}
 80030d4:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
			!isxdigit((int)argv[0][0]) || !isxdigit((int)argv[0][1]) ||\
			!isxdigit((int)argv[0][2]) || !isxdigit((int)argv[0][3]) ||\
			!isxdigit((int)argv[0][4]) || !isxdigit((int)argv[0][5]) )
			
	{
		chprintf(chp, "Usage: rgb <24bits_hex_value>\r\n");
 80030d8:	f7ff bf32 	b.w	8002f40 <chprintf.lto_priv.79>
		return;
	}
	else
	{
		rgb_co2ppm=0;
 80030dc:	2500      	movs	r5, #0
 80030de:	4b18      	ldr	r3, [pc, #96]	; (8003140 <cmd_rgb.lto_priv.75+0xd0>)
		rgb_value = strtol(argv[0], NULL, 16);
 80030e0:	4620      	mov	r0, r4
 80030e2:	4629      	mov	r1, r5
 80030e4:	2210      	movs	r2, #16
		chprintf(chp, "Usage: rgb <24bits_hex_value>\r\n");
		return;
	}
	else
	{
		rgb_co2ppm=0;
 80030e6:	701d      	strb	r5, [r3, #0]
		rgb_value = strtol(argv[0], NULL, 16);
 80030e8:	f000 fc9a 	bl	8003a20 <strtol>
 80030ec:	2220      	movs	r2, #32
		/* LED_RED : TIM3 CH2 PA7 */
		pwmEnableChannel(&PWMD3, 1, (pwmcnt_t)((rgb_value>>16)&0xFF));
 80030ee:	f3c0 4407 	ubfx	r4, r0, #16, #8
 80030f2:	f382 8811 	msr	BASEPRI, r2

  osalSysLock();

  osalDbgAssert(pwmp->state == PWM_READY, "not ready");

  pwmEnableChannelI(pwmp, channel, width);
 80030f6:	4b13      	ldr	r3, [pc, #76]	; (8003144 <cmd_rgb.lto_priv.75+0xd4>)
 80030f8:	68d9      	ldr	r1, [r3, #12]
 80030fa:	f041 0102 	orr.w	r1, r1, #2
 80030fe:	60d9      	str	r1, [r3, #12]
  /* Changing channel duty cycle on the fly.*/
#if STM32_TIM_MAX_CHANNELS <= 4
  pwmp->tim->CCR[channel] = width;
#else
  if (channel <= 4)
    pwmp->tim->CCR[channel] = width;
 8003100:	6999      	ldr	r1, [r3, #24]
 8003102:	638c      	str	r4, [r1, #56]	; 0x38
 8003104:	f385 8811 	msr	BASEPRI, r5
		/* LED_GREEN: TIM3 CH3 PB0 */
		pwmEnableChannel(&PWMD3, 2, (pwmcnt_t)((rgb_value>>8)&0xFF));
 8003108:	f3c0 2407 	ubfx	r4, r0, #8, #8
 800310c:	f382 8811 	msr	BASEPRI, r2
 8003110:	68d9      	ldr	r1, [r3, #12]
 8003112:	f041 0104 	orr.w	r1, r1, #4
 8003116:	60d9      	str	r1, [r3, #12]
 8003118:	6999      	ldr	r1, [r3, #24]
 800311a:	63cc      	str	r4, [r1, #60]	; 0x3c
 800311c:	f385 8811 	msr	BASEPRI, r5
		/* LED_BLUE : TIM3 CH1 PA6 */
		pwmEnableChannel(&PWMD3, 0, (pwmcnt_t)((rgb_value)&0xFF));
 8003120:	b2c0      	uxtb	r0, r0
 8003122:	f382 8811 	msr	BASEPRI, r2
 8003126:	68da      	ldr	r2, [r3, #12]
 8003128:	f042 0201 	orr.w	r2, r2, #1
 800312c:	60da      	str	r2, [r3, #12]
 800312e:	699b      	ldr	r3, [r3, #24]
 8003130:	6358      	str	r0, [r3, #52]	; 0x34
 8003132:	f385 8811 	msr	BASEPRI, r5
 8003136:	bd38      	pop	{r3, r4, r5, pc}
 8003138:	2000081c 	.word	0x2000081c
 800313c:	080043f5 	.word	0x080043f5
 8003140:	20000800 	.word	0x20000800
 8003144:	200011f0 	.word	0x200011f0
	...

08003150 <cmd_log.lto_priv.74>:
	}
}

static void cmd_log(BaseSequentialStream *chp, int argc, char *argv[]) {
	(void)argv;
	if (argc != 1 || !((*argv[0]=='1') || (*argv[0]=='0')) )
 8003150:	2901      	cmp	r1, #1
 8003152:	d105      	bne.n	8003160 <cmd_log.lto_priv.74+0x10>
 8003154:	6813      	ldr	r3, [r2, #0]
 8003156:	781b      	ldrb	r3, [r3, #0]
 8003158:	f1a3 0230 	sub.w	r2, r3, #48	; 0x30
 800315c:	2a01      	cmp	r2, #1
 800315e:	d902      	bls.n	8003166 <cmd_log.lto_priv.74+0x16>
	{
		chprintf(chp, "Usage: log [1|0]\r\n");
 8003160:	4904      	ldr	r1, [pc, #16]	; (8003174 <cmd_log.lto_priv.74+0x24>)
 8003162:	f7ff beed 	b.w	8002f40 <chprintf.lto_priv.79>
		return;
	}
	else
	{
		if (*argv[0]=='1')
 8003166:	2b31      	cmp	r3, #49	; 0x31
 8003168:	4b03      	ldr	r3, [pc, #12]	; (8003178 <cmd_log.lto_priv.74+0x28>)
			log_active=1;
		else
			log_active=0;
 800316a:	bf16      	itet	ne
 800316c:	2200      	movne	r2, #0
		return;
	}
	else
	{
		if (*argv[0]=='1')
			log_active=1;
 800316e:	7019      	strbeq	r1, [r3, #0]
		else
			log_active=0;
 8003170:	701a      	strbne	r2, [r3, #0]
 8003172:	4770      	bx	lr
 8003174:	08004415 	.word	0x08004415
 8003178:	20000f84 	.word	0x20000f84
 800317c:	00000000 	.word	0x00000000

08003180 <cmd_i2c.lto_priv.73>:
					*(__IO uint32_t*)(0x1FF80064),\
					*(__IO uint32_t*)(0x1FF80054),\
					*(__IO uint32_t*)(0x1FF80050));
}

static void cmd_i2c(BaseSequentialStream *chp, int argc, char *argv[]) {
 8003180:	b5f0      	push	{r4, r5, r6, r7, lr}
	systime_t tmo = MS2ST(4);
	uint8_t i2c_rx_data[16];
	uint8_t i2c_tx_data[2];

	(void)argv;
	if (argc != 4 || !((*argv[0]=='r') || (*argv[0]=='w')) )
 8003182:	2904      	cmp	r1, #4
					*(__IO uint32_t*)(0x1FF80064),\
					*(__IO uint32_t*)(0x1FF80054),\
					*(__IO uint32_t*)(0x1FF80050));
}

static void cmd_i2c(BaseSequentialStream *chp, int argc, char *argv[]) {
 8003184:	b089      	sub	sp, #36	; 0x24
 8003186:	4605      	mov	r5, r0
 8003188:	4614      	mov	r4, r2
	systime_t tmo = MS2ST(4);
	uint8_t i2c_rx_data[16];
	uint8_t i2c_tx_data[2];

	(void)argv;
	if (argc != 4 || !((*argv[0]=='r') || (*argv[0]=='w')) )
 800318a:	d105      	bne.n	8003198 <cmd_i2c.lto_priv.73+0x18>
 800318c:	6813      	ldr	r3, [r2, #0]
 800318e:	781b      	ldrb	r3, [r3, #0]
 8003190:	2b72      	cmp	r3, #114	; 0x72
 8003192:	d006      	beq.n	80031a2 <cmd_i2c.lto_priv.73+0x22>
 8003194:	2b77      	cmp	r3, #119	; 0x77
 8003196:	d004      	beq.n	80031a2 <cmd_i2c.lto_priv.73+0x22>
	{
		chprintf(chp, "Usage: i2c [w|r] [device_addr] [reg_addr] [data|nb bytes to read]\r\n");
 8003198:	4628      	mov	r0, r5
 800319a:	493d      	ldr	r1, [pc, #244]	; (8003290 <cmd_i2c.lto_priv.73+0x110>)
 800319c:	f7ff fed0 	bl	8002f40 <chprintf.lto_priv.79>
 80031a0:	e073      	b.n	800328a <cmd_i2c.lto_priv.73+0x10a>
		return;
	}
	else
	{
		i2c_device_address=(uint8_t)strtol(argv[1], NULL,16);	// device address
 80031a2:	6860      	ldr	r0, [r4, #4]
 80031a4:	4f3b      	ldr	r7, [pc, #236]	; (8003294 <cmd_i2c.lto_priv.73+0x114>)
 80031a6:	2100      	movs	r1, #0
 80031a8:	2210      	movs	r2, #16
 80031aa:	f000 fc39 	bl	8003a20 <strtol>
		i2c_device_address &= 0xFE;
		i2c_device_address >>= 1;
		i2c_tx_data[0]=(uint8_t)strtol(argv[2], NULL,16);		// register address
 80031ae:	2100      	movs	r1, #0
	}
	else
	{
		i2c_device_address=(uint8_t)strtol(argv[1], NULL,16);	// device address
		i2c_device_address &= 0xFE;
		i2c_device_address >>= 1;
 80031b0:	f3c0 0646 	ubfx	r6, r0, #1, #7
		i2c_tx_data[0]=(uint8_t)strtol(argv[2], NULL,16);		// register address
 80031b4:	2210      	movs	r2, #16
 80031b6:	68a0      	ldr	r0, [r4, #8]
 80031b8:	f000 fc32 	bl	8003a20 <strtol>
		i2c_tx_data[1]=(uint8_t)strtol(argv[3], NULL,16);		// data to write or nb byte to read
 80031bc:	2100      	movs	r1, #0
	else
	{
		i2c_device_address=(uint8_t)strtol(argv[1], NULL,16);	// device address
		i2c_device_address &= 0xFE;
		i2c_device_address >>= 1;
		i2c_tx_data[0]=(uint8_t)strtol(argv[2], NULL,16);		// register address
 80031be:	f88d 000c 	strb.w	r0, [sp, #12]
		i2c_tx_data[1]=(uint8_t)strtol(argv[3], NULL,16);		// data to write or nb byte to read
 80031c2:	2210      	movs	r2, #16
 80031c4:	68e0      	ldr	r0, [r4, #12]
 80031c6:	f000 fc2b 	bl	8003a20 <strtol>
		if(*argv[0]=='r')	// read command
 80031ca:	6823      	ldr	r3, [r4, #0]
	{
		i2c_device_address=(uint8_t)strtol(argv[1], NULL,16);	// device address
		i2c_device_address &= 0xFE;
		i2c_device_address >>= 1;
		i2c_tx_data[0]=(uint8_t)strtol(argv[2], NULL,16);		// register address
		i2c_tx_data[1]=(uint8_t)strtol(argv[3], NULL,16);		// data to write or nb byte to read
 80031cc:	f88d 000d 	strb.w	r0, [sp, #13]
		if(*argv[0]=='r')	// read command
 80031d0:	781b      	ldrb	r3, [r3, #0]
 * @api
 */
static inline void osalMutexLock(mutex_t *mp) {

#if CH_CFG_USE_MUTEXES
  chMtxLock(mp);
 80031d2:	4831      	ldr	r0, [pc, #196]	; (8003298 <cmd_i2c.lto_priv.73+0x118>)
 80031d4:	2b72      	cmp	r3, #114	; 0x72
 80031d6:	b2b4      	uxth	r4, r6
 80031d8:	d137      	bne.n	800324a <cmd_i2c.lto_priv.73+0xca>
 80031da:	f7fd ff01 	bl	8000fe0 <chMtxLock>
		{
			i2cAcquireBus(&I2CD1);
			status = i2cMasterTransmitTimeout(&I2CD1, i2c_device_address, i2c_tx_data, 1, i2c_rx_data, i2c_tx_data[1], tmo);
 80031de:	f89d 300d 	ldrb.w	r3, [sp, #13]
 80031e2:	9300      	str	r3, [sp, #0]
 80031e4:	4620      	mov	r0, r4
 80031e6:	a903      	add	r1, sp, #12
 80031e8:	2201      	movs	r2, #1
 80031ea:	ab04      	add	r3, sp, #16
 80031ec:	f000 fa90 	bl	8003710 <i2cMasterTransmitTimeout.constprop.17>
 80031f0:	4604      	mov	r4, r0
 80031f2:	6038      	str	r0, [r7, #0]
			if (status != MSG_OK)
 80031f4:	2800      	cmp	r0, #0
 80031f6:	d134      	bne.n	8003262 <cmd_i2c.lto_priv.73+0xe2>
				errors = i2cGetErrors(&I2CD1);
				chprintf(chp, "error : %02.2x\r\n", errors);
			}
			else
			{
				chprintf(chp, "%02.2xr%02.2x> ", i2c_device_address<<1, i2c_tx_data[0]);
 80031f8:	4628      	mov	r0, r5
 80031fa:	4928      	ldr	r1, [pc, #160]	; (800329c <cmd_i2c.lto_priv.73+0x11c>)
 80031fc:	f89d 300c 	ldrb.w	r3, [sp, #12]
 8003200:	0072      	lsls	r2, r6, #1
 8003202:	f7ff fe9d 	bl	8002f40 <chprintf.lto_priv.79>
				for (loop=0; loop<i2c_tx_data[1];)
 8003206:	f89d 300d 	ldrb.w	r3, [sp, #13]
 800320a:	42a3      	cmp	r3, r4
 800320c:	d915      	bls.n	800323a <cmd_i2c.lto_priv.73+0xba>
				{
					chprintf(chp, "%02.2x", i2c_rx_data[loop]);
 800320e:	ab08      	add	r3, sp, #32
 8003210:	4423      	add	r3, r4
 8003212:	4628      	mov	r0, r5
 8003214:	f813 2c10 	ldrb.w	r2, [r3, #-16]
 8003218:	4921      	ldr	r1, [pc, #132]	; (80032a0 <cmd_i2c.lto_priv.73+0x120>)
 800321a:	f7ff fe91 	bl	8002f40 <chprintf.lto_priv.79>
					if (++loop<i2c_tx_data[1])
 800321e:	3401      	adds	r4, #1
 8003220:	f89d 300d 	ldrb.w	r3, [sp, #13]
 8003224:	b2e4      	uxtb	r4, r4
 8003226:	42a3      	cmp	r3, r4
 8003228:	d9ed      	bls.n	8003206 <cmd_i2c.lto_priv.73+0x86>
					{
						if(loop % 2)
 800322a:	07e3      	lsls	r3, r4, #31
							chprintf(chp, ",");
 800322c:	4628      	mov	r0, r5
 800322e:	bf4c      	ite	mi
 8003230:	491c      	ldrmi	r1, [pc, #112]	; (80032a4 <cmd_i2c.lto_priv.73+0x124>)
						else
							chprintf(chp, ";");
 8003232:	491d      	ldrpl	r1, [pc, #116]	; (80032a8 <cmd_i2c.lto_priv.73+0x128>)
 8003234:	f7ff fe84 	bl	8002f40 <chprintf.lto_priv.79>
 8003238:	e7e5      	b.n	8003206 <cmd_i2c.lto_priv.73+0x86>
					}
				}
				chprintf(chp,"\r\n");
 800323a:	4628      	mov	r0, r5
 800323c:	491b      	ldr	r1, [pc, #108]	; (80032ac <cmd_i2c.lto_priv.73+0x12c>)
 800323e:	f7ff fe7f 	bl	8002f40 <chprintf.lto_priv.79>
 * @api
 */
static inline void osalMutexUnlock(mutex_t *mp) {

#if CH_CFG_USE_MUTEXES
  chMtxUnlock(mp);
 8003242:	4815      	ldr	r0, [pc, #84]	; (8003298 <cmd_i2c.lto_priv.73+0x118>)
 8003244:	f7fd fe94 	bl	8000f70 <chMtxUnlock>
 8003248:	e01f      	b.n	800328a <cmd_i2c.lto_priv.73+0x10a>
 * @api
 */
static inline void osalMutexLock(mutex_t *mp) {

#if CH_CFG_USE_MUTEXES
  chMtxLock(mp);
 800324a:	f7fd fec9 	bl	8000fe0 <chMtxLock>
			i2cReleaseBus(&I2CD1);
		}
		else	// write command
		{
			i2cAcquireBus(&I2CD1);
			status = i2cMasterTransmitTimeout(&I2CD1, i2c_device_address, i2c_tx_data, 2, i2c_rx_data, 0, tmo);
 800324e:	2300      	movs	r3, #0
 8003250:	9300      	str	r3, [sp, #0]
 8003252:	4620      	mov	r0, r4
 8003254:	a903      	add	r1, sp, #12
 8003256:	2202      	movs	r2, #2
 8003258:	ab04      	add	r3, sp, #16
 800325a:	f000 fa59 	bl	8003710 <i2cMasterTransmitTimeout.constprop.17>
 800325e:	6038      	str	r0, [r7, #0]
			if (status != MSG_OK)
 8003260:	b140      	cbz	r0, 8003274 <cmd_i2c.lto_priv.73+0xf4>
 */
i2cflags_t i2cGetErrors(I2CDriver *i2cp) {

  osalDbgCheck(i2cp != NULL);

  return i2c_lld_get_errors(i2cp);
 8003262:	4b13      	ldr	r3, [pc, #76]	; (80032b0 <cmd_i2c.lto_priv.73+0x130>)
			{
				errors = i2cGetErrors(&I2CD1);
				chprintf(chp, "error : %02.2x\r\n", errors);
 8003264:	4913      	ldr	r1, [pc, #76]	; (80032b4 <cmd_i2c.lto_priv.73+0x134>)
 8003266:	689a      	ldr	r2, [r3, #8]
		{
			i2cAcquireBus(&I2CD1);
			status = i2cMasterTransmitTimeout(&I2CD1, i2c_device_address, i2c_tx_data, 2, i2c_rx_data, 0, tmo);
			if (status != MSG_OK)
			{
				errors = i2cGetErrors(&I2CD1);
 8003268:	4b13      	ldr	r3, [pc, #76]	; (80032b8 <cmd_i2c.lto_priv.73+0x138>)
				chprintf(chp, "error : %02.2x\r\n", errors);
 800326a:	4628      	mov	r0, r5
		{
			i2cAcquireBus(&I2CD1);
			status = i2cMasterTransmitTimeout(&I2CD1, i2c_device_address, i2c_tx_data, 2, i2c_rx_data, 0, tmo);
			if (status != MSG_OK)
			{
				errors = i2cGetErrors(&I2CD1);
 800326c:	601a      	str	r2, [r3, #0]
				chprintf(chp, "error : %02.2x\r\n", errors);
 800326e:	f7ff fe67 	bl	8002f40 <chprintf.lto_priv.79>
 8003272:	e7e6      	b.n	8003242 <cmd_i2c.lto_priv.73+0xc2>
			}
			else
			{
				chprintf(chp, "%02.2xr%02.2x<%02.2x\r\n", i2c_device_address<<1, i2c_tx_data[0], i2c_tx_data[1]);
 8003274:	f89d 200d 	ldrb.w	r2, [sp, #13]
 8003278:	9200      	str	r2, [sp, #0]
 800327a:	f89d 300c 	ldrb.w	r3, [sp, #12]
 800327e:	490f      	ldr	r1, [pc, #60]	; (80032bc <cmd_i2c.lto_priv.73+0x13c>)
 8003280:	4628      	mov	r0, r5
 8003282:	0072      	lsls	r2, r6, #1
 8003284:	f7ff fe5c 	bl	8002f40 <chprintf.lto_priv.79>
 8003288:	e7db      	b.n	8003242 <cmd_i2c.lto_priv.73+0xc2>
			}
			i2cReleaseBus(&I2CD1);
		}
	}
}
 800328a:	b009      	add	sp, #36	; 0x24
 800328c:	bdf0      	pop	{r4, r5, r6, r7, pc}
 800328e:	bf00      	nop
 8003290:	08004428 	.word	0x08004428
 8003294:	200019ac 	.word	0x200019ac
 8003298:	20001be4 	.word	0x20001be4
 800329c:	0800447d 	.word	0x0800447d
 80032a0:	0800448d 	.word	0x0800448d
 80032a4:	08004494 	.word	0x08004494
 80032a8:	08004496 	.word	0x08004496
 80032ac:	08003f2b 	.word	0x08003f2b
 80032b0:	20001bd8 	.word	0x20001bd8
 80032b4:	0800446c 	.word	0x0800446c
 80032b8:	200019b8 	.word	0x200019b8
 80032bc:	08004498 	.word	0x08004498

080032c0 <cmd_serial.lto_priv.72>:
}

static void cmd_serial(BaseSequentialStream *chp, int argc, char *argv[]) {

	(void)argv;
	if (argc > 0) {
 80032c0:	2900      	cmp	r1, #0
             states[tp->p_state]);
    tp = chRegNextThread(tp);
  } while (tp != NULL);
}

static void cmd_serial(BaseSequentialStream *chp, int argc, char *argv[]) {
 80032c2:	b507      	push	{r0, r1, r2, lr}

	(void)argv;
	if (argc > 0) {
 80032c4:	dd05      	ble.n	80032d2 <cmd_serial.lto_priv.72+0x12>
		chprintf(chp, "Usage: serial\r\n");
 80032c6:	4909      	ldr	r1, [pc, #36]	; (80032ec <cmd_serial.lto_priv.72+0x2c>)
	// for STM32L152
	//chprintf(chp, "MCU serial : %08x%08x%08x\r\n", \
					*(__IO uint32_t*)(0x1FF80064),\
					*(__IO uint32_t*)(0x1FF80054),\
					*(__IO uint32_t*)(0x1FF80050));
}
 80032c8:	b003      	add	sp, #12
 80032ca:	f85d eb04 	ldr.w	lr, [sp], #4

static void cmd_serial(BaseSequentialStream *chp, int argc, char *argv[]) {

	(void)argv;
	if (argc > 0) {
		chprintf(chp, "Usage: serial\r\n");
 80032ce:	f7ff be37 	b.w	8002f40 <chprintf.lto_priv.79>
		return;
	}
	// for STM32F042
	chprintf(chp, "MCU serial : %08x%08x%08x\r\n", \
 80032d2:	4b07      	ldr	r3, [pc, #28]	; (80032f0 <cmd_serial.lto_priv.72+0x30>)
 80032d4:	4907      	ldr	r1, [pc, #28]	; (80032f4 <cmd_serial.lto_priv.72+0x34>)
 80032d6:	681a      	ldr	r2, [r3, #0]
 80032d8:	3b04      	subs	r3, #4
 80032da:	681b      	ldr	r3, [r3, #0]
 80032dc:	6809      	ldr	r1, [r1, #0]
 80032de:	9100      	str	r1, [sp, #0]
 80032e0:	4905      	ldr	r1, [pc, #20]	; (80032f8 <cmd_serial.lto_priv.72+0x38>)
 80032e2:	f7ff fe2d 	bl	8002f40 <chprintf.lto_priv.79>
	// for STM32L152
	//chprintf(chp, "MCU serial : %08x%08x%08x\r\n", \
					*(__IO uint32_t*)(0x1FF80064),\
					*(__IO uint32_t*)(0x1FF80054),\
					*(__IO uint32_t*)(0x1FF80050));
}
 80032e6:	b003      	add	sp, #12
 80032e8:	f85d fb04 	ldr.w	pc, [sp], #4
 80032ec:	080044af 	.word	0x080044af
 80032f0:	1ffff7b4 	.word	0x1ffff7b4
 80032f4:	1ffff7ac 	.word	0x1ffff7ac
 80032f8:	080044bf 	.word	0x080044bf
 80032fc:	00000000 	.word	0x00000000

08003300 <cmd_threads.lto_priv.71>:
  chprintf(chp, "core free memory : %u bytes\r\n", chCoreGetStatusX());
  chprintf(chp, "heap fragments   : %u\r\n", n);
  chprintf(chp, "heap free total  : %u bytes\r\n", size);
}

static void cmd_threads(BaseSequentialStream *chp, int argc, char *argv[]) {
 8003300:	b5f0      	push	{r4, r5, r6, r7, lr}
  static const char *states[] = {CH_STATE_NAMES};
  thread_t *tp;

  (void)argv;
  if (argc > 0) {
 8003302:	2900      	cmp	r1, #0
  chprintf(chp, "core free memory : %u bytes\r\n", chCoreGetStatusX());
  chprintf(chp, "heap fragments   : %u\r\n", n);
  chprintf(chp, "heap free total  : %u bytes\r\n", size);
}

static void cmd_threads(BaseSequentialStream *chp, int argc, char *argv[]) {
 8003304:	b085      	sub	sp, #20
 8003306:	4607      	mov	r7, r0
  static const char *states[] = {CH_STATE_NAMES};
  thread_t *tp;

  (void)argv;
  if (argc > 0) {
 8003308:	dd05      	ble.n	8003316 <cmd_threads.lto_priv.71+0x16>
    chprintf(chp, "Usage: threads\r\n");
 800330a:	491d      	ldr	r1, [pc, #116]	; (8003380 <cmd_threads.lto_priv.71+0x80>)
             (uint32_t)tp, (uint32_t)tp->p_ctx.r13,
             (uint32_t)tp->p_prio, (uint32_t)(tp->p_refs - 1),
             states[tp->p_state]);
    tp = chRegNextThread(tp);
  } while (tp != NULL);
}
 800330c:	b005      	add	sp, #20
 800330e:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
  static const char *states[] = {CH_STATE_NAMES};
  thread_t *tp;

  (void)argv;
  if (argc > 0) {
    chprintf(chp, "Usage: threads\r\n");
 8003312:	f7ff be15 	b.w	8002f40 <chprintf.lto_priv.79>
    return;
  }
  chprintf(chp, "    addr    stack prio refs     state\r\n");
 8003316:	491b      	ldr	r1, [pc, #108]	; (8003384 <cmd_threads.lto_priv.71+0x84>)
 8003318:	f7ff fe12 	bl	8002f40 <chprintf.lto_priv.79>
 800331c:	2320      	movs	r3, #32
 800331e:	f383 8811 	msr	BASEPRI, r3
 */
thread_t *chRegFirstThread(void) {
  thread_t *tp;

  chSysLock();
  tp = ch.rlist.r_newer;
 8003322:	4e19      	ldr	r6, [pc, #100]	; (8003388 <cmd_threads.lto_priv.71+0x88>)
 8003324:	6934      	ldr	r4, [r6, #16]
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs++;
 8003326:	7fa3      	ldrb	r3, [r4, #30]
 8003328:	3301      	adds	r3, #1
 800332a:	77a3      	strb	r3, [r4, #30]
 800332c:	2300      	movs	r3, #0
 800332e:	f383 8811 	msr	BASEPRI, r3
  tp = chRegFirstThread();
  do {
    chprintf(chp, "%08lx %08lx %4lu %4lu %9s %lu\r\n",
 8003332:	68a3      	ldr	r3, [r4, #8]
 8003334:	9300      	str	r3, [sp, #0]
             (uint32_t)tp, (uint32_t)tp->p_ctx.r13,
             (uint32_t)tp->p_prio, (uint32_t)(tp->p_refs - 1),
 8003336:	7fa3      	ldrb	r3, [r4, #30]
    return;
  }
  chprintf(chp, "    addr    stack prio refs     state\r\n");
  tp = chRegFirstThread();
  do {
    chprintf(chp, "%08lx %08lx %4lu %4lu %9s %lu\r\n",
 8003338:	4914      	ldr	r1, [pc, #80]	; (800338c <cmd_threads.lto_priv.71+0x8c>)
             (uint32_t)tp, (uint32_t)tp->p_ctx.r13,
             (uint32_t)tp->p_prio, (uint32_t)(tp->p_refs - 1),
 800333a:	3b01      	subs	r3, #1
    return;
  }
  chprintf(chp, "    addr    stack prio refs     state\r\n");
  tp = chRegFirstThread();
  do {
    chprintf(chp, "%08lx %08lx %4lu %4lu %9s %lu\r\n",
 800333c:	9301      	str	r3, [sp, #4]
 800333e:	7f22      	ldrb	r2, [r4, #28]
 8003340:	4b13      	ldr	r3, [pc, #76]	; (8003390 <cmd_threads.lto_priv.71+0x90>)
 8003342:	f853 3022 	ldr.w	r3, [r3, r2, lsl #2]
 8003346:	9302      	str	r3, [sp, #8]
 8003348:	68e3      	ldr	r3, [r4, #12]
 800334a:	4638      	mov	r0, r7
 800334c:	4622      	mov	r2, r4
 800334e:	f7ff fdf7 	bl	8002f40 <chprintf.lto_priv.79>
 8003352:	2320      	movs	r3, #32
 8003354:	f383 8811 	msr	BASEPRI, r3
 */
thread_t *chRegNextThread(thread_t *tp) {
  thread_t *ntp;

  chSysLock();
  ntp = tp->p_newer;
 8003358:	6925      	ldr	r5, [r4, #16]
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  if (ntp == (thread_t *)&ch.rlist) {
 800335a:	42b5      	cmp	r5, r6
    ntp = NULL;
  }
#if CH_CFG_USE_DYNAMIC == TRUE
  else {
    chDbgAssert(ntp->p_refs < (trefs_t)255, "too many references");
    ntp->p_refs++;
 800335c:	bf18      	it	ne
 800335e:	7fab      	ldrbne	r3, [r5, #30]
 8003360:	f04f 0200 	mov.w	r2, #0
 8003364:	bf1a      	itte	ne
 8003366:	3301      	addne	r3, #1
 8003368:	77ab      	strbne	r3, [r5, #30]
  chSysLock();
  ntp = tp->p_newer;
  /*lint -save -e9087 -e740 [11.3, 1.3] Cast required by list handling.*/
  if (ntp == (thread_t *)&ch.rlist) {
  /*lint -restore*/
    ntp = NULL;
 800336a:	4615      	moveq	r5, r2
 800336c:	f382 8811 	msr	BASEPRI, r2
    ntp->p_refs++;
  }
#endif
  chSysUnlock();
#if CH_CFG_USE_DYNAMIC == TRUE
  chThdRelease(tp);
 8003370:	4620      	mov	r0, r4
 8003372:	f7fd fe7d 	bl	8001070 <chThdRelease>
             (uint32_t)tp, (uint32_t)tp->p_ctx.r13,
             (uint32_t)tp->p_prio, (uint32_t)(tp->p_refs - 1),
             states[tp->p_state]);
    tp = chRegNextThread(tp);
  } while (tp != NULL);
 8003376:	b10d      	cbz	r5, 800337c <cmd_threads.lto_priv.71+0x7c>
 8003378:	462c      	mov	r4, r5
 800337a:	e7da      	b.n	8003332 <cmd_threads.lto_priv.71+0x32>
}
 800337c:	b005      	add	sp, #20
 800337e:	bdf0      	pop	{r4, r5, r6, r7, pc}
 8003380:	080044db 	.word	0x080044db
 8003384:	080044ec 	.word	0x080044ec
 8003388:	20001a00 	.word	0x20001a00
 800338c:	08004514 	.word	0x08004514
 8003390:	08004160 	.word	0x08004160
	...

080033a0 <cmd_mem.lto_priv.70>:

static void cmd_mem(BaseSequentialStream *chp, int argc, char *argv[]) {
  size_t n, size;

  (void)argv;
  if (argc > 0) {
 80033a0:	2900      	cmp	r1, #0
/* Command line related.                                                     */
/*===========================================================================*/

#define SHELL_WA_SIZE   THD_WORKING_AREA_SIZE(2048)

static void cmd_mem(BaseSequentialStream *chp, int argc, char *argv[]) {
 80033a2:	b570      	push	{r4, r5, r6, lr}
 80033a4:	4605      	mov	r5, r0
  size_t n, size;

  (void)argv;
  if (argc > 0) {
 80033a6:	dd04      	ble.n	80033b2 <cmd_mem.lto_priv.70+0x12>
    chprintf(chp, "Usage: mem\r\n");
 80033a8:	4914      	ldr	r1, [pc, #80]	; (80033fc <cmd_mem.lto_priv.70+0x5c>)
  }
  n = chHeapStatus(NULL, &size);
  chprintf(chp, "core free memory : %u bytes\r\n", chCoreGetStatusX());
  chprintf(chp, "heap fragments   : %u\r\n", n);
  chprintf(chp, "heap free total  : %u bytes\r\n", size);
}
 80033aa:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
static void cmd_mem(BaseSequentialStream *chp, int argc, char *argv[]) {
  size_t n, size;

  (void)argv;
  if (argc > 0) {
    chprintf(chp, "Usage: mem\r\n");
 80033ae:	f7ff bdc7 	b.w	8002f40 <chprintf.lto_priv.79>

  if (heapp == NULL) {
    heapp = &default_heap;
  }

  H_LOCK(heapp);
 80033b2:	4813      	ldr	r0, [pc, #76]	; (8003400 <cmd_mem.lto_priv.70+0x60>)
 80033b4:	f7fd fe14 	bl	8000fe0 <chMtxLock>
  sz = 0;
 80033b8:	2400      	movs	r4, #0
  n = 0;
  qp = &heapp->h_free;
 80033ba:	4b12      	ldr	r3, [pc, #72]	; (8003404 <cmd_mem.lto_priv.70+0x64>)
    heapp = &default_heap;
  }

  H_LOCK(heapp);
  sz = 0;
  n = 0;
 80033bc:	4626      	mov	r6, r4
  qp = &heapp->h_free;
  while (qp->h.u.next != NULL) {
 80033be:	681b      	ldr	r3, [r3, #0]
 80033c0:	b11b      	cbz	r3, 80033ca <cmd_mem.lto_priv.70+0x2a>
    sz += qp->h.u.next->h.size;
 80033c2:	685a      	ldr	r2, [r3, #4]
    n++;
 80033c4:	3601      	adds	r6, #1
  H_LOCK(heapp);
  sz = 0;
  n = 0;
  qp = &heapp->h_free;
  while (qp->h.u.next != NULL) {
    sz += qp->h.u.next->h.size;
 80033c6:	4414      	add	r4, r2
 80033c8:	e7f9      	b.n	80033be <cmd_mem.lto_priv.70+0x1e>
    qp = qp->h.u.next;
  }
  if (sizep != NULL) {
    *sizep = sz;
  }
  H_UNLOCK(heapp);
 80033ca:	480d      	ldr	r0, [pc, #52]	; (8003400 <cmd_mem.lto_priv.70+0x60>)
 80033cc:	f7fd fdd0 	bl	8000f70 <chMtxUnlock>
 * @xclass
 */
size_t chCoreGetStatusX(void) {

  /*lint -save -e9033 [10.8] The cast is safe.*/
  return (size_t)(endmem - nextmem);
 80033d0:	4b0d      	ldr	r3, [pc, #52]	; (8003408 <cmd_mem.lto_priv.70+0x68>)
    return;
  }
  n = chHeapStatus(NULL, &size);
  chprintf(chp, "core free memory : %u bytes\r\n", chCoreGetStatusX());
 80033d2:	490e      	ldr	r1, [pc, #56]	; (800340c <cmd_mem.lto_priv.70+0x6c>)
 80033d4:	681a      	ldr	r2, [r3, #0]
 80033d6:	4b0e      	ldr	r3, [pc, #56]	; (8003410 <cmd_mem.lto_priv.70+0x70>)
 80033d8:	681b      	ldr	r3, [r3, #0]
 80033da:	4628      	mov	r0, r5
 80033dc:	1ad2      	subs	r2, r2, r3
 80033de:	f7ff fdaf 	bl	8002f40 <chprintf.lto_priv.79>
  chprintf(chp, "heap fragments   : %u\r\n", n);
 80033e2:	4632      	mov	r2, r6
 80033e4:	4628      	mov	r0, r5
 80033e6:	490b      	ldr	r1, [pc, #44]	; (8003414 <cmd_mem.lto_priv.70+0x74>)
 80033e8:	f7ff fdaa 	bl	8002f40 <chprintf.lto_priv.79>
  chprintf(chp, "heap free total  : %u bytes\r\n", size);
 80033ec:	4628      	mov	r0, r5
 80033ee:	4622      	mov	r2, r4
 80033f0:	4909      	ldr	r1, [pc, #36]	; (8003418 <cmd_mem.lto_priv.70+0x78>)
}
 80033f2:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    return;
  }
  n = chHeapStatus(NULL, &size);
  chprintf(chp, "core free memory : %u bytes\r\n", chCoreGetStatusX());
  chprintf(chp, "heap fragments   : %u\r\n", n);
  chprintf(chp, "heap free total  : %u bytes\r\n", size);
 80033f6:	f7ff bda3 	b.w	8002f40 <chprintf.lto_priv.79>
 80033fa:	bf00      	nop
 80033fc:	08004534 	.word	0x08004534
 8003400:	200011d8 	.word	0x200011d8
 8003404:	200011d0 	.word	0x200011d0
 8003408:	20001264 	.word	0x20001264
 800340c:	08004541 	.word	0x08004541
 8003410:	20001258 	.word	0x20001258
 8003414:	0800455f 	.word	0x0800455f
 8003418:	08004577 	.word	0x08004577
 800341c:	00000000 	.word	0x00000000

08003420 <chVTGetSystemTime.lto_priv.80>:
 8003420:	2320      	movs	r3, #32
 8003422:	f383 8811 	msr	BASEPRI, r3
 8003426:	4b03      	ldr	r3, [pc, #12]	; (8003434 <chVTGetSystemTime.lto_priv.80+0x14>)
 8003428:	6a98      	ldr	r0, [r3, #40]	; 0x28
 800342a:	2300      	movs	r3, #0
 800342c:	f383 8811 	msr	BASEPRI, r3
  chSysLock();
  systime = chVTGetSystemTimeX();
  chSysUnlock();

  return systime;
}
 8003430:	4770      	bx	lr
 8003432:	bf00      	nop
 8003434:	20001a00 	.word	0x20001a00
	...

08003440 <Thread3.lto_priv.62>:
/*
 * MPL3115A2 absolute pressure sensor readout
 */
static THD_WORKING_AREA(waThread3, 128);
static THD_FUNCTION(Thread3, arg)
{
 8003440:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
 8003442:	4b30      	ldr	r3, [pc, #192]	; (8003504 <Thread3.lto_priv.62+0xc4>)
 8003444:	4a30      	ldr	r2, [pc, #192]	; (8003508 <Thread3.lto_priv.62+0xc8>)
 8003446:	699b      	ldr	r3, [r3, #24]
 8003448:	4830      	ldr	r0, [pc, #192]	; (800350c <Thread3.lto_priv.62+0xcc>)
 800344a:	619a      	str	r2, [r3, #24]
 800344c:	f7fd fdc8 	bl	8000fe0 <chMtxLock>
	/*
	 * Initialization of the sensor
	 */
	i2cAcquireBus(&I2CD1);

	i2c_tx_data[0]=0x26;   // CTRL_REG1 register
 8003450:	2326      	movs	r3, #38	; 0x26
 8003452:	f88d 300c 	strb.w	r3, [sp, #12]
	i2c_tx_data[1]=0x3B;   // ALT=0, RAW=0, OS=111, RST=0, OST=1, SBYB=1
 8003456:	233b      	movs	r3, #59	; 0x3b
 8003458:	f88d 300d 	strb.w	r3, [sp, #13]
	status = i2cMasterTransmitTimeout(&I2CD1, i2c_device_address, i2c_tx_data, 2, i2c_rx_data, 0, tmo);
 800345c:	2300      	movs	r3, #0
 800345e:	9300      	str	r3, [sp, #0]
 8003460:	2060      	movs	r0, #96	; 0x60
 8003462:	a903      	add	r1, sp, #12
 8003464:	2202      	movs	r2, #2
 8003466:	ab04      	add	r3, sp, #16
 8003468:	f000 f952 	bl	8003710 <i2cMasterTransmitTimeout.constprop.17>
 800346c:	4c28      	ldr	r4, [pc, #160]	; (8003510 <Thread3.lto_priv.62+0xd0>)
 800346e:	6020      	str	r0, [r4, #0]
	if (status != MSG_OK) {
 8003470:	b168      	cbz	r0, 800348e <Thread3.lto_priv.62+0x4e>
 8003472:	4b28      	ldr	r3, [pc, #160]	; (8003514 <Thread3.lto_priv.62+0xd4>)
 8003474:	689d      	ldr	r5, [r3, #8]
		errors = i2cGetErrors(&I2CD1);
 8003476:	4b28      	ldr	r3, [pc, #160]	; (8003518 <Thread3.lto_priv.62+0xd8>)
 8003478:	601d      	str	r5, [r3, #0]
		chprintf((BaseSequentialStream *)&SD1, "[%010d] i2c error : %02.2x at address %02.2x\r\n", chVTGetSystemTime(), errors, i2c_device_address); 
 800347a:	f7ff ffd1 	bl	8003420 <chVTGetSystemTime.lto_priv.80>
 800347e:	2360      	movs	r3, #96	; 0x60
 8003480:	4602      	mov	r2, r0
 8003482:	9300      	str	r3, [sp, #0]
 8003484:	4825      	ldr	r0, [pc, #148]	; (800351c <Thread3.lto_priv.62+0xdc>)
 8003486:	4926      	ldr	r1, [pc, #152]	; (8003520 <Thread3.lto_priv.62+0xe0>)
 8003488:	462b      	mov	r3, r5
 800348a:	f7ff fd59 	bl	8002f40 <chprintf.lto_priv.79>
 * @api
 */
static inline void osalMutexUnlock(mutex_t *mp) {

#if CH_CFG_USE_MUTEXES
  chMtxUnlock(mp);
 800348e:	481f      	ldr	r0, [pc, #124]	; (800350c <Thread3.lto_priv.62+0xcc>)
 8003490:	f7fd fd6e 	bl	8000f70 <chMtxUnlock>
	}

	i2cReleaseBus(&I2CD1);
	chThdSleepMilliseconds(1100);
 8003494:	f642 20f8 	movw	r0, #11000	; 0x2af8
 8003498:	f7fd fd22 	bl	8000ee0 <chThdSleep>
 * @api
 */
static inline void osalMutexLock(mutex_t *mp) {

#if CH_CFG_USE_MUTEXES
  chMtxLock(mp);
 800349c:	481b      	ldr	r0, [pc, #108]	; (800350c <Thread3.lto_priv.62+0xcc>)
 800349e:	f7fd fd9f 	bl	8000fe0 <chMtxLock>
	
	while (true) {
		i2cAcquireBus(&I2CD1);
		i2c_tx_data[0]=0x01;   // PRESS_OUT_XL register, auto-increment
		i2c_tx_data[1]=5;      // nb byte to read
 80034a2:	2305      	movs	r3, #5
	i2cReleaseBus(&I2CD1);
	chThdSleepMilliseconds(1100);
	
	while (true) {
		i2cAcquireBus(&I2CD1);
		i2c_tx_data[0]=0x01;   // PRESS_OUT_XL register, auto-increment
 80034a4:	2201      	movs	r2, #1
		i2c_tx_data[1]=5;      // nb byte to read
 80034a6:	f88d 300d 	strb.w	r3, [sp, #13]
		status = i2cMasterTransmitTimeout(&I2CD1, i2c_device_address, i2c_tx_data, 1, i2c_rx_data, i2c_tx_data[1], tmo);
 80034aa:	9300      	str	r3, [sp, #0]
 80034ac:	2060      	movs	r0, #96	; 0x60
 80034ae:	a903      	add	r1, sp, #12
 80034b0:	ab04      	add	r3, sp, #16
	i2cReleaseBus(&I2CD1);
	chThdSleepMilliseconds(1100);
	
	while (true) {
		i2cAcquireBus(&I2CD1);
		i2c_tx_data[0]=0x01;   // PRESS_OUT_XL register, auto-increment
 80034b2:	f88d 200c 	strb.w	r2, [sp, #12]
		i2c_tx_data[1]=5;      // nb byte to read
		status = i2cMasterTransmitTimeout(&I2CD1, i2c_device_address, i2c_tx_data, 1, i2c_rx_data, i2c_tx_data[1], tmo);
 80034b6:	f000 f92b 	bl	8003710 <i2cMasterTransmitTimeout.constprop.17>
 80034ba:	6020      	str	r0, [r4, #0]
		if (status != MSG_OK) {
 80034bc:	2800      	cmp	r0, #0
 80034be:	d1d8      	bne.n	8003472 <Thread3.lto_priv.62+0x32>
		}
		else
		{
			/* Build the resulting data into float 18bits.2bits pascals */
			tempPressure = (((uint32_t) i2c_rx_data[0]) << 12);
			tempPressure |= (((uint32_t) i2c_rx_data[1]) << 4);
 80034c0:	f89d 3011 	ldrb.w	r3, [sp, #17]
			chprintf((BaseSequentialStream *)&SD1, "[%010d] i2c error : %02.2x at address %02.2x\r\n", chVTGetSystemTime(), errors, i2c_device_address); 
		}
		else
		{
			/* Build the resulting data into float 18bits.2bits pascals */
			tempPressure = (((uint32_t) i2c_rx_data[0]) << 12);
 80034c4:	f89d 2010 	ldrb.w	r2, [sp, #16]
			tempPressure |= (((uint32_t) i2c_rx_data[1]) << 4);
 80034c8:	011b      	lsls	r3, r3, #4
 80034ca:	ea43 3302 	orr.w	r3, r3, r2, lsl #12
			tempPressure |= (((uint32_t) (i2c_rx_data[2] & 0xF0)) >> 4);
 80034ce:	f89d 2012 	ldrb.w	r2, [sp, #18]
 80034d2:	ea43 1312 	orr.w	r3, r3, r2, lsr #4
 80034d6:	ee07 3a90 	vmov	s15, r3
			pressure = ((float_t) tempPressure) / 4;
 80034da:	4b12      	ldr	r3, [pc, #72]	; (8003524 <Thread3.lto_priv.62+0xe4>)

			tempTemperature = (((int16_t) i2c_rx_data[3]) << 4);
 80034dc:	f89d 2013 	ldrb.w	r2, [sp, #19]
		{
			/* Build the resulting data into float 18bits.2bits pascals */
			tempPressure = (((uint32_t) i2c_rx_data[0]) << 12);
			tempPressure |= (((uint32_t) i2c_rx_data[1]) << 4);
			tempPressure |= (((uint32_t) (i2c_rx_data[2] & 0xF0)) >> 4);
			pressure = ((float_t) tempPressure) / 4;
 80034e0:	eefa 7acf 	vcvt.f32.s32	s15, s15, #2
 80034e4:	edc3 7a00 	vstr	s15, [r3]

			tempTemperature = (((int16_t) i2c_rx_data[3]) << 4);
			tempTemperature |= (((int16_t) i2c_rx_data[4]&0xF0) >> 4);
 80034e8:	f89d 3014 	ldrb.w	r3, [sp, #20]
 80034ec:	091b      	lsrs	r3, r3, #4
			if(tempTemperature & 0x1000)
			{
				tempTemperature=~(tempTemperature & 0x1FFF) +1;
				tempTemperature=(tempTemperature & 0x1FFF) * -1;
			}
			temperature1 = ((float_t)tempTemperature/16);
 80034ee:	ea43 1302 	orr.w	r3, r3, r2, lsl #4
 80034f2:	ee07 3a90 	vmov	s15, r3
 80034f6:	4b0c      	ldr	r3, [pc, #48]	; (8003528 <Thread3.lto_priv.62+0xe8>)
 80034f8:	eefa 7ace 	vcvt.f32.s32	s15, s15, #4
 80034fc:	edc3 7a00 	vstr	s15, [r3]
 8003500:	e7c5      	b.n	800348e <Thread3.lto_priv.62+0x4e>
 8003502:	bf00      	nop
 8003504:	20001a00 	.word	0x20001a00
 8003508:	08004595 	.word	0x08004595
 800350c:	20001be4 	.word	0x20001be4
 8003510:	200019a8 	.word	0x200019a8
 8003514:	20001bd8 	.word	0x20001bd8
 8003518:	200019bc 	.word	0x200019bc
 800351c:	20000e88 	.word	0x20000e88
 8003520:	08003e32 	.word	0x08003e32
 8003524:	20000e84 	.word	0x20000e84
 8003528:	2000125c 	.word	0x2000125c
 800352c:	00000000 	.word	0x00000000

08003530 <chSchWakeupS.constprop.50>:
 * @param[in] ntp       the thread to be made ready
 * @param[in] msg       the wakeup message
 *
 * @sclass
 */
void chSchWakeupS(thread_t *ntp, msg_t msg) {
 8003530:	b538      	push	{r3, r4, r5, lr}

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio) {
 8003532:	4d0c      	ldr	r5, [pc, #48]	; (8003564 <chSchWakeupS.constprop.50+0x34>)
 8003534:	6881      	ldr	r1, [r0, #8]

  chDbgCheckClassS();

  /* Storing the message to be retrieved by the target thread when it will
     restart execution.*/
  ntp->p_u.rdymsg = msg;
 8003536:	2300      	movs	r3, #0
 8003538:	6203      	str	r3, [r0, #32]

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio) {
 800353a:	69ab      	ldr	r3, [r5, #24]
 800353c:	689a      	ldr	r2, [r3, #8]
 800353e:	4291      	cmp	r1, r2
 * @param[in] ntp       the thread to be made ready
 * @param[in] msg       the wakeup message
 *
 * @sclass
 */
void chSchWakeupS(thread_t *ntp, msg_t msg) {
 8003540:	4604      	mov	r4, r0

  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio) {
 8003542:	d803      	bhi.n	800354c <chSchWakeupS.constprop.50+0x1c>
    }
#endif
    ntp->p_state = CH_STATE_CURRENT;
    chSysSwitch(ntp, otp);
  }
}
 8003544:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  /* If the waken thread has a not-greater priority than the current
     one then it is just inserted in the ready list else it made
     running immediately and the invoking thread goes in the ready
     list instead.*/
  if (ntp->p_prio <= currp->p_prio) {
    (void) chSchReadyI(ntp);
 8003548:	f7fd bcda 	b.w	8000f00 <chSchReadyI>
  }
  else {
    thread_t *otp = chSchReadyI(currp);
 800354c:	4618      	mov	r0, r3
 800354e:	f7fd fcd7 	bl	8000f00 <chSchReadyI>
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
    if (otp->p_prio == IDLEPRIO) {
      CH_CFG_IDLE_LEAVE_HOOK();
    }
#endif
    ntp->p_state = CH_STATE_CURRENT;
 8003552:	2301      	movs	r3, #1
     list instead.*/
  if (ntp->p_prio <= currp->p_prio) {
    (void) chSchReadyI(ntp);
  }
  else {
    thread_t *otp = chSchReadyI(currp);
 8003554:	4601      	mov	r1, r0
    setcurrp(ntp);
 8003556:	61ac      	str	r4, [r5, #24]
#if defined(CH_CFG_IDLE_LEAVE_HOOK)
    if (otp->p_prio == IDLEPRIO) {
      CH_CFG_IDLE_LEAVE_HOOK();
    }
#endif
    ntp->p_state = CH_STATE_CURRENT;
 8003558:	7723      	strb	r3, [r4, #28]
    chSysSwitch(ntp, otp);
 800355a:	4620      	mov	r0, r4
  }
}
 800355c:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
    if (otp->p_prio == IDLEPRIO) {
      CH_CFG_IDLE_LEAVE_HOOK();
    }
#endif
    ntp->p_state = CH_STATE_CURRENT;
    chSysSwitch(ntp, otp);
 8003560:	f7fc bea6 	b.w	80002b0 <_port_switch>
 8003564:	20001a00 	.word	0x20001a00
	...

08003570 <chThdCreateStatic.constprop.49>:
 * @return              The pointer to the @p thread_t structure allocated for
 *                      the thread into the working space area.
 *
 * @api
 */
thread_t *chThdCreateStatic(void *wsp, size_t size,
 8003570:	b538      	push	{r3, r4, r5, lr}
 8003572:	4604      	mov	r4, r0
 8003574:	2520      	movs	r5, #32
 8003576:	f385 8811 	msr	BASEPRI, r5

  chDbgCheckClassI();
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 800357a:	3964      	subs	r1, #100	; 0x64
 800357c:	4401      	add	r1, r0
 800357e:	60c1      	str	r1, [r0, #12]
 8003580:	640b      	str	r3, [r1, #64]	; 0x40
 8003582:	4b11      	ldr	r3, [pc, #68]	; (80035c8 <chThdCreateStatic.constprop.49+0x58>)
 8003584:	660b      	str	r3, [r1, #96]	; 0x60
 8003586:	2500      	movs	r5, #0
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
 8003588:	2302      	movs	r3, #2

  chDbgCheckClassI();
  chDbgCheck((wsp != NULL) && (size >= THD_WORKING_AREA_SIZE(0)) &&
             (prio <= HIGHPRIO) && (pf != NULL));

  PORT_SETUP_CONTEXT(tp, wsp, size, pf, arg);
 800358a:	644d      	str	r5, [r1, #68]	; 0x44
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
 800358c:	7703      	strb	r3, [r0, #28]
  tp->p_flags = CH_FLAG_MODE_STATIC;
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
 800358e:	2301      	movs	r3, #1
 8003590:	77c3      	strb	r3, [r0, #31]
#endif
#if CH_DBG_THREADS_PROFILING == TRUE
  tp->p_time = (systime_t)0;
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
 8003592:	7783      	strb	r3, [r0, #30]
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
 8003594:	4b0d      	ldr	r3, [pc, #52]	; (80035cc <chThdCreateStatic.constprop.49+0x5c>)
 *
 * @notapi
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
 8003596:	6082      	str	r2, [r0, #8]
  tp->p_flags = CH_FLAG_MODE_STATIC;
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->p_realprio = prio;
 8003598:	63c2      	str	r2, [r0, #60]	; 0x3c
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
  REG_INSERT(tp);
 800359a:	695a      	ldr	r2, [r3, #20]
 800359c:	6103      	str	r3, [r0, #16]
 800359e:	6142      	str	r2, [r0, #20]
 */
thread_t *_thread_init(thread_t *tp, tprio_t prio) {

  tp->p_prio = prio;
  tp->p_state = CH_STATE_WTSTART;
  tp->p_flags = CH_FLAG_MODE_STATIC;
 80035a0:	7745      	strb	r5, [r0, #29]
#if CH_CFG_TIME_QUANTUM > 0
  tp->p_preempt = (tslices_t)CH_CFG_TIME_QUANTUM;
#endif
#if CH_CFG_USE_MUTEXES == TRUE
  tp->p_realprio = prio;
  tp->p_mtxlist = NULL;
 80035a2:	6385      	str	r5, [r0, #56]	; 0x38
#endif
#if CH_CFG_USE_EVENTS == TRUE
  tp->p_epending = (eventmask_t)0;
 80035a4:	6345      	str	r5, [r0, #52]	; 0x34
#endif
#if CH_CFG_USE_DYNAMIC == TRUE
  tp->p_refs = (trefs_t)1;
#endif
#if CH_CFG_USE_REGISTRY == TRUE
  tp->p_name = NULL;
 80035a6:	6185      	str	r5, [r0, #24]
  REG_INSERT(tp);
 80035a8:	6110      	str	r0, [r2, #16]
 80035aa:	6158      	str	r0, [r3, #20]
#endif
#if CH_CFG_USE_WAITEXIT == TRUE
  list_init(&tp->p_waiting);
 80035ac:	f100 0324 	add.w	r3, r0, #36	; 0x24
 *
 * @notapi
 */
static inline void list_init(threads_list_t *tlp) {

  tlp->p_next = (thread_t *)tlp;
 80035b0:	6243      	str	r3, [r0, #36]	; 0x24
#endif
#if CH_CFG_USE_MESSAGES == TRUE
  queue_init(&tp->p_msgqueue);
 80035b2:	f100 0328 	add.w	r3, r0, #40	; 0x28
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 80035b6:	6283      	str	r3, [r0, #40]	; 0x28
  tqp->p_prev = (thread_t *)tqp;
 80035b8:	62c3      	str	r3, [r0, #44]	; 0x2c
                  CH_DBG_STACK_FILL_VALUE);
#endif

  chSysLock();
  tp = chThdCreateI(wsp, size, prio, pf, arg);
  chSchWakeupS(tp, MSG_OK);
 80035ba:	f7ff ffb9 	bl	8003530 <chSchWakeupS.constprop.50>
 80035be:	f385 8811 	msr	BASEPRI, r5
  chSysUnlock();

  return tp;
}
 80035c2:	4620      	mov	r0, r4
 80035c4:	bd38      	pop	{r3, r4, r5, pc}
 80035c6:	bf00      	nop
 80035c8:	080002c9 	.word	0x080002c9
 80035cc:	20001a00 	.word	0x20001a00

080035d0 <sdObjectInit.constprop.37>:
 *
 * @init
 */
void sdObjectInit(SerialDriver *sdp, qnotify_t inotify, qnotify_t onotify) {

  sdp->vmt = &vmt;
 80035d0:	4603      	mov	r3, r0
 80035d2:	4a12      	ldr	r2, [pc, #72]	; (800361c <sdObjectInit.constprop.37+0x4c>)
 80035d4:	f843 2b04 	str.w	r2, [r3], #4
 * @init
 */
void chIQObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                    qnotify_t infy, void *link) {

  chThdQueueObjectInit(&iqp->q_waiting);
 80035d8:	f100 020c 	add.w	r2, r0, #12
 *
 * @init
 */
static inline void chEvtObjectInit(event_source_t *esp) {

  esp->es_next = (event_listener_t *)esp;
 80035dc:	6043      	str	r3, [r0, #4]
  osalEventObjectInit(&sdp->event);
  sdp->state = SD_STOP;
 80035de:	2301      	movs	r3, #1
 80035e0:	7203      	strb	r3, [r0, #8]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 80035e2:	60c2      	str	r2, [r0, #12]
  iqObjectInit(&sdp->iqueue, sdp->ib, SERIAL_BUFFERS_SIZE, inotify, sdp);
 80035e4:	f100 0354 	add.w	r3, r0, #84	; 0x54
  tqp->p_prev = (thread_t *)tqp;
 80035e8:	6102      	str	r2, [r0, #16]
  iqp->q_counter = 0;
 80035ea:	2200      	movs	r2, #0
 80035ec:	6142      	str	r2, [r0, #20]
  iqp->q_buffer  = bp;
 80035ee:	6183      	str	r3, [r0, #24]
  iqp->q_rdptr   = bp;
 80035f0:	6243      	str	r3, [r0, #36]	; 0x24
  iqp->q_wrptr   = bp;
 80035f2:	6203      	str	r3, [r0, #32]
  iqp->q_top     = bp + size;
  iqp->q_notify  = infy;
 80035f4:	6282      	str	r2, [r0, #40]	; 0x28
  chThdQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
  iqp->q_buffer  = bp;
  iqp->q_rdptr   = bp;
  iqp->q_wrptr   = bp;
  iqp->q_top     = bp + size;
 80035f6:	f100 0364 	add.w	r3, r0, #100	; 0x64
 * @init
 */
void chOQObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                    qnotify_t onfy, void *link) {

  chThdQueueObjectInit(&oqp->q_waiting);
 80035fa:	f100 0230 	add.w	r2, r0, #48	; 0x30
  chThdQueueObjectInit(&iqp->q_waiting);
  iqp->q_counter = 0;
  iqp->q_buffer  = bp;
  iqp->q_rdptr   = bp;
  iqp->q_wrptr   = bp;
  iqp->q_top     = bp + size;
 80035fe:	61c3      	str	r3, [r0, #28]
 *
 * @notapi
 */
static inline void queue_init(threads_queue_t *tqp) {

  tqp->p_next = (thread_t *)tqp;
 8003600:	6302      	str	r2, [r0, #48]	; 0x30
  tqp->p_prev = (thread_t *)tqp;
 8003602:	6342      	str	r2, [r0, #52]	; 0x34
void chOQObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                    qnotify_t onfy, void *link) {

  chThdQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
  oqp->q_buffer  = bp;
 8003604:	63c3      	str	r3, [r0, #60]	; 0x3c
 */
void chOQObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                    qnotify_t onfy, void *link) {

  chThdQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
 8003606:	2210      	movs	r2, #16
  oqp->q_buffer  = bp;
  oqp->q_rdptr   = bp;
 8003608:	6483      	str	r3, [r0, #72]	; 0x48
  oqp->q_wrptr   = bp;
 800360a:	6443      	str	r3, [r0, #68]	; 0x44
  oqp->q_top     = bp + size;
 800360c:	f100 0374 	add.w	r3, r0, #116	; 0x74
  iqp->q_buffer  = bp;
  iqp->q_rdptr   = bp;
  iqp->q_wrptr   = bp;
  iqp->q_top     = bp + size;
  iqp->q_notify  = infy;
  iqp->q_link    = link;
 8003610:	62c0      	str	r0, [r0, #44]	; 0x2c
 */
void chOQObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                    qnotify_t onfy, void *link) {

  chThdQueueObjectInit(&oqp->q_waiting);
  oqp->q_counter = size;
 8003612:	6382      	str	r2, [r0, #56]	; 0x38
  oqp->q_buffer  = bp;
  oqp->q_rdptr   = bp;
  oqp->q_wrptr   = bp;
  oqp->q_top     = bp + size;
 8003614:	6403      	str	r3, [r0, #64]	; 0x40
  oqp->q_notify  = onfy;
 8003616:	64c1      	str	r1, [r0, #76]	; 0x4c
  oqp->q_link    = link;
 8003618:	6500      	str	r0, [r0, #80]	; 0x50
 800361a:	4770      	bx	lr
 800361c:	08004630 	.word	0x08004630

08003620 <adc_lld_start_conversion.constprop.26>:
 *
 * @notapi
 */
void adc_lld_start_conversion(ADCDriver *adcp) {
  uint32_t dmamode, ccr, cfgr;
  const ADCConversionGroup *grpp = adcp->grpp;
 8003620:	4929      	ldr	r1, [pc, #164]	; (80036c8 <adc_lld_start_conversion.constprop.26+0xa8>)
 *
 * @param[in] adcp      pointer to the @p ADCDriver object
 *
 * @notapi
 */
void adc_lld_start_conversion(ADCDriver *adcp) {
 8003622:	b5f0      	push	{r4, r5, r6, r7, lr}
  osalDbgAssert(!STM32_ADC_DUAL_MODE || ((grpp->num_channels & 1) == 0),
                "odd number of channels in dual mode");

  /* Calculating control registers values.*/
  dmamode = adcp->dmamode;
  ccr     = grpp->ccr | (adcp->adcc->CCR & (ADC_CCR_CKMODE_MASK |
 8003624:	f8d1 e028 	ldr.w	lr, [r1, #40]	; 0x28
 *
 * @notapi
 */
void adc_lld_start_conversion(ADCDriver *adcp) {
  uint32_t dmamode, ccr, cfgr;
  const ADCConversionGroup *grpp = adcp->grpp;
 8003628:	690b      	ldr	r3, [r1, #16]
  osalDbgAssert(!STM32_ADC_DUAL_MODE || ((grpp->num_channels & 1) == 0),
                "odd number of channels in dual mode");

  /* Calculating control registers values.*/
  dmamode = adcp->dmamode;
  ccr     = grpp->ccr | (adcp->adcc->CCR & (ADC_CCR_CKMODE_MASK |
 800362a:	f8de 2008 	ldr.w	r2, [lr, #8]
 800362e:	6958      	ldr	r0, [r3, #20]
                                            ADC_CCR_MDMA_MASK));
  cfgr    = grpp->cfgr | ADC_CFGR_DMAEN;
 8003630:	68de      	ldr	r6, [r3, #12]

  osalDbgAssert(!STM32_ADC_DUAL_MODE || ((grpp->num_channels & 1) == 0),
                "odd number of channels in dual mode");

  /* Calculating control registers values.*/
  dmamode = adcp->dmamode;
 8003632:	6b8d      	ldr	r5, [r1, #56]	; 0x38
  ccr     = grpp->ccr | (adcp->adcc->CCR & (ADC_CCR_CKMODE_MASK |
 8003634:	f402 3270 	and.w	r2, r2, #245760	; 0x3c000
 8003638:	4302      	orrs	r2, r0
                                            ADC_CCR_MDMA_MASK));
  cfgr    = grpp->cfgr | ADC_CFGR_DMAEN;
  if (grpp->circular) {
 800363a:	7818      	ldrb	r0, [r3, #0]

  /* Calculating control registers values.*/
  dmamode = adcp->dmamode;
  ccr     = grpp->ccr | (adcp->adcc->CCR & (ADC_CCR_CKMODE_MASK |
                                            ADC_CCR_MDMA_MASK));
  cfgr    = grpp->cfgr | ADC_CFGR_DMAEN;
 800363c:	f046 0601 	orr.w	r6, r6, #1
  if (grpp->circular) {
 8003640:	b140      	cbz	r0, 8003654 <adc_lld_start_conversion.constprop.26+0x34>
#if STM32_ADC_DUAL_MODE
    ccr  |= ADC_CCR_DMACFG_CIRCULAR;
#else
    cfgr |= ADC_CFGR_DMACFG_CIRCULAR;
#endif
    if (adcp->depth > 1) {
 8003642:	68c8      	ldr	r0, [r1, #12]
 8003644:	2801      	cmp	r0, #1
                                            ADC_CCR_MDMA_MASK));
  cfgr    = grpp->cfgr | ADC_CFGR_DMAEN;
  if (grpp->circular) {
    dmamode |= STM32_DMA_CR_CIRC;
#if STM32_ADC_DUAL_MODE
    ccr  |= ADC_CCR_DMACFG_CIRCULAR;
 8003646:	f442 5200 	orr.w	r2, r2, #8192	; 0x2000
  dmamode = adcp->dmamode;
  ccr     = grpp->ccr | (adcp->adcc->CCR & (ADC_CCR_CKMODE_MASK |
                                            ADC_CCR_MDMA_MASK));
  cfgr    = grpp->cfgr | ADC_CFGR_DMAEN;
  if (grpp->circular) {
    dmamode |= STM32_DMA_CR_CIRC;
 800364a:	bf94      	ite	ls
 800364c:	f045 0520 	orrls.w	r5, r5, #32
    cfgr |= ADC_CFGR_DMACFG_CIRCULAR;
#endif
    if (adcp->depth > 1) {
      /* If circular buffer depth > 1, then the half transfer interrupt
         is enabled in order to allow streaming processing.*/
      dmamode |= STM32_DMA_CR_HTIE;
 8003650:	f045 0524 	orrhi.w	r5, r5, #36	; 0x24
    }
  }

  /* DMA setup.*/
  dmaStreamSetMemory0(adcp->dmastp, adcp->samples);
 8003654:	6b48      	ldr	r0, [r1, #52]	; 0x34
#if STM32_ADC_DUAL_MODE
  dmaStreamSetTransactionSize(adcp->dmastp, ((uint32_t)grpp->num_channels/2) *
 8003656:	68cf      	ldr	r7, [r1, #12]
      dmamode |= STM32_DMA_CR_HTIE;
    }
  }

  /* DMA setup.*/
  dmaStreamSetMemory0(adcp->dmastp, adcp->samples);
 8003658:	6804      	ldr	r4, [r0, #0]
 800365a:	6888      	ldr	r0, [r1, #8]
 800365c:	60e0      	str	r0, [r4, #12]
#if STM32_ADC_DUAL_MODE
  dmaStreamSetTransactionSize(adcp->dmastp, ((uint32_t)grpp->num_channels/2) *
 800365e:	8858      	ldrh	r0, [r3, #2]
 8003660:	0840      	lsrs	r0, r0, #1
 8003662:	4347      	muls	r7, r0
 8003664:	6067      	str	r7, [r4, #4]
                                            (uint32_t)adcp->depth);
#else
  dmaStreamSetTransactionSize(adcp->dmastp, (uint32_t)grpp->num_channels *
                                            (uint32_t)adcp->depth);
#endif
  dmaStreamSetMode(adcp->dmastp, dmamode);
 8003666:	6025      	str	r5, [r4, #0]
  dmaStreamEnable(adcp->dmastp);
 8003668:	6825      	ldr	r5, [r4, #0]
 800366a:	f045 0501 	orr.w	r5, r5, #1
 800366e:	6025      	str	r5, [r4, #0]

  /* Configuring the CCR register with the static settings ORed with
     the user-specified settings in the conversion group configuration
     structure.*/
  adcp->adcc->CCR   = ccr;
 8003670:	f8ce 2008 	str.w	r2, [lr, #8]

  /* ADC setup, if it is defined a callback for the analog watch dog then it
     is enabled.*/
  adcp->adcm->ISR   = adcp->adcm->ISR;
 8003674:	6aca      	ldr	r2, [r1, #44]	; 0x2c
  adcp->adcm->SMPR2 = grpp->smpr[1];
  adcp->adcm->SQR1  = grpp->sqr[0] | ADC_SQR1_NUM_CH(grpp->num_channels / 2);
  adcp->adcm->SQR2  = grpp->sqr[1];
  adcp->adcm->SQR3  = grpp->sqr[2];
  adcp->adcm->SQR4  = grpp->sqr[3];
  adcp->adcs->SMPR1 = grpp->ssmpr[0];
 8003676:	6b09      	ldr	r1, [r1, #48]	; 0x30
     structure.*/
  adcp->adcc->CCR   = ccr;

  /* ADC setup, if it is defined a callback for the analog watch dog then it
     is enabled.*/
  adcp->adcm->ISR   = adcp->adcm->ISR;
 8003678:	6814      	ldr	r4, [r2, #0]
 800367a:	6014      	str	r4, [r2, #0]
  adcp->adcm->IER   = ADC_IER_OVR | ADC_IER_AWD1;
 800367c:	2490      	movs	r4, #144	; 0x90
 800367e:	6054      	str	r4, [r2, #4]
  adcp->adcm->TR1   = grpp->tr1;
 8003680:	691c      	ldr	r4, [r3, #16]
 8003682:	6214      	str	r4, [r2, #32]
#if STM32_ADC_DUAL_MODE
  adcp->adcm->SMPR1 = grpp->smpr[0];
 8003684:	699c      	ldr	r4, [r3, #24]
 8003686:	6154      	str	r4, [r2, #20]
  adcp->adcm->SMPR2 = grpp->smpr[1];
 8003688:	69dc      	ldr	r4, [r3, #28]
 800368a:	6194      	str	r4, [r2, #24]
  adcp->adcm->SQR1  = grpp->sqr[0] | ADC_SQR1_NUM_CH(grpp->num_channels / 2);
 800368c:	6a1c      	ldr	r4, [r3, #32]
 800368e:	3801      	subs	r0, #1
 8003690:	4304      	orrs	r4, r0
 8003692:	6314      	str	r4, [r2, #48]	; 0x30
  adcp->adcm->SQR2  = grpp->sqr[1];
 8003694:	6a5c      	ldr	r4, [r3, #36]	; 0x24
 8003696:	6354      	str	r4, [r2, #52]	; 0x34
  adcp->adcm->SQR3  = grpp->sqr[2];
 8003698:	6a9c      	ldr	r4, [r3, #40]	; 0x28
 800369a:	6394      	str	r4, [r2, #56]	; 0x38
  adcp->adcm->SQR4  = grpp->sqr[3];
 800369c:	6adc      	ldr	r4, [r3, #44]	; 0x2c
 800369e:	63d4      	str	r4, [r2, #60]	; 0x3c
  adcp->adcs->SMPR1 = grpp->ssmpr[0];
 80036a0:	6b1c      	ldr	r4, [r3, #48]	; 0x30
 80036a2:	614c      	str	r4, [r1, #20]
  adcp->adcs->SMPR2 = grpp->ssmpr[1];
 80036a4:	6b5c      	ldr	r4, [r3, #52]	; 0x34
 80036a6:	618c      	str	r4, [r1, #24]
  adcp->adcs->SQR1  = grpp->ssqr[0] | ADC_SQR1_NUM_CH(grpp->num_channels / 2);
 80036a8:	6b9c      	ldr	r4, [r3, #56]	; 0x38
 80036aa:	4320      	orrs	r0, r4
 80036ac:	6308      	str	r0, [r1, #48]	; 0x30
  adcp->adcs->SQR2  = grpp->ssqr[1];
 80036ae:	6bd8      	ldr	r0, [r3, #60]	; 0x3c
 80036b0:	6348      	str	r0, [r1, #52]	; 0x34
  adcp->adcs->SQR3  = grpp->ssqr[2];
 80036b2:	6c18      	ldr	r0, [r3, #64]	; 0x40
  adcp->adcs->SQR4  = grpp->ssqr[3];
 80036b4:	6c5b      	ldr	r3, [r3, #68]	; 0x44
  adcp->adcm->SQR4  = grpp->sqr[3];
  adcp->adcs->SMPR1 = grpp->ssmpr[0];
  adcp->adcs->SMPR2 = grpp->ssmpr[1];
  adcp->adcs->SQR1  = grpp->ssqr[0] | ADC_SQR1_NUM_CH(grpp->num_channels / 2);
  adcp->adcs->SQR2  = grpp->ssqr[1];
  adcp->adcs->SQR3  = grpp->ssqr[2];
 80036b6:	6388      	str	r0, [r1, #56]	; 0x38
  adcp->adcs->SQR4  = grpp->ssqr[3];
 80036b8:	63cb      	str	r3, [r1, #60]	; 0x3c
  adcp->adcm->SQR3  = grpp->sqr[2];
  adcp->adcm->SQR4  = grpp->sqr[3];
#endif /* !STM32_ADC_DUAL_MODE */

  /* ADC configuration.*/
  adcp->adcm->CFGR  = cfgr;
 80036ba:	60d6      	str	r6, [r2, #12]

  /* Starting conversion.*/
  adcp->adcm->CR   |= ADC_CR_ADSTART;
 80036bc:	6893      	ldr	r3, [r2, #8]
 80036be:	f043 0304 	orr.w	r3, r3, #4
 80036c2:	6093      	str	r3, [r2, #8]
 80036c4:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80036c6:	bf00      	nop
 80036c8:	200019c0 	.word	0x200019c0
 80036cc:	00000000 	.word	0x00000000

080036d0 <i2c_lld_setup_tx_transfer.constprop.20>:
 * @param[in] i2cp      pointer to the @p I2CDriver object
 *
 * @notapi
 */
static void i2c_lld_setup_tx_transfer(I2CDriver *i2cp) {
  I2C_TypeDef *dp = i2cp->i2c;
 80036d0:	4a0d      	ldr	r2, [pc, #52]	; (8003708 <i2c_lld_setup_tx_transfer.constprop.20+0x38>)
  uint32_t reload;
  size_t n;

  /* The unit can transfer 255 bytes maximum in a single operation.*/
  n = i2c_lld_get_txbytes(i2cp);
 80036d2:	6ad3      	ldr	r3, [r2, #44]	; 0x2c
 *
 * @param[in] i2cp      pointer to the @p I2CDriver object
 *
 * @notapi
 */
static void i2c_lld_setup_tx_transfer(I2CDriver *i2cp) {
 80036d4:	b510      	push	{r4, lr}
  I2C_TypeDef *dp = i2cp->i2c;
  uint32_t reload;
  size_t n;

  /* The unit can transfer 255 bytes maximum in a single operation.*/
  n = i2c_lld_get_txbytes(i2cp);
 80036d6:	681b      	ldr	r3, [r3, #0]
 * @param[in] i2cp      pointer to the @p I2CDriver object
 *
 * @notapi
 */
static void i2c_lld_setup_tx_transfer(I2CDriver *i2cp) {
  I2C_TypeDef *dp = i2cp->i2c;
 80036d8:	6b14      	ldr	r4, [r2, #48]	; 0x30
  uint32_t reload;
  size_t n;

  /* The unit can transfer 255 bytes maximum in a single operation.*/
  n = i2c_lld_get_txbytes(i2cp);
 80036da:	6858      	ldr	r0, [r3, #4]
 80036dc:	4611      	mov	r1, r2
    reload = 0U;
  }

  /* Configures the CR2 registers with both the calculated and static
     settings.*/
  dp->CR2 = (dp->CR2 & ~(I2C_CR2_NBYTES | I2C_CR2_RELOAD)) | i2cp->config->cr2 |
 80036de:	6862      	ldr	r2, [r4, #4]
 80036e0:	6849      	ldr	r1, [r1, #4]
 80036e2:	f022 72ff 	bic.w	r2, r2, #33423360	; 0x1fe0000
 80036e6:	6889      	ldr	r1, [r1, #8]
  uint32_t reload;
  size_t n;

  /* The unit can transfer 255 bytes maximum in a single operation.*/
  n = i2c_lld_get_txbytes(i2cp);
  if (n > 255U) {
 80036e8:	28ff      	cmp	r0, #255	; 0xff
    reload = 0U;
  }

  /* Configures the CR2 registers with both the calculated and static
     settings.*/
  dp->CR2 = (dp->CR2 & ~(I2C_CR2_NBYTES | I2C_CR2_RELOAD)) | i2cp->config->cr2 |
 80036ea:	f422 3280 	bic.w	r2, r2, #65536	; 0x10000
  if (n > 255U) {
    n = 255U;
    reload = I2C_CR2_RELOAD;
  }
  else {
    reload = 0U;
 80036ee:	bf94      	ite	ls
 80036f0:	2300      	movls	r3, #0

  /* The unit can transfer 255 bytes maximum in a single operation.*/
  n = i2c_lld_get_txbytes(i2cp);
  if (n > 255U) {
    n = 255U;
    reload = I2C_CR2_RELOAD;
 80036f2:	f04f 7380 	movhi.w	r3, #16777216	; 0x1000000
    reload = 0U;
  }

  /* Configures the CR2 registers with both the calculated and static
     settings.*/
  dp->CR2 = (dp->CR2 & ~(I2C_CR2_NBYTES | I2C_CR2_RELOAD)) | i2cp->config->cr2 |
 80036f6:	ea42 0201 	orr.w	r2, r2, r1
  size_t n;

  /* The unit can transfer 255 bytes maximum in a single operation.*/
  n = i2c_lld_get_txbytes(i2cp);
  if (n > 255U) {
    n = 255U;
 80036fa:	bf88      	it	hi
 80036fc:	20ff      	movhi	r0, #255	; 0xff
 80036fe:	4313      	orrs	r3, r2
  }

  /* Configures the CR2 registers with both the calculated and static
     settings.*/
  dp->CR2 = (dp->CR2 & ~(I2C_CR2_NBYTES | I2C_CR2_RELOAD)) | i2cp->config->cr2 |
            (n << 16U) | reload;
 8003700:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
    reload = 0U;
  }

  /* Configures the CR2 registers with both the calculated and static
     settings.*/
  dp->CR2 = (dp->CR2 & ~(I2C_CR2_NBYTES | I2C_CR2_RELOAD)) | i2cp->config->cr2 |
 8003704:	6063      	str	r3, [r4, #4]
 8003706:	bd10      	pop	{r4, pc}
 8003708:	20001bd8 	.word	0x20001bd8
 800370c:	00000000 	.word	0x00000000

08003710 <i2cMasterTransmitTimeout.constprop.17>:
 *                      be retrieved using @p i2cGetErrors().
 * @retval MSG_TIMEOUT  if a timeout occurred before operation end.
 *
 * @api
 */
msg_t i2cMasterTransmitTimeout(I2CDriver *i2cp,
 8003710:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 8003712:	2420      	movs	r4, #32
 8003714:	f384 8811 	msr	BASEPRI, r4
               (timeout != TIME_IMMEDIATE));

  osalDbgAssert(i2cp->state == I2C_READY, "not ready");

  osalSysLock();
  i2cp->errors = I2C_NO_ERROR;
 8003718:	4c2b      	ldr	r4, [pc, #172]	; (80037c8 <i2cMasterTransmitTimeout.constprop.17+0xb8>)
 800371a:	2600      	movs	r6, #0
  i2cp->state = I2C_ACTIVE_TX;
 800371c:	2503      	movs	r5, #3
 800371e:	7025      	strb	r5, [r4, #0]
               (timeout != TIME_IMMEDIATE));

  osalDbgAssert(i2cp->state == I2C_READY, "not ready");

  osalSysLock();
  i2cp->errors = I2C_NO_ERROR;
 8003720:	60a6      	str	r6, [r4, #8]
msg_t i2c_lld_master_transmit_timeout(I2CDriver *i2cp, i2caddr_t addr,
                                      const uint8_t *txbuf, size_t txbytes,
                                      uint8_t *rxbuf, size_t rxbytes,
                                      systime_t timeout) {
  msg_t msg;
  I2C_TypeDef *dp = i2cp->i2c;
 8003722:	6b25      	ldr	r5, [r4, #48]	; 0x30
 8003724:	f386 8811 	msr	BASEPRI, r6
  /* Releases the lock from high level driver.*/
  osalSysUnlock();

#if STM32_I2C_USE_DMA == TRUE
  /* TX DMA setup.*/
  dmaStreamSetMode(i2cp->dmatx, i2cp->txdmamode);
 8003728:	6ae6      	ldr	r6, [r4, #44]	; 0x2c
 800372a:	6a67      	ldr	r7, [r4, #36]	; 0x24
 800372c:	6836      	ldr	r6, [r6, #0]
 800372e:	6037      	str	r7, [r6, #0]
  dmaStreamSetMemory0(i2cp->dmatx, txbuf);
 8003730:	60f1      	str	r1, [r6, #12]
  dmaStreamSetTransactionSize(i2cp->dmatx, txbytes);
 8003732:	6072      	str	r2, [r6, #4]

  /* RX DMA setup, note, rxbytes can be zero but we write the value anyway.*/
  dmaStreamSetMode(i2cp->dmarx, i2cp->rxdmamode);
 8003734:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 8003736:	6a21      	ldr	r1, [r4, #32]
 8003738:	6812      	ldr	r2, [r2, #0]
 * @xclass
 */
static inline systime_t chVTGetSystemTimeX(void) {

#if CH_CFG_ST_TIMEDELTA == 0
  return ch.vtlist.vt_systime;
 800373a:	4e24      	ldr	r6, [pc, #144]	; (80037cc <i2cMasterTransmitTimeout.constprop.17+0xbc>)
 800373c:	6011      	str	r1, [r2, #0]
  dmaStreamSetMemory0(i2cp->dmarx, rxbuf);
 800373e:	60d3      	str	r3, [r2, #12]
  dmaStreamSetTransactionSize(i2cp->dmarx, rxbytes);
 8003740:	9b06      	ldr	r3, [sp, #24]
 8003742:	6053      	str	r3, [r2, #4]
 8003744:	6ab2      	ldr	r2, [r6, #40]	; 0x28
 8003746:	2320      	movs	r3, #32
 8003748:	f383 8811 	msr	BASEPRI, r3
  while (true) {
    osalSysLock();

    /* If the bus is not busy then the operation can continue, note, the
       loop is exited in the locked state.*/
    if ((dp->ISR & I2C_ISR_BUSY) == 0)
 800374c:	69ab      	ldr	r3, [r5, #24]
 800374e:	0419      	lsls	r1, r3, #16
 8003750:	d508      	bpl.n	8003764 <i2cMasterTransmitTimeout.constprop.17+0x54>
 8003752:	6ab3      	ldr	r3, [r6, #40]	; 0x28
 */
static inline bool chVTIsTimeWithinX(systime_t time,
                                     systime_t start,
                                     systime_t end) {

  return (bool)((systime_t)(time - start) < (systime_t)(end - start));
 8003754:	1a9b      	subs	r3, r3, r2
      break;

    /* If the system time went outside the allowed window then a timeout
       condition is returned.*/
    if (!osalOsIsTimeWithinX(osalOsGetSystemTimeX(), start, end)) {
 8003756:	f5b3 7ffa 	cmp.w	r3, #500	; 0x1f4
 800375a:	d22a      	bcs.n	80037b2 <i2cMasterTransmitTimeout.constprop.17+0xa2>
 800375c:	2300      	movs	r3, #0
 800375e:	f383 8811 	msr	BASEPRI, r3
 8003762:	e7f0      	b.n	8003746 <i2cMasterTransmitTimeout.constprop.17+0x36>
 */
static void i2c_lld_set_address(I2CDriver *i2cp, i2caddr_t addr) {
  I2C_TypeDef *dp = i2cp->i2c;

  /* Address alignment depends on the addressing mode selected.*/
  if ((i2cp->config->cr2 & I2C_CR2_ADD10) == 0U)
 8003764:	6862      	ldr	r2, [r4, #4]
 * @param[in] addr      slave device address
 *
 * @notapi
 */
static void i2c_lld_set_address(I2CDriver *i2cp, i2caddr_t addr) {
  I2C_TypeDef *dp = i2cp->i2c;
 8003766:	6b23      	ldr	r3, [r4, #48]	; 0x30

  /* Address alignment depends on the addressing mode selected.*/
  if ((i2cp->config->cr2 & I2C_CR2_ADD10) == 0U)
 8003768:	6892      	ldr	r2, [r2, #8]
  /* Preparing the transfer.*/
  i2c_lld_setup_tx_transfer(i2cp);

#if STM32_I2C_USE_DMA == TRUE
  /* Enabling TX DMA.*/
  dmaStreamEnable(i2cp->dmatx);
 800376a:	4f17      	ldr	r7, [pc, #92]	; (80037c8 <i2cMasterTransmitTimeout.constprop.17+0xb8>)
 */
static void i2c_lld_set_address(I2CDriver *i2cp, i2caddr_t addr) {
  I2C_TypeDef *dp = i2cp->i2c;

  /* Address alignment depends on the addressing mode selected.*/
  if ((i2cp->config->cr2 & I2C_CR2_ADD10) == 0U)
 800376c:	0512      	lsls	r2, r2, #20
    dp->CR2 = (uint32_t)addr << 1U;
 800376e:	bf58      	it	pl
 8003770:	0040      	lslpl	r0, r0, #1
  else
    dp->CR2 = (uint32_t)addr;
 8003772:	6058      	str	r0, [r3, #4]

  /* Setting up the slave address.*/
  i2c_lld_set_address(i2cp, addr);

  /* Preparing the transfer.*/
  i2c_lld_setup_tx_transfer(i2cp);
 8003774:	f7ff ffac 	bl	80036d0 <i2c_lld_setup_tx_transfer.constprop.20>

#if STM32_I2C_USE_DMA == TRUE
  /* Enabling TX DMA.*/
  dmaStreamEnable(i2cp->dmatx);
 8003778:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
 800377a:	681a      	ldr	r2, [r3, #0]
 800377c:	6813      	ldr	r3, [r2, #0]
 800377e:	f043 0301 	orr.w	r3, r3, #1
 8003782:	6013      	str	r3, [r2, #0]

  /* Transfer complete interrupt enabled.*/
  dp->CR1 |= I2C_CR1_TCIE;
 8003784:	682b      	ldr	r3, [r5, #0]
 8003786:	f043 0340 	orr.w	r3, r3, #64	; 0x40
 800378a:	602b      	str	r3, [r5, #0]
  /* Transfer complete and TX interrupts enabled.*/
  dp->CR1 |= I2C_CR1_TCIE | I2C_CR1_TXIE;
#endif

  /* Starts the operation.*/
  dp->CR2 |= I2C_CR2_START;
 800378c:	686b      	ldr	r3, [r5, #4]
 800378e:	f443 5300 	orr.w	r3, r3, #8192	; 0x2000
 8003792:	606b      	str	r3, [r5, #4]
 8003794:	69b3      	ldr	r3, [r6, #24]

  if (TIME_IMMEDIATE == timeout) {
    return MSG_TIMEOUT;
  }

  *trp = tp;
 8003796:	61e3      	str	r3, [r4, #28]
  tp->p_u.wttrp = trp;
 8003798:	f107 021c 	add.w	r2, r7, #28
 800379c:	621a      	str	r2, [r3, #32]

  return chSchGoSleepTimeoutS(CH_STATE_SUSPENDED, timeout);
 800379e:	2003      	movs	r0, #3
 80037a0:	2128      	movs	r1, #40	; 0x28
 80037a2:	f7fd fa45 	bl	8000c30 <chSchGoSleepTimeoutS>
  /* Waits for the operation completion or a timeout.*/
  msg = osalThreadSuspendTimeoutS(&i2cp->thread, timeout);

  /* In case of a software timeout a STOP is sent as an extreme attempt
     to release the bus.*/
  if (msg == MSG_TIMEOUT) {
 80037a6:	1c43      	adds	r3, r0, #1
 80037a8:	d108      	bne.n	80037bc <i2cMasterTransmitTimeout.constprop.17+0xac>
    dp->CR2 |= I2C_CR2_STOP;
 80037aa:	686b      	ldr	r3, [r5, #4]
 80037ac:	f443 4380 	orr.w	r3, r3, #16384	; 0x4000
 80037b0:	606b      	str	r3, [r5, #4]
  i2cp->state = I2C_ACTIVE_TX;
  rdymsg = i2c_lld_master_transmit_timeout(i2cp, addr, txbuf, txbytes,
                                           rxbuf, rxbytes, timeout);
  if (rdymsg == MSG_TIMEOUT) {
    i2cp->state = I2C_LOCKED;
 80037b2:	2305      	movs	r3, #5
 80037b4:	7023      	strb	r3, [r4, #0]
 80037b6:	f04f 30ff 	mov.w	r0, #4294967295	; 0xffffffff
 80037ba:	e001      	b.n	80037c0 <i2cMasterTransmitTimeout.constprop.17+0xb0>
  }
  else {
    i2cp->state = I2C_READY;
 80037bc:	2302      	movs	r3, #2
 80037be:	703b      	strb	r3, [r7, #0]
 80037c0:	2300      	movs	r3, #0
 80037c2:	f383 8811 	msr	BASEPRI, r3
  }
  osalSysUnlock();
  return rdymsg;
}
 80037c6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80037c8:	20001bd8 	.word	0x20001bd8
 80037cc:	20001a00 	.word	0x20001a00

080037d0 <i2c_lld_setup_rx_transfer.constprop.16>:
 * @param[in] i2cp      pointer to the @p I2CDriver object
 *
 * @notapi
 */
static void i2c_lld_setup_rx_transfer(I2CDriver *i2cp) {
  I2C_TypeDef *dp = i2cp->i2c;
 80037d0:	4a0e      	ldr	r2, [pc, #56]	; (800380c <i2c_lld_setup_rx_transfer.constprop.16+0x3c>)
  uint32_t reload;
  size_t n;

  /* The unit can transfer 255 bytes maximum in a single operation.*/
  n = i2c_lld_get_rxbytes(i2cp);
 80037d2:	6a93      	ldr	r3, [r2, #40]	; 0x28
 80037d4:	4610      	mov	r0, r2
 80037d6:	681b      	ldr	r3, [r3, #0]
 *
 * @param[in] i2cp      pointer to the @p I2CDriver object
 *
 * @notapi
 */
static void i2c_lld_setup_rx_transfer(I2CDriver *i2cp) {
 80037d8:	b530      	push	{r4, r5, lr}
  I2C_TypeDef *dp = i2cp->i2c;
  uint32_t reload;
  size_t n;

  /* The unit can transfer 255 bytes maximum in a single operation.*/
  n = i2c_lld_get_rxbytes(i2cp);
 80037da:	685c      	ldr	r4, [r3, #4]
 * @param[in] i2cp      pointer to the @p I2CDriver object
 *
 * @notapi
 */
static void i2c_lld_setup_rx_transfer(I2CDriver *i2cp) {
  I2C_TypeDef *dp = i2cp->i2c;
 80037dc:	6b15      	ldr	r5, [r2, #48]	; 0x30
    reload = 0U;
  }

  /* Configures the CR2 registers with both the calculated and static
     settings.*/
  dp->CR2 = (dp->CR2 & ~(I2C_CR2_NBYTES | I2C_CR2_RELOAD)) | i2cp->config->cr2 |
 80037de:	6843      	ldr	r3, [r0, #4]
 80037e0:	686a      	ldr	r2, [r5, #4]
 80037e2:	689b      	ldr	r3, [r3, #8]
 80037e4:	f443 6080 	orr.w	r0, r3, #1024	; 0x400
 80037e8:	f022 73ff 	bic.w	r3, r2, #33423360	; 0x1fe0000
  uint32_t reload;
  size_t n;

  /* The unit can transfer 255 bytes maximum in a single operation.*/
  n = i2c_lld_get_rxbytes(i2cp);
  if (n > 255U) {
 80037ec:	2cff      	cmp	r4, #255	; 0xff
    reload = 0U;
  }

  /* Configures the CR2 registers with both the calculated and static
     settings.*/
  dp->CR2 = (dp->CR2 & ~(I2C_CR2_NBYTES | I2C_CR2_RELOAD)) | i2cp->config->cr2 |
 80037ee:	f423 3380 	bic.w	r3, r3, #65536	; 0x10000
  if (n > 255U) {
    n = 255U;
    reload = I2C_CR2_RELOAD;
  }
  else {
    reload = 0U;
 80037f2:	bf94      	ite	ls
 80037f4:	2100      	movls	r1, #0

  /* The unit can transfer 255 bytes maximum in a single operation.*/
  n = i2c_lld_get_rxbytes(i2cp);
  if (n > 255U) {
    n = 255U;
    reload = I2C_CR2_RELOAD;
 80037f6:	f04f 7180 	movhi.w	r1, #16777216	; 0x1000000
 80037fa:	ea43 0300 	orr.w	r3, r3, r0
  size_t n;

  /* The unit can transfer 255 bytes maximum in a single operation.*/
  n = i2c_lld_get_rxbytes(i2cp);
  if (n > 255U) {
    n = 255U;
 80037fe:	bf88      	it	hi
 8003800:	24ff      	movhi	r4, #255	; 0xff
 8003802:	430b      	orrs	r3, r1
  }

  /* Configures the CR2 registers with both the calculated and static
     settings.*/
  dp->CR2 = (dp->CR2 & ~(I2C_CR2_NBYTES | I2C_CR2_RELOAD)) | i2cp->config->cr2 |
            I2C_CR2_RD_WRN | (n << 16U) | reload;
 8003804:	ea43 4304 	orr.w	r3, r3, r4, lsl #16
    reload = 0U;
  }

  /* Configures the CR2 registers with both the calculated and static
     settings.*/
  dp->CR2 = (dp->CR2 & ~(I2C_CR2_NBYTES | I2C_CR2_RELOAD)) | i2cp->config->cr2 |
 8003808:	606b      	str	r3, [r5, #4]
 800380a:	bd30      	pop	{r4, r5, pc}
 800380c:	20001bd8 	.word	0x20001bd8

08003810 <_pal_lld_setgroupmode.constprop.9>:
 * @param[in] mode      the mode
 *
 * @notapi
 */
#if 1
void _pal_lld_setgroupmode(ioportid_t port,
 8003810:	b570      	push	{r4, r5, r6, lr}
  uint32_t moder   = (mode & PAL_STM32_MODE_MASK) >> 0;
  uint32_t otyper  = (mode & PAL_STM32_OTYPE_MASK) >> 2;
  uint32_t ospeedr = (mode & PAL_STM32_OSPEED_MASK) >> 3;
  uint32_t pupdr   = (mode & PAL_STM32_PUDR_MASK) >> 5;
  uint32_t altr    = (mode & PAL_STM32_ALTERNATE_MASK) >> 7;
  uint32_t bit     = 0;
 8003812:	2100      	movs	r1, #0
#if 1
void _pal_lld_setgroupmode(ioportid_t port,
                           ioportmask_t mask,
                           iomode_t mode) {

  uint32_t moder   = (mode & PAL_STM32_MODE_MASK) >> 0;
 8003814:	2402      	movs	r4, #2
  uint32_t ospeedr = (mode & PAL_STM32_OSPEED_MASK) >> 3;
  uint32_t pupdr   = (mode & PAL_STM32_PUDR_MASK) >> 5;
  uint32_t altr    = (mode & PAL_STM32_ALTERNATE_MASK) >> 7;
  uint32_t bit     = 0;
  while (TRUE) {
    if ((mask & 1) != 0) {
 8003816:	07c3      	lsls	r3, r0, #31
 8003818:	d52c      	bpl.n	8003874 <_pal_lld_setgroupmode.constprop.9+0x64>
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
 800381a:	f001 0507 	and.w	r5, r1, #7
 800381e:	00ad      	lsls	r5, r5, #2
 8003820:	2307      	movs	r3, #7
      m4 = 15 << ((bit & 7) * 4);
 8003822:	220f      	movs	r2, #15
  uint32_t bit     = 0;
  while (TRUE) {
    if ((mask & 1) != 0) {
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
 8003824:	40ab      	lsls	r3, r5
      m4 = 15 << ((bit & 7) * 4);
 8003826:	40aa      	lsls	r2, r5
 8003828:	f04f 4590 	mov.w	r5, #1207959552	; 0x48000000
      if (bit < 8)
 800382c:	2907      	cmp	r1, #7
        port->AFRL = (port->AFRL & ~m4) | altrmask;
 800382e:	bf94      	ite	ls
 8003830:	6a2e      	ldrls	r6, [r5, #32]
      else
        port->AFRH = (port->AFRH & ~m4) | altrmask;
 8003832:	6a6e      	ldrhi	r6, [r5, #36]	; 0x24
 8003834:	ea6f 0202 	mvn.w	r2, r2
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
      m4 = 15 << ((bit & 7) * 4);
      if (bit < 8)
        port->AFRL = (port->AFRL & ~m4) | altrmask;
 8003838:	bf95      	itete	ls
 800383a:	4032      	andls	r2, r6
      else
        port->AFRH = (port->AFRH & ~m4) | altrmask;
 800383c:	4032      	andhi	r2, r6
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
      m4 = 15 << ((bit & 7) * 4);
      if (bit < 8)
        port->AFRL = (port->AFRL & ~m4) | altrmask;
 800383e:	4313      	orrls	r3, r2
      else
        port->AFRH = (port->AFRH & ~m4) | altrmask;
 8003840:	4313      	orrhi	r3, r2
      uint32_t altrmask, m1, m2, m4;

      altrmask = altr << ((bit & 7) * 4);
      m4 = 15 << ((bit & 7) * 4);
      if (bit < 8)
        port->AFRL = (port->AFRL & ~m4) | altrmask;
 8003842:	bf94      	ite	ls
 8003844:	622b      	strls	r3, [r5, #32]
      else
        port->AFRH = (port->AFRH & ~m4) | altrmask;
 8003846:	626b      	strhi	r3, [r5, #36]	; 0x24
      m1 = 1 << bit;
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
 8003848:	f04f 4390 	mov.w	r3, #1207959552	; 0x48000000
      m4 = 15 << ((bit & 7) * 4);
      if (bit < 8)
        port->AFRL = (port->AFRL & ~m4) | altrmask;
      else
        port->AFRH = (port->AFRH & ~m4) | altrmask;
      m1 = 1 << bit;
 800384c:	2201      	movs	r2, #1
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
 800384e:	685d      	ldr	r5, [r3, #4]
      m4 = 15 << ((bit & 7) * 4);
      if (bit < 8)
        port->AFRL = (port->AFRL & ~m4) | altrmask;
      else
        port->AFRH = (port->AFRH & ~m4) | altrmask;
      m1 = 1 << bit;
 8003850:	408a      	lsls	r2, r1
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
 8003852:	ea25 0202 	bic.w	r2, r5, r2
 8003856:	605a      	str	r2, [r3, #4]
 8003858:	004e      	lsls	r6, r1, #1
      m2 = 3 << (bit * 2);
 800385a:	2203      	movs	r2, #3
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
 800385c:	689d      	ldr	r5, [r3, #8]
        port->AFRL = (port->AFRL & ~m4) | altrmask;
      else
        port->AFRH = (port->AFRH & ~m4) | altrmask;
      m1 = 1 << bit;
      port->OTYPER  = (port->OTYPER & ~m1) | otyper;
      m2 = 3 << (bit * 2);
 800385e:	40b2      	lsls	r2, r6
      port->OSPEEDR = (port->OSPEEDR & ~m2) | ospeedr;
 8003860:	43d2      	mvns	r2, r2
 8003862:	4015      	ands	r5, r2
 8003864:	609d      	str	r5, [r3, #8]
      port->PUPDR   = (port->PUPDR & ~m2) | pupdr;
 8003866:	68dd      	ldr	r5, [r3, #12]
 8003868:	4015      	ands	r5, r2
 800386a:	60dd      	str	r5, [r3, #12]
      port->MODER   = (port->MODER & ~m2) | moder;
 800386c:	681d      	ldr	r5, [r3, #0]
 800386e:	402a      	ands	r2, r5
 8003870:	4322      	orrs	r2, r4
 8003872:	601a      	str	r2, [r3, #0]
    }
    mask >>= 1;
    if (!mask)
 8003874:	0840      	lsrs	r0, r0, #1
 8003876:	d002      	beq.n	800387e <_pal_lld_setgroupmode.constprop.9+0x6e>
      return;
    otyper <<= 1;
    ospeedr <<= 2;
    pupdr <<= 2;
    moder <<= 2;
 8003878:	00a4      	lsls	r4, r4, #2
    bit++;
 800387a:	3101      	adds	r1, #1
 800387c:	e7cb      	b.n	8003816 <_pal_lld_setgroupmode.constprop.9+0x6>
 800387e:	bd70      	pop	{r4, r5, r6, pc}

08003880 <long_to_string_with_divisor.constprop.5>:
#include "memstreams.h"

#define MAX_FILLER 11
#define FLOAT_PRECISION 9

static char *long_to_string_with_divisor(char *p,
 8003880:	b5f0      	push	{r4, r5, r6, r7, lr}
    ll = num;
  } else {
    ll = divisor;
  }

  q = p + MAX_FILLER;
 8003882:	f100 040b 	add.w	r4, r0, #11
 8003886:	460d      	mov	r5, r1
 8003888:	4623      	mov	r3, r4
  do {
    i = (int)(l % radix);
 800388a:	fbb1 f7f2 	udiv	r7, r1, r2
 800388e:	fb02 1117 	mls	r1, r2, r7, r1
    i += '0';
 8003892:	f101 0630 	add.w	r6, r1, #48	; 0x30
    if (i > '9')
 8003896:	2e39      	cmp	r6, #57	; 0x39
      i += 'A' - '0' - 10;
 8003898:	bfc8      	it	gt
 800389a:	f101 0637 	addgt.w	r6, r1, #55	; 0x37
    *--q = i;
 800389e:	f803 6d01 	strb.w	r6, [r3, #-1]!
    l /= radix;
  } while ((ll /= radix) != 0);
 80038a2:	fbb5 f5f2 	udiv	r5, r5, r2
    i = (int)(l % radix);
    i += '0';
    if (i > '9')
      i += 'A' - '0' - 10;
    *--q = i;
    l /= radix;
 80038a6:	4639      	mov	r1, r7
  } while ((ll /= radix) != 0);
 80038a8:	2d00      	cmp	r5, #0
 80038aa:	d1ee      	bne.n	800388a <long_to_string_with_divisor.constprop.5+0xa>
 80038ac:	1e42      	subs	r2, r0, #1

  i = (int)(p + MAX_FILLER - q);
 80038ae:	1ae1      	subs	r1, r4, r3
  do
    *p++ = *q++;
 80038b0:	f813 5b01 	ldrb.w	r5, [r3], #1
 80038b4:	f802 5f01 	strb.w	r5, [r2, #1]!
  while (--i);
 80038b8:	42a3      	cmp	r3, r4
 80038ba:	d1f9      	bne.n	80038b0 <long_to_string_with_divisor.constprop.5+0x30>

  return p;
}
 80038bc:	4408      	add	r0, r1
 80038be:	bdf0      	pop	{r4, r5, r6, r7, pc}

080038c0 <_strtok.constprop.3>:
/**
 * @brief   Shell termination event source.
 */
event_source_t shell_terminated;

static char *_strtok(char *str, const char *delim, char **saveptr) {
 80038c0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80038c2:	460e      	mov	r6, r1
  char *token;
  if (str)
 80038c4:	b100      	cbz	r0, 80038c8 <_strtok.constprop.3+0x8>
    *saveptr = str;
 80038c6:	6008      	str	r0, [r1, #0]
  token = *saveptr;
 80038c8:	6835      	ldr	r5, [r6, #0]

  if (!token)
 80038ca:	b90d      	cbnz	r5, 80038d0 <_strtok.constprop.3+0x10>
    return NULL;
 80038cc:	2000      	movs	r0, #0
 80038ce:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

  token += strspn(token, delim);
 80038d0:	490a      	ldr	r1, [pc, #40]	; (80038fc <_strtok.constprop.3+0x3c>)
 80038d2:	4628      	mov	r0, r5
 80038d4:	f000 f984 	bl	8003be0 <strspn>
 80038d8:	182c      	adds	r4, r5, r0
 80038da:	4607      	mov	r7, r0
  *saveptr = strpbrk(token, delim);
 80038dc:	4907      	ldr	r1, [pc, #28]	; (80038fc <_strtok.constprop.3+0x3c>)
 80038de:	4620      	mov	r0, r4
 80038e0:	f000 f956 	bl	8003b90 <strpbrk>
  if (*saveptr)
 80038e4:	b908      	cbnz	r0, 80038ea <_strtok.constprop.3+0x2a>

  if (!token)
    return NULL;

  token += strspn(token, delim);
  *saveptr = strpbrk(token, delim);
 80038e6:	6030      	str	r0, [r6, #0]
 80038e8:	e003      	b.n	80038f2 <_strtok.constprop.3+0x32>
  if (*saveptr)
    *(*saveptr)++ = '\0';
 80038ea:	1c43      	adds	r3, r0, #1
 80038ec:	6033      	str	r3, [r6, #0]
 80038ee:	2300      	movs	r3, #0
 80038f0:	7003      	strb	r3, [r0, #0]

  return *token ? token : NULL;
 80038f2:	5deb      	ldrb	r3, [r5, r7]
 80038f4:	2b00      	cmp	r3, #0
 80038f6:	d0e9      	beq.n	80038cc <_strtok.constprop.3+0xc>
 80038f8:	4620      	mov	r0, r4
}
 80038fa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80038fc:	08004620 	.word	0x08004620

08003900 <_strtol_r>:
 8003900:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 8003904:	4c44      	ldr	r4, [pc, #272]	; (8003a18 <_strtol_r+0x118>)
 8003906:	4683      	mov	fp, r0
 8003908:	460e      	mov	r6, r1
 800390a:	f8d4 e000 	ldr.w	lr, [r4]
 800390e:	e000      	b.n	8003912 <_strtol_r+0x12>
 8003910:	4626      	mov	r6, r4
 8003912:	4634      	mov	r4, r6
 8003914:	f814 5b01 	ldrb.w	r5, [r4], #1
 8003918:	eb0e 0005 	add.w	r0, lr, r5
 800391c:	7840      	ldrb	r0, [r0, #1]
 800391e:	f000 0008 	and.w	r0, r0, #8
 8003922:	f000 08ff 	and.w	r8, r0, #255	; 0xff
 8003926:	2800      	cmp	r0, #0
 8003928:	d1f2      	bne.n	8003910 <_strtol_r+0x10>
 800392a:	2d2d      	cmp	r5, #45	; 0x2d
 800392c:	d04b      	beq.n	80039c6 <_strtol_r+0xc6>
 800392e:	2d2b      	cmp	r5, #43	; 0x2b
 8003930:	bf04      	itt	eq
 8003932:	7875      	ldrbeq	r5, [r6, #1]
 8003934:	1cb4      	addeq	r4, r6, #2
 8003936:	b11b      	cbz	r3, 8003940 <_strtol_r+0x40>
 8003938:	2b10      	cmp	r3, #16
 800393a:	d060      	beq.n	80039fe <_strtol_r+0xfe>
 800393c:	469a      	mov	sl, r3
 800393e:	e003      	b.n	8003948 <_strtol_r+0x48>
 8003940:	2d30      	cmp	r5, #48	; 0x30
 8003942:	d054      	beq.n	80039ee <_strtol_r+0xee>
 8003944:	230a      	movs	r3, #10
 8003946:	469a      	mov	sl, r3
 8003948:	f1b8 0f00 	cmp.w	r8, #0
 800394c:	bf14      	ite	ne
 800394e:	f04f 4000 	movne.w	r0, #2147483648	; 0x80000000
 8003952:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
 8003956:	2700      	movs	r7, #0
 8003958:	fbb0 f9fa 	udiv	r9, r0, sl
 800395c:	46bc      	mov	ip, r7
 800395e:	fb0a 0019 	mls	r0, sl, r9, r0
 8003962:	e00c      	b.n	800397e <_strtol_r+0x7e>
 8003964:	3d30      	subs	r5, #48	; 0x30
 8003966:	42ab      	cmp	r3, r5
 8003968:	dd19      	ble.n	800399e <_strtol_r+0x9e>
 800396a:	1c7e      	adds	r6, r7, #1
 800396c:	d005      	beq.n	800397a <_strtol_r+0x7a>
 800396e:	45cc      	cmp	ip, r9
 8003970:	d824      	bhi.n	80039bc <_strtol_r+0xbc>
 8003972:	d021      	beq.n	80039b8 <_strtol_r+0xb8>
 8003974:	fb0a 5c0c 	mla	ip, sl, ip, r5
 8003978:	2701      	movs	r7, #1
 800397a:	f814 5b01 	ldrb.w	r5, [r4], #1
 800397e:	eb0e 0605 	add.w	r6, lr, r5
 8003982:	7876      	ldrb	r6, [r6, #1]
 8003984:	f016 0f04 	tst.w	r6, #4
 8003988:	d1ec      	bne.n	8003964 <_strtol_r+0x64>
 800398a:	f016 0603 	ands.w	r6, r6, #3
 800398e:	d006      	beq.n	800399e <_strtol_r+0x9e>
 8003990:	2e01      	cmp	r6, #1
 8003992:	bf0c      	ite	eq
 8003994:	2637      	moveq	r6, #55	; 0x37
 8003996:	2657      	movne	r6, #87	; 0x57
 8003998:	1bad      	subs	r5, r5, r6
 800399a:	42ab      	cmp	r3, r5
 800399c:	dce5      	bgt.n	800396a <_strtol_r+0x6a>
 800399e:	1c7b      	adds	r3, r7, #1
 80039a0:	d016      	beq.n	80039d0 <_strtol_r+0xd0>
 80039a2:	f1c8 0000 	rsb	r0, r8, #0
 80039a6:	ea8c 0000 	eor.w	r0, ip, r0
 80039aa:	4440      	add	r0, r8
 80039ac:	b14a      	cbz	r2, 80039c2 <_strtol_r+0xc2>
 80039ae:	b107      	cbz	r7, 80039b2 <_strtol_r+0xb2>
 80039b0:	1e61      	subs	r1, r4, #1
 80039b2:	6011      	str	r1, [r2, #0]
 80039b4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80039b8:	4285      	cmp	r5, r0
 80039ba:	dddb      	ble.n	8003974 <_strtol_r+0x74>
 80039bc:	f04f 37ff 	mov.w	r7, #4294967295	; 0xffffffff
 80039c0:	e7db      	b.n	800397a <_strtol_r+0x7a>
 80039c2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80039c6:	1cb4      	adds	r4, r6, #2
 80039c8:	7875      	ldrb	r5, [r6, #1]
 80039ca:	f04f 0801 	mov.w	r8, #1
 80039ce:	e7b2      	b.n	8003936 <_strtol_r+0x36>
 80039d0:	f1b8 0f00 	cmp.w	r8, #0
 80039d4:	f04f 0322 	mov.w	r3, #34	; 0x22
 80039d8:	bf14      	ite	ne
 80039da:	f04f 4000 	movne.w	r0, #2147483648	; 0x80000000
 80039de:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
 80039e2:	f8cb 3000 	str.w	r3, [fp]
 80039e6:	2a00      	cmp	r2, #0
 80039e8:	d1e2      	bne.n	80039b0 <_strtol_r+0xb0>
 80039ea:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80039ee:	7823      	ldrb	r3, [r4, #0]
 80039f0:	f003 03df 	and.w	r3, r3, #223	; 0xdf
 80039f4:	2b58      	cmp	r3, #88	; 0x58
 80039f6:	d009      	beq.n	8003a0c <_strtol_r+0x10c>
 80039f8:	2308      	movs	r3, #8
 80039fa:	469a      	mov	sl, r3
 80039fc:	e7a4      	b.n	8003948 <_strtol_r+0x48>
 80039fe:	2d30      	cmp	r5, #48	; 0x30
 8003a00:	d19c      	bne.n	800393c <_strtol_r+0x3c>
 8003a02:	7820      	ldrb	r0, [r4, #0]
 8003a04:	f000 00df 	and.w	r0, r0, #223	; 0xdf
 8003a08:	2858      	cmp	r0, #88	; 0x58
 8003a0a:	d197      	bne.n	800393c <_strtol_r+0x3c>
 8003a0c:	f04f 0a10 	mov.w	sl, #16
 8003a10:	7865      	ldrb	r5, [r4, #1]
 8003a12:	4653      	mov	r3, sl
 8003a14:	3402      	adds	r4, #2
 8003a16:	e797      	b.n	8003948 <_strtol_r+0x48>
 8003a18:	2000081c 	.word	0x2000081c
 8003a1c:	00000000 	.word	0x00000000

08003a20 <strtol>:
 8003a20:	b430      	push	{r4, r5}
 8003a22:	4c04      	ldr	r4, [pc, #16]	; (8003a34 <strtol+0x14>)
 8003a24:	460d      	mov	r5, r1
 8003a26:	4613      	mov	r3, r2
 8003a28:	4601      	mov	r1, r0
 8003a2a:	462a      	mov	r2, r5
 8003a2c:	6820      	ldr	r0, [r4, #0]
 8003a2e:	bc30      	pop	{r4, r5}
 8003a30:	f7ff bf66 	b.w	8003900 <_strtol_r>
 8003a34:	20000c48 	.word	0x20000c48
	...

08003a40 <memset>:
 8003a40:	b470      	push	{r4, r5, r6}
 8003a42:	0784      	lsls	r4, r0, #30
 8003a44:	d046      	beq.n	8003ad4 <memset+0x94>
 8003a46:	1e54      	subs	r4, r2, #1
 8003a48:	2a00      	cmp	r2, #0
 8003a4a:	d041      	beq.n	8003ad0 <memset+0x90>
 8003a4c:	b2cd      	uxtb	r5, r1
 8003a4e:	4603      	mov	r3, r0
 8003a50:	e002      	b.n	8003a58 <memset+0x18>
 8003a52:	1e62      	subs	r2, r4, #1
 8003a54:	b3e4      	cbz	r4, 8003ad0 <memset+0x90>
 8003a56:	4614      	mov	r4, r2
 8003a58:	f803 5b01 	strb.w	r5, [r3], #1
 8003a5c:	079a      	lsls	r2, r3, #30
 8003a5e:	d1f8      	bne.n	8003a52 <memset+0x12>
 8003a60:	2c03      	cmp	r4, #3
 8003a62:	d92e      	bls.n	8003ac2 <memset+0x82>
 8003a64:	b2cd      	uxtb	r5, r1
 8003a66:	ea45 2505 	orr.w	r5, r5, r5, lsl #8
 8003a6a:	2c0f      	cmp	r4, #15
 8003a6c:	ea45 4505 	orr.w	r5, r5, r5, lsl #16
 8003a70:	d919      	bls.n	8003aa6 <memset+0x66>
 8003a72:	f103 0210 	add.w	r2, r3, #16
 8003a76:	4626      	mov	r6, r4
 8003a78:	3e10      	subs	r6, #16
 8003a7a:	2e0f      	cmp	r6, #15
 8003a7c:	f842 5c10 	str.w	r5, [r2, #-16]
 8003a80:	f842 5c0c 	str.w	r5, [r2, #-12]
 8003a84:	f842 5c08 	str.w	r5, [r2, #-8]
 8003a88:	f842 5c04 	str.w	r5, [r2, #-4]
 8003a8c:	f102 0210 	add.w	r2, r2, #16
 8003a90:	d8f2      	bhi.n	8003a78 <memset+0x38>
 8003a92:	f1a4 0210 	sub.w	r2, r4, #16
 8003a96:	f022 020f 	bic.w	r2, r2, #15
 8003a9a:	f004 040f 	and.w	r4, r4, #15
 8003a9e:	3210      	adds	r2, #16
 8003aa0:	2c03      	cmp	r4, #3
 8003aa2:	4413      	add	r3, r2
 8003aa4:	d90d      	bls.n	8003ac2 <memset+0x82>
 8003aa6:	461e      	mov	r6, r3
 8003aa8:	4622      	mov	r2, r4
 8003aaa:	3a04      	subs	r2, #4
 8003aac:	2a03      	cmp	r2, #3
 8003aae:	f846 5b04 	str.w	r5, [r6], #4
 8003ab2:	d8fa      	bhi.n	8003aaa <memset+0x6a>
 8003ab4:	1f22      	subs	r2, r4, #4
 8003ab6:	f022 0203 	bic.w	r2, r2, #3
 8003aba:	3204      	adds	r2, #4
 8003abc:	4413      	add	r3, r2
 8003abe:	f004 0403 	and.w	r4, r4, #3
 8003ac2:	b12c      	cbz	r4, 8003ad0 <memset+0x90>
 8003ac4:	b2c9      	uxtb	r1, r1
 8003ac6:	441c      	add	r4, r3
 8003ac8:	f803 1b01 	strb.w	r1, [r3], #1
 8003acc:	42a3      	cmp	r3, r4
 8003ace:	d1fb      	bne.n	8003ac8 <memset+0x88>
 8003ad0:	bc70      	pop	{r4, r5, r6}
 8003ad2:	4770      	bx	lr
 8003ad4:	4614      	mov	r4, r2
 8003ad6:	4603      	mov	r3, r0
 8003ad8:	e7c2      	b.n	8003a60 <memset+0x20>
 8003ada:	bf00      	nop
 8003adc:	0000      	movs	r0, r0
	...

08003ae0 <strcasecmp>:
 8003ae0:	4b0f      	ldr	r3, [pc, #60]	; (8003b20 <strcasecmp+0x40>)
 8003ae2:	b430      	push	{r4, r5}
 8003ae4:	681d      	ldr	r5, [r3, #0]
 8003ae6:	e002      	b.n	8003aee <strcasecmp+0xe>
 8003ae8:	1ad2      	subs	r2, r2, r3
 8003aea:	d116      	bne.n	8003b1a <strcasecmp+0x3a>
 8003aec:	b1ab      	cbz	r3, 8003b1a <strcasecmp+0x3a>
 8003aee:	f810 4b01 	ldrb.w	r4, [r0], #1
 8003af2:	192b      	adds	r3, r5, r4
 8003af4:	4622      	mov	r2, r4
 8003af6:	785b      	ldrb	r3, [r3, #1]
 8003af8:	f003 0303 	and.w	r3, r3, #3
 8003afc:	2b01      	cmp	r3, #1
 8003afe:	f811 3b01 	ldrb.w	r3, [r1], #1
 8003b02:	bf08      	it	eq
 8003b04:	f104 0220 	addeq.w	r2, r4, #32
 8003b08:	18ec      	adds	r4, r5, r3
 8003b0a:	7864      	ldrb	r4, [r4, #1]
 8003b0c:	f004 0403 	and.w	r4, r4, #3
 8003b10:	2c01      	cmp	r4, #1
 8003b12:	d1e9      	bne.n	8003ae8 <strcasecmp+0x8>
 8003b14:	3320      	adds	r3, #32
 8003b16:	1ad2      	subs	r2, r2, r3
 8003b18:	d0e9      	beq.n	8003aee <strcasecmp+0xe>
 8003b1a:	4610      	mov	r0, r2
 8003b1c:	bc30      	pop	{r4, r5}
 8003b1e:	4770      	bx	lr
 8003b20:	2000081c 	.word	0x2000081c
	...

08003b30 <strlen>:
 8003b30:	f020 0103 	bic.w	r1, r0, #3
 8003b34:	f010 0003 	ands.w	r0, r0, #3
 8003b38:	f1c0 0000 	rsb	r0, r0, #0
 8003b3c:	f851 3b04 	ldr.w	r3, [r1], #4
 8003b40:	f100 0c04 	add.w	ip, r0, #4
 8003b44:	ea4f 0ccc 	mov.w	ip, ip, lsl #3
 8003b48:	f06f 0200 	mvn.w	r2, #0
 8003b4c:	bf1c      	itt	ne
 8003b4e:	fa22 f20c 	lsrne.w	r2, r2, ip
 8003b52:	4313      	orrne	r3, r2
 8003b54:	f04f 0c01 	mov.w	ip, #1
 8003b58:	ea4c 2c0c 	orr.w	ip, ip, ip, lsl #8
 8003b5c:	ea4c 4c0c 	orr.w	ip, ip, ip, lsl #16
 8003b60:	eba3 020c 	sub.w	r2, r3, ip
 8003b64:	ea22 0203 	bic.w	r2, r2, r3
 8003b68:	ea12 12cc 	ands.w	r2, r2, ip, lsl #7
 8003b6c:	bf04      	itt	eq
 8003b6e:	f851 3b04 	ldreq.w	r3, [r1], #4
 8003b72:	3004      	addeq	r0, #4
 8003b74:	d0f4      	beq.n	8003b60 <strlen+0x30>
 8003b76:	f1c2 0100 	rsb	r1, r2, #0
 8003b7a:	ea02 0201 	and.w	r2, r2, r1
 8003b7e:	fab2 f282 	clz	r2, r2
 8003b82:	f1c2 021f 	rsb	r2, r2, #31
 8003b86:	eb00 00d2 	add.w	r0, r0, r2, lsr #3
 8003b8a:	4770      	bx	lr
 8003b8c:	0000      	movs	r0, r0
	...

08003b90 <strpbrk>:
 8003b90:	b430      	push	{r4, r5}
 8003b92:	7804      	ldrb	r4, [r0, #0]
 8003b94:	b1ec      	cbz	r4, 8003bd2 <strpbrk+0x42>
 8003b96:	780d      	ldrb	r5, [r1, #0]
 8003b98:	b1ad      	cbz	r5, 8003bc6 <strpbrk+0x36>
 8003b9a:	42ac      	cmp	r4, r5
 8003b9c:	d00e      	beq.n	8003bbc <strpbrk+0x2c>
 8003b9e:	460a      	mov	r2, r1
 8003ba0:	e001      	b.n	8003ba6 <strpbrk+0x16>
 8003ba2:	429c      	cmp	r4, r3
 8003ba4:	d009      	beq.n	8003bba <strpbrk+0x2a>
 8003ba6:	f812 3f01 	ldrb.w	r3, [r2, #1]!
 8003baa:	2b00      	cmp	r3, #0
 8003bac:	d1f9      	bne.n	8003ba2 <strpbrk+0x12>
 8003bae:	f810 4f01 	ldrb.w	r4, [r0, #1]!
 8003bb2:	2c00      	cmp	r4, #0
 8003bb4:	d1f0      	bne.n	8003b98 <strpbrk+0x8>
 8003bb6:	7815      	ldrb	r5, [r2, #0]
 8003bb8:	e000      	b.n	8003bbc <strpbrk+0x2c>
 8003bba:	4625      	mov	r5, r4
 8003bbc:	2d00      	cmp	r5, #0
 8003bbe:	bf08      	it	eq
 8003bc0:	2000      	moveq	r0, #0
 8003bc2:	bc30      	pop	{r4, r5}
 8003bc4:	4770      	bx	lr
 8003bc6:	f810 4f01 	ldrb.w	r4, [r0, #1]!
 8003bca:	460a      	mov	r2, r1
 8003bcc:	2c00      	cmp	r4, #0
 8003bce:	d1e3      	bne.n	8003b98 <strpbrk+0x8>
 8003bd0:	e7f1      	b.n	8003bb6 <strpbrk+0x26>
 8003bd2:	4620      	mov	r0, r4
 8003bd4:	bc30      	pop	{r4, r5}
 8003bd6:	4770      	bx	lr
	...

08003be0 <strspn>:
 8003be0:	b470      	push	{r4, r5, r6}
 8003be2:	7804      	ldrb	r4, [r0, #0]
 8003be4:	b1a4      	cbz	r4, 8003c10 <strspn+0x30>
 8003be6:	780e      	ldrb	r6, [r1, #0]
 8003be8:	4605      	mov	r5, r0
 8003bea:	b14e      	cbz	r6, 8003c00 <strspn+0x20>
 8003bec:	42b4      	cmp	r4, r6
 8003bee:	d00a      	beq.n	8003c06 <strspn+0x26>
 8003bf0:	460a      	mov	r2, r1
 8003bf2:	e001      	b.n	8003bf8 <strspn+0x18>
 8003bf4:	429c      	cmp	r4, r3
 8003bf6:	d006      	beq.n	8003c06 <strspn+0x26>
 8003bf8:	f812 3f01 	ldrb.w	r3, [r2, #1]!
 8003bfc:	2b00      	cmp	r3, #0
 8003bfe:	d1f9      	bne.n	8003bf4 <strspn+0x14>
 8003c00:	1a28      	subs	r0, r5, r0
 8003c02:	bc70      	pop	{r4, r5, r6}
 8003c04:	4770      	bx	lr
 8003c06:	f815 4f01 	ldrb.w	r4, [r5, #1]!
 8003c0a:	2c00      	cmp	r4, #0
 8003c0c:	d1ed      	bne.n	8003bea <strspn+0xa>
 8003c0e:	e7f7      	b.n	8003c00 <strspn+0x20>
 8003c10:	4620      	mov	r0, r4
 8003c12:	e7f6      	b.n	8003c02 <strspn+0x22>
	...
 8003c20:	0001c200 	.word	0x0001c200
 8003c24:	00000000 	.word	0x00000000
 8003c28:	00004000 	.word	0x00004000
 8003c2c:	00000000 	.word	0x00000000
 8003c30:	00002580 	.word	0x00002580
 8003c34:	00000000 	.word	0x00000000
 8003c38:	00004000 	.word	0x00004000
 8003c3c:	00000000 	.word	0x00000000

08003c40 <default_config>:
 8003c40:	00009600 00000000 00004000 00000000     .........@......
 8003c50:	6c756e28 0000296c 00000000 00000000     (null)..........

08003c60 <adcgrpcfg1>:
 8003c60:	00040000 00000000 08002b11 00002000     .........+... ..
 8003c70:	0fff0000 00000001 00000000 00000000     ................
 8003c80:	000081c0 00000000 00000000 00000000     ................
	...
 8003c98:	00007200 00000000 00000000 00000000     .r..............
	...

08003cb0 <adcgrpcfg2>:
 8003cb0:	00100001 08002b21 08002b11 00002000     ....!+...+... ..
 8003cc0:	0fff0000 01800001 04800000 00b40000     ................
 8003cd0:	081c81c0 00450207 00000000 00000000     ......E.........
 8003ce0:	00000120 00b40000 01081080 00411042      ...........B.A.
	...

08003d00 <_stm32_dma_streams>:
 8003d00:	40020008 40020004 000b0000 4002001c     ...@...@.......@
 8003d10:	40020004 000c0104 40020030 40020004     ...@....0..@...@
 8003d20:	000d0208 40020044 40020004 000e030c     ....D..@...@....
 8003d30:	40020058 40020004 000f0410 4002006c     X..@...@....l..@
 8003d40:	40020004 00100514 40020080 40020004     ...@.......@...@
 8003d50:	00110618 40020408 40020404 00380700     .......@...@..8.
 8003d60:	4002041c 40020404 00390804 40020430     ...@...@..9.0..@
 8003d70:	40020404 003a0908 40020444 40020404     ...@..:.D..@...@
 8003d80:	003b0a0c 40020458 40020404 003c0b10     ..;.X..@...@..<.

08003d90 <commands>:
 8003d90:	08004030 080033a1 08004034 08003301     0@...3..4@...3..
 8003da0:	0800403c 080032c1 08004043 08003181     <@...2..C@...1..
 8003db0:	08004047 08003151 0800404b 08003071     G@..Q1..K@..q0..
 8003dc0:	0800404f 08003041 08004057 08002fa1     O@..A0..W@.../..
 8003dd0:	0800405b 08002f61 00000000 00000000     [@..a/..........
 8003de0:	5f736167 736e6573 745f726f 68007473     gas_sensor_tst.h
 8003df0:	64696d75 5f797469 64616572 30255b00     umidity_read.[%0
 8003e00:	5d643031 63326920 69727720 65206574     10d] i2c write e
 8003e10:	726f7272 25203a20 322e3230 74612078     rror : %02.2x at
 8003e20:	64646120 73736572 32302520 0d78322e      address %02.2x.
 8003e30:	255b000a 64303130 3269205d 72652063     ..[%010d] i2c er
 8003e40:	20726f72 3025203a 78322e32 20746120     ror : %02.2x at 
 8003e50:	72646461 20737365 2e323025 0a0d7832     address %02.2x..
 8003e60:	30255b00 5d643031 63326920 61657220     .[%010d] i2c rea
 8003e70:	72652064 20726f72 3025203a 78322e32     d error : %02.2x
 8003e80:	20746120 72646461 20737365 2e323025      at address %02.
 8003e90:	0a0d7832 6c646900 5b0a0065 30313025     2x...idle..[%010
 8003ea0:	43205d64 6320324f 65636e6f 6172746e     d] CO2 concentra
 8003eb0:	6e6f6974 25203a20 70702064 000a0d6d     tion : %d ppm...
 8003ec0:	3130255b 205d6430 6f736261 6574756c     [%010d] absolute
 8003ed0:	65727020 72757373 203a2065 322e3625      pressure : %6.2
 8003ee0:	61502066 33252820 2066322e 67486d6d     f Pa (%3.2f mmHg
 8003ef0:	000a0d29 3130255b 205d6430 706d6574     )...[%010d] temp
 8003f00:	74617265 20657275 20202031 203a2020     erature 1     : 
 8003f10:	322e3225 65642066 43202e67 33252820     %2.2f deg. C (%3
 8003f20:	2066322e 2e676564 0d294620 255b000a     .2f deg. F)...[%
 8003f30:	64303130 6572205d 6974616c 68206576     010d] relative h
 8003f40:	64696d75 20797469 3225203a 2066322e     umidity : %2.2f 
 8003f50:	63726570 0d746e65 255b000a 64303130     percent...[%010d
 8003f60:	6574205d 7265706d 72757461 20322065     ] temperature 2 
 8003f70:	20202020 3225203a 2066322e 2e676564         : %2.2f deg.
 8003f80:	28204320 322e3325 65642066 46202e67      C (%3.2f deg. F
 8003f90:	000a0d29 3130255b 205d6430 31534147     )...[%010d] GAS1
 8003fa0:	43444120 77617220 20202020 203a2020      ADC raw      : 
 8003fb0:	30257830 78332e33 5b000a0d 30313025     0x%03.3x...[%010
 8003fc0:	47205d64 20325341 20434441 20776172     d] GAS2 ADC raw 
 8003fd0:	20202020 30203a20 33302578 0d78332e          : 0x%03.3x.
 8003fe0:	255b000a 64303130 4147205d 41203153     ..[%010d] GAS1 A
 8003ff0:	76204344 20746c6f 20202020 3025203a     DC volt     : %0
 8004000:	66332e31 0a0d5620 30255b00 5d643031     1.3f V...[%010d]
 8004010:	53414720 44412032 6f762043 2020746c      GAS2 ADC volt  
 8004020:	3a202020 31302520 2066332e 000a0d56        : %01.3f V...
 8004030:	006d656d 65726874 00736461 69726573     mem.threads.seri
 8004040:	69006c61 6c006332 7200676f 6e006267     al.i2c.log.rgb.n
 8004050:	6b706461 67007965 72007361 6f6f6265     adpkey.gas.reboo
 8004060:	00000074 00000000 00000000 00000000     t...............

08004070 <ch_debug>:
 8004070:	6e69616d 18031600 08440404 1814100c     main......D.....
 8004080:	1e1d1c00 0000001f 00000000 00000000     ................

08004090 <shell_cfg1>:
 8004090:	20000e88 08003d90 00000000 00000000     ... .=..........

080040a0 <pal_default_config>:
 80040a0:	2aa95f00 00000100 3c000000 64145055     ._.*.......<UP.d
 80040b0:	0000ffff 00000000 000ee770 00a1a001     ........p.......
	...
 80040c8:	15555545 0000feff 44000000 00007700     EUU........D.w..
 80040d8:	54000000 00000000 00000000 55555554     ...T........TUUU
 80040e8:	00001fff 00000000 00000000 00000000     ................
	...
 8004100:	55555555 0000ffff 00000000 00000000     UUUU............
	...
 800411c:	55555555 0000ffff 00000000 00000000     UUUU............
	...
 8004138:	55555550 0000ffff 00000000 00000000     PUUU............
	...

08004150 <i2cfg1>:
 8004150:	f0420f15 00000000 00000000 00000000     ..B.............

08004160 <states.9297>:
 8004160:	080045a3 080045a9 080045b1 080045b9     .E...E...E...E..
 8004170:	080045c3 080045ca 080045d0 080045d6     .E...E...E...E..
 8004180:	080045dd 080045e6 080045ed 080045f5     .E...E...E...E..
 8004190:	080045fe 08004606 0800460d 08004613     .E...F...F...F..
 80041a0:	6e696c62 3172656b 326f6300 6165725f     blinker1.co2_rea
 80041b0:	73550064 3a656761 0d732520 7973000a     d.Usage: %s...sy
 80041c0:	6d697473 6e690065 4b006f66 656e7265     stime.info.Kerne
 80041d0:	20203a6c 20202020 0d732520 2e33000a     l:       %s...3.
 80041e0:	00332e30 706d6f43 72656c69 2020203a     0.3.Compiler:   
 80041f0:	73252020 47000a0d 34204343 332e392e       %s...GCC 4.9.3
 8004200:	31303220 32353035 70282039 65726572      20150529 (prere
 8004210:	7361656c 41002965 69686372 74636574     lease).Architect
 8004220:	3a657275 0d732520 5241000a 2d37764d     ure: %s...ARMv7-
 8004230:	4300454d 2065726f 69726156 3a746e61     ME.Core Variant:
 8004240:	0d732520 6f43000a 78657472 46344d2d      %s...Cortex-M4F
 8004250:	726f5000 6e492074 203a6f66 25202020     .Port Info:    %
 8004260:	000a0d73 61766441 6465636e 72656b20     s...Advanced ker
 8004270:	206c656e 65646f6d 616c5000 726f6674     nel mode.Platfor
 8004280:	20203a6d 25202020 000a0d73 334d5453     m:     %s...STM3
 8004290:	30334632 20437833 6c616e41 2620676f     2F303xC Analog &
 80042a0:	50534420 616f4200 203a6472 20202020      DSP.Board:     
 80042b0:	25202020 000a0d73 41414141 20414141        %s...AAAAAAA 
 80042c0:	204c574f 312e3076 69754200 7420646c     OWL v0.1.Build t
 80042d0:	3a656d69 25202020 25732573 000a0d73     ime:   %s%s%s...
 80042e0:	2079614d 32203532 00373130 00202d20     May 25 2017. - .
 80042f0:	323a3931 37333a38 65687300 0d006c6c     19:28:37.shell..
 8004300:	6968430a 534f6962 2054522f 6c656853     .ChibiOS/RT Shel
 8004310:	000a0d6c 3e6c776f 445e0020 6c0a0d00     l...owl> .^D...l
 8004320:	756f676f 6f740074 616d206f 6120796e     ogout.too many a
 8004330:	6d756772 73746e65 65000a0d 00746978     rguments...exit.
 8004340:	706c6568 6d6f4300 646e616d 68203a73     help.Commands: h
 8004350:	20706c65 74697865 73250020 73250020     elp exit .%s .%s
 8004360:	0d3f2000 7355000a 3a656761 62657220     . ?...Usage: reb
 8004370:	0d746f6f 6552000a 746f6f62 2e676e69     oot...Rebooting.
 8004380:	0a0d2e2e 61735500 203a6567 20736167     .....Usage: gas 
 8004390:	6e65733c 5f726f73 203e626e 307c315b     <sensor_nb> [1|0
 80043a0:	0d5d727c 6f50000a 20726577 47204e4f     |r]...Power ON G
 80043b0:	0a0d3153 776f5000 4f207265 47204646     S1...Power OFF G
 80043c0:	0a0d3153 776f5000 4f207265 5347204e     S1...Power ON GS
 80043d0:	000a0d32 65776f50 464f2072 53472046     2...Power OFF GS
 80043e0:	000a0d32 67617355 6e203a65 6b706461     2...Usage: nadpk
 80043f0:	0a0d7965 61735500 203a6567 20626772     ey...Usage: rgb 
 8004400:	6234323c 5f737469 5f786568 756c6176     <24bits_hex_valu
 8004410:	0a0d3e65 61735500 203a6567 20676f6c     e>...Usage: log 
 8004420:	307c315b 000a0d5d 67617355 69203a65     [1|0]...Usage: i
 8004430:	5b206332 5d727c77 65645b20 65636976     2c [w|r] [device
 8004440:	6464615f 5b205d72 5f676572 72646461     _addr] [reg_addr
 8004450:	645b205d 7c617461 6220626e 73657479     ] [data|nb bytes
 8004460:	206f7420 64616572 000a0d5d 6f727265      to read]...erro
 8004470:	203a2072 2e323025 0a0d7832 32302500     r : %02.2x...%02
 8004480:	7278322e 2e323025 203e7832 32302500     .2xr%02.2x> .%02
 8004490:	0078322e 003b002c 2e323025 25727832     .2x.,.;.%02.2xr%
 80044a0:	322e3230 30253c78 78322e32 55000a0d     02.2x<%02.2x...U
 80044b0:	65676173 6573203a 6c616972 4d000a0d     sage: serial...M
 80044c0:	73205543 61697265 203a206c 78383025     CU serial : %08x
 80044d0:	78383025 78383025 55000a0d 65676173     %08x%08x...Usage
 80044e0:	6874203a 64616572 000a0d73 20202020     : threads...    
 80044f0:	72646461 20202020 63617473 7270206b     addr    stack pr
 8004500:	72206f69 20736665 20202020 74617473     io refs     stat
 8004510:	000a0d65 6c383025 30252078 20786c38     e...%08lx %08lx 
 8004520:	756c3425 6c342520 39252075 6c252073     %4lu %4lu %9s %l
 8004530:	000a0d75 67617355 6d203a65 0a0d6d65     u...Usage: mem..
 8004540:	726f6300 72662065 6d206565 726f6d65     .core free memor
 8004550:	203a2079 62207525 73657479 68000a0d     y : %u bytes...h
 8004560:	20706165 67617266 746e656d 20202073     eap fragments   
 8004570:	7525203a 68000a0d 20706165 65657266     : %u...heap free
 8004580:	746f7420 20206c61 7525203a 74796220      total  : %u byt
 8004590:	0a0d7365 65727000 72757373 65725f65     es...pressure_re
 80045a0:	52006461 59444145 52554300 544e4552     ad.READY.CURRENT
 80045b0:	53545700 54524154 53555300 444e4550     .WTSTART.SUSPEND
 80045c0:	51004445 45554555 54570044 004d4553     ED.QUEUED.WTSEM.
 80045d0:	544d5457 54570058 444e4f43 454c5300     WTMTX.WTCOND.SLE
 80045e0:	4e495045 54570047 54495845 4f545700     EPING.WTEXIT.WTO
 80045f0:	54564552 41545700 5645444e 4e530054     REVT.WTANDEVT.SN
 8004600:	47534d44 4e530051 47534d44 4d545700     DMSGQ.SNDMSG.WTM
 8004610:	46004753 4c414e49 00000000 00000000     SG.FINAL........
 8004620:	00000920 00000000 00000000 00000000      ...............

08004630 <vmt>:
 8004630:	08000d61 08000e61 08000dd1 08000ed1     a...a...........
 8004640:	08000dc1 08000ec1 08000d51 08000e51     ........Q...Q...

08004650 <_ctype_>:
 8004650:	20202000 20202020 28282020 20282828     .         ((((( 
 8004660:	20202020 20202020 20202020 20202020                     
 8004670:	10108820 10101010 10101010 10101010      ...............
 8004680:	04040410 04040404 10040404 10101010     ................
 8004690:	41411010 41414141 01010101 01010101     ..AAAAAA........
 80046a0:	01010101 01010101 01010101 10101010     ................
 80046b0:	42421010 42424242 02020202 02020202     ..BBBBBB........
 80046c0:	02020202 02020202 02020202 10101010     ................
 80046d0:	00000020 00000000 00000000 00000000      ...............
	...
 8004760:	00000043                                C...
